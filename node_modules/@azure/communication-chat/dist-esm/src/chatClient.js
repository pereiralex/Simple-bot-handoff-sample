// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference lib="esnext.asynciterable" />
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter, __rest } from "tslib";
import { logger } from "./models/logger";
import { EventEmitter } from "events";
import { SDK_VERSION } from "./constants";
import { getSignalingClient } from "./signaling/signalingClient";
import { createPipelineFromOptions, operationOptionsToRequestOptionsBase, generateUuid } from "@azure/core-http";
import "@azure/core-paging";
import { CanonicalCode } from "@opentelemetry/api";
import { createSpan } from "./tracing";
import { ChatThreadClient } from "./chatThreadClient";
import { mapToChatParticipantRestModel, mapToCreateChatThreadOptionsRestModel, mapToCreateChatThreadResultSdkModel } from "./models/mappers";
import { createCommunicationTokenCredentialPolicy } from "./credential/communicationTokenCredentialPolicy";
import { ChatApiClient } from "./generated/src";
/**
 * The client to do chat operations
 */
export class ChatClient {
    /**
     * Creates an instance of the ChatClient for a given resource and user.
     *
     * @param endpoint - The url of the Communication Services resouce.
     * @param credential - The token credential. Use AzureCommunicationTokenCredential from \@azure/communication-common to create a credential.
     * @param options - Additional client options.
     */
    constructor(endpoint, credential, options = {}) {
        this.endpoint = endpoint;
        this.signalingClient = undefined;
        this.emitter = new EventEmitter();
        this.isRealtimeNotificationsStarted = false;
        this.tokenCredential = credential;
        this.clientOptions = Object.assign({}, options);
        const libInfo = `azsdk-js-communication-chat/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        const userAgentOptions = Object.assign({}, options.userAgentOptions);
        if (options.userAgentOptions.userAgentPrefix) {
            userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, Object.assign(Object.assign({}, options), { userAgentOptions })), {
            loggingOptions: {
                logger: logger.info
            }
        });
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new ChatApiClient(this.endpoint, pipeline);
        this.signalingClient = getSignalingClient(credential, logger);
    }
    /**
     * Returns ChatThreadClient with the specific thread id.
     * @param threadId - Thread ID for the ChatThreadClient
     */
    getChatThreadClient(threadId) {
        return new ChatThreadClient(this.endpoint, threadId, this.tokenCredential, this.clientOptions);
    }
    /**
     * Creates a chat thread.
     * Returns thread client with the id of the created thread.
     * @param request - Request for creating a chat thread.
     * @param options - Operation options.
     */
    createChatThread(request, options = {}) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatClient-CreateChatThread", options);
            try {
                // We generate an UUID if the user does not provide an idempotencyToken value
                updatedOptions.idempotencyToken = (_a = updatedOptions.idempotencyToken) !== null && _a !== void 0 ? _a : generateUuid();
                const updatedRestModelOptions = mapToCreateChatThreadOptionsRestModel(updatedOptions);
                const _c = yield this.client.chat.createChatThread({
                    topic: request.topic,
                    participants: (_b = options.participants) === null || _b === void 0 ? void 0 : _b.map((participant) => mapToChatParticipantRestModel(participant))
                }, operationOptionsToRequestOptionsBase(updatedRestModelOptions)), { _response } = _c, result = __rest(_c, ["_response"]);
                return mapToCreateChatThreadResultSdkModel(result);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listChatThreadsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listChatThreadsPage_1() {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.chat.listChatThreads(requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value);
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.chat.listChatThreadsNext(continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value);
                }
                else {
                    break;
                }
            }
        });
    }
    listChatThreadsAll(options) {
        return __asyncGenerator(this, arguments, function* listChatThreadsAll_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listChatThreadsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of chat threads of a user.
     * @param options - List chat threads options.
     */
    listChatThreads(options = {}) {
        const { span, updatedOptions } = createSpan("ChatClient-ListChatThreads", options);
        try {
            const iter = this.listChatThreadsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listChatThreadsPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a chat thread.
     * @param threadId - The ID of the thread to delete.
     * @param options -  Operation options.
     */
    deleteChatThread(threadId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatClient-DeleteChatThread", options);
            try {
                yield this.client.chat.deleteChatThread(threadId, operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Start receiving realtime notifications.
     * Call this function before subscribing to any event.
     */
    startRealtimeNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signalingClient === undefined) {
                throw new Error("Realtime notifications are only supported in the browser.");
            }
            if (this.isRealtimeNotificationsStarted) {
                return;
            }
            this.isRealtimeNotificationsStarted = true;
            this.signalingClient.start();
            this.subscribeToSignalingEvents();
        });
    }
    /**
     * Stop receiving realtime notifications.
     * This function would unsubscribe to all events.
     */
    stopRealtimeNotifications() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.signalingClient === undefined) {
                throw new Error("Realtime notifications are only supported in the browser.");
            }
            this.isRealtimeNotificationsStarted = false;
            this.signalingClient.stop();
            this.emitter.removeAllListeners();
        });
    }
    on(event, listener) {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        if (!this.isRealtimeNotificationsStarted) {
            throw new Error("You must call startRealtimeNotifications before you can subscribe to events.");
        }
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.emitter.removeListener(event, listener);
    }
    subscribeToSignalingEvents() {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.signalingClient.on("chatMessageReceived", (payload) => {
            this.emitter.emit("chatMessageReceived", payload);
        });
        this.signalingClient.on("chatMessageEdited", (payload) => {
            this.emitter.emit("chatMessageEdited", payload);
        });
        this.signalingClient.on("chatMessageDeleted", (payload) => {
            this.emitter.emit("chatMessageDeleted", payload);
        });
        this.signalingClient.on("typingIndicatorReceived", (payload) => {
            this.emitter.emit("typingIndicatorReceived", payload);
        });
        this.signalingClient.on("readReceiptReceived", (payload) => {
            this.emitter.emit("readReceiptReceived", payload);
        });
        this.signalingClient.on("chatThreadCreated", (payload) => {
            this.emitter.emit("chatThreadCreated", payload);
        });
        this.signalingClient.on("chatThreadDeleted", (payload) => {
            this.emitter.emit("chatThreadDeleted", payload);
        });
        this.signalingClient.on("chatThreadPropertiesUpdated", (payload) => {
            this.emitter.emit("chatThreadPropertiesUpdated", payload);
        });
        this.signalingClient.on("participantsAdded", (payload) => {
            this.emitter.emit("participantsAdded", payload);
        });
        this.signalingClient.on("participantsRemoved", (payload) => {
            this.emitter.emit("participantsRemoved", payload);
        });
    }
}
//# sourceMappingURL=chatClient.js.map