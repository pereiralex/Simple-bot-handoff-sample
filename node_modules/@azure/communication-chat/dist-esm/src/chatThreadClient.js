// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter, __rest } from "tslib";
import { logger } from "./models/logger";
import { SDK_VERSION } from "./constants";
import { serializeCommunicationIdentifier } from "@azure/communication-common";
import { createPipelineFromOptions, operationOptionsToRequestOptionsBase } from "@azure/core-http";
import { CanonicalCode } from "@opentelemetry/api";
import { createSpan } from "./tracing";
import { mapToAddChatParticipantsRequestRestModel, mapToChatMessageSdkModel, mapToChatParticipantSdkModel, mapToChatThreadPropertiesSdkModel, mapToReadReceiptSdkModel } from "./models/mappers";
import { ChatApiClient } from "./generated/src";
import { createCommunicationTokenCredentialPolicy } from "./credential/communicationTokenCredentialPolicy";
const minimumTypingIntervalInMilliSeconds = 8000;
/**
 * The client to do chat operations
 */
export class ChatThreadClient {
    constructor(endpoint, threadId, credential, options = {}) {
        this.endpoint = endpoint;
        this.timeOfLastTypingRequest = undefined;
        this.threadId = threadId;
        this.tokenCredential = credential;
        const libInfo = `azsdk-js-communication-chat/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        const userAgentOptions = Object.assign({}, options.userAgentOptions);
        if (options.userAgentOptions.userAgentPrefix) {
            userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, Object.assign(Object.assign({}, options), { userAgentOptions })), {
            loggingOptions: {
                logger: logger.info
            }
        });
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        const pipeline = createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new ChatApiClient(this.endpoint, pipeline);
    }
    /**
     * Gets a chat thread.
     * Returns the chat thread.
     * @param options -  Operation options.
     */
    getProperties(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatClient-GetProperties", options);
            try {
                const _a = yield this.client.chatThread.getChatThreadProperties(this.threadId, operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = __rest(_a, ["_response"]);
                return mapToChatThreadPropertiesSdkModel(result);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Updates a thread's topic.
     * @param topic - The topic needs to be updated to.
     * @param options - Operation options.
     */
    updateTopic(topic, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-UpdateTopic", options);
            try {
                yield this.client.chatThread.updateChatThreadProperties(this.threadId, { topic: topic }, operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Sends a chat message to a thread identified by threadId.
     * Returns the id of the created message.
     * @param request - Request for sending a message.
     * @param options - Operation options.
     */
    sendMessage(request, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-SendMessage", options);
            try {
                // reset typing notification clock
                this.timeOfLastTypingRequest = undefined;
                const _a = yield this.client.chatThread.sendChatMessage(this.threadId, Object.assign(Object.assign({}, request), options), operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = __rest(_a, ["_response"]);
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Gets a chat message identified by messageId.
     * Returns the specific message.
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    getMessage(messageId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-GetMessage", options);
            try {
                const _a = yield this.client.chatThread.getChatMessage(this.threadId, messageId, operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = __rest(_a, ["_response"]);
                return mapToChatMessageSdkModel(result);
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listMessagesPage(pageSettings, options = {}) {
        return __asyncGenerator(this, arguments, function* listMessagesPage_1() {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            if (!pageSettings.continuationToken) {
                const currentSetResponse = yield __await(this.client.chatThread.listChatMessages(this.threadId, requestOptions));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
                }
            }
            while (pageSettings.continuationToken) {
                const currentSetResponse = yield __await(this.client.chatThread.listChatMessagesNext(this.threadId, pageSettings.continuationToken, requestOptions));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listMessagesAll(options) {
        return __asyncGenerator(this, arguments, function* listMessagesAll_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listMessagesPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of message from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */
    listMessages(options = {}) {
        const { span, updatedOptions } = createSpan("ChatThreadClient-ListMessages", options);
        try {
            const iter = this.listMessagesAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listMessagesPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    deleteMessage(messageId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-DeleteMessage", options);
            try {
                yield this.client.chatThread.deleteChatMessage(this.threadId, messageId, operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Updates a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    updateMessage(messageId, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-UpdateMessage", options);
            try {
                yield this.client.chatThread.updateChatMessage(this.threadId, messageId, options, operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Adds the details of chat participants belonging to the thread identified by threadId.
     * @param request - Thread participants' details to add in the thread roster
     * @param options - Operation options.
     */
    addParticipants(request, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-AddParticipants", options);
            try {
                const _a = yield this.client.chatThread.addChatParticipants(this.threadId, mapToAddChatParticipantsRequestRestModel(request), operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = __rest(_a, ["_response"]);
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listParticipantsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listParticipantsPage_1() {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.chatThread.listChatParticipants(this.threadId, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.chatThread.listChatParticipantsNext(this.threadId, continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listParticipantsAll(options) {
        return __asyncGenerator(this, arguments, function* listParticipantsAll_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.listParticipantsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the participants of the thread identified by threadId.
     * Returns the lists of the participants.
     * @param options - Operation options.
     */
    listParticipants(options = {}) {
        const { span, updatedOptions } = createSpan("ChatThreadClient-ListParticipants", options);
        try {
            const iter = this.listParticipantsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listParticipantsPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes participant from the thread identified by threadId.
     * @param participant - Thread participant to remove from the thread roster
     * @param options - Operation options.
     */
    removeParticipant(participant, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-RemoveParticipant", options);
            try {
                yield this.client.chatThread.removeChatParticipant(this.threadId, serializeCommunicationIdentifier(participant), operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Sends a typing notification to the thread.
     * Doesn't attempt to send if the time since last notification is smaller than the minimum typing interval
     * @param options - - Operation options
     * @returns True if the typing message notification could be sent, otherwise false.
     */
    sendTypingNotification(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-SendTypingNotification", options);
            try {
                const dateNow = new Date();
                if (this.canPostTypingNotification(dateNow)) {
                    yield this.client.chatThread.sendTypingNotification(this.threadId, operationOptionsToRequestOptionsBase(updatedOptions));
                    this.timeOfLastTypingRequest = dateNow;
                    return true;
                }
                logger.info(`Typing Notification NOT Send. [thread_id=${this.threadId}]`);
                return false;
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Sends a read receipt to the thread identified by threadId.
     * @param messageId - The message id of the message that user latest read.
     * @param request - Request for sending a read receipt
     * @param options - Operation options.
     */
    sendReadReceipt(request, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-SendReadReceipt", options);
            try {
                yield this.client.chatThread.sendChatReadReceipt(this.threadId, request, operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listReadReceiptsPage(continuationState, options = {}) {
        return __asyncGenerator(this, arguments, function* listReadReceiptsPage_1() {
            const requestOptions = operationOptionsToRequestOptionsBase(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceipts(this.threadId, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield __await(this.client.chatThread.listChatReadReceiptsNext(this.threadId, continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield __await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listReadReceiptsAll(options) {
        return __asyncGenerator(this, arguments, function* listReadReceiptsAll_1() {
            var e_3, _a;
            try {
                for (var _b = __asyncValues(this.listReadReceiptsPage({}, options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield __await(yield* __asyncDelegator(__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets a list of read receipt from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */
    listReadReceipts(options = {}) {
        const { span, updatedOptions } = createSpan("ChatThreadClient-ListChatReadReceipts", options);
        try {
            const iter = this.listReadReceiptsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listReadReceiptsPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    canPostTypingNotification(dateNow) {
        if (this.timeOfLastTypingRequest) {
            const timeSinceLastRequestInMilliSeconds = dateNow.getTime() - this.timeOfLastTypingRequest.getTime();
            if (timeSinceLastRequestInMilliSeconds < minimumTypingIntervalInMilliSeconds) {
                logger.info(`Typing interval check failed. [last_request=${this.timeOfLastTypingRequest}]`);
                return false;
            }
        }
        return true;
    }
}
//# sourceMappingURL=chatThreadClient.js.map