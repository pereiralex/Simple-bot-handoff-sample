'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var logger$1 = require('@azure/logger');
var events = require('events');
var coreHttp = require('@azure/core-http');
require('@azure/core-paging');
var api = require('@opentelemetry/api');
var coreTracing = require('@azure/core-tracing');
var communicationCommon = require('@azure/communication-common');

// Copyright (c) Microsoft Corporation.
const logger = logger$1.createClientLogger("communication-chat");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "1.0.0";

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const getSignalingClient = (_credential, _logger) => {
    return undefined;
};

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @internal
 */
const createSpan = coreTracing.createSpanFunction({
    packagePrefix: "Azure.Communication",
    namespace: "Microsoft.Communication"
});

// Copyright (c) Microsoft Corporation.
const mapToCreateChatThreadOptionsRestModel = (options) => {
    const { participants, idempotencyToken } = options, rest = tslib.__rest(options, ["participants", "idempotencyToken"]);
    return Object.assign({ repeatabilityRequestId: idempotencyToken }, rest);
};
/**
 * @internal
 * Mapping chat participant customer model to chat participant REST model
 */
const mapToChatParticipantRestModel = (chatParticipant) => {
    const { id } = chatParticipant, rest = tslib.__rest(chatParticipant, ["id"]);
    return Object.assign(Object.assign({}, rest), { communicationIdentifier: communicationCommon.serializeCommunicationIdentifier(id) });
};
/**
 * @internal
 * Mapping add participants request to add chat participants request REST model
 */
const mapToAddChatParticipantsRequestRestModel = (addParticipantsRequest) => {
    var _a;
    return {
        participants: (_a = addParticipantsRequest.participants) === null || _a === void 0 ? void 0 : _a.map((participant) => mapToChatParticipantRestModel(participant))
    };
};
/**
 * @internal
 */
const mapToChatContentSdkModel = (content) => {
    const { participants, initiatorCommunicationIdentifier } = content, otherChatContents = tslib.__rest(content, ["participants", "initiatorCommunicationIdentifier"]);
    let result = Object.assign({}, otherChatContents);
    if (initiatorCommunicationIdentifier) {
        const initiator = communicationCommon.deserializeCommunicationIdentifier(initiatorCommunicationIdentifier);
        result = Object.assign(Object.assign({}, result), { initiator });
    }
    if (participants) {
        result = Object.assign(Object.assign({}, result), { participants: participants === null || participants === void 0 ? void 0 : participants.map((participant) => mapToChatParticipantSdkModel(participant)) });
    }
    return result;
};
/**
 * @internal
 * Mapping chat message REST model to chat message SDK model
 */
const mapToChatMessageSdkModel = (chatMessage) => {
    const { content, senderCommunicationIdentifier } = chatMessage, otherChatMessage = tslib.__rest(chatMessage, ["content", "senderCommunicationIdentifier"]);
    const contentSdkModel = content ? mapToChatContentSdkModel(content) : undefined;
    if (senderCommunicationIdentifier) {
        return Object.assign({ sender: communicationCommon.deserializeCommunicationIdentifier(senderCommunicationIdentifier), content: contentSdkModel }, otherChatMessage);
    }
    else {
        return Object.assign({ content: contentSdkModel }, otherChatMessage);
    }
};
/**
 * @internal
 * Mapping chat participant REST model to chat participant SDK model
 */
const mapToChatParticipantSdkModel = (chatParticipant) => {
    const { communicationIdentifier } = chatParticipant, rest = tslib.__rest(chatParticipant, ["communicationIdentifier"]);
    return Object.assign(Object.assign({}, rest), { id: communicationCommon.deserializeCommunicationIdentifier(communicationIdentifier) });
};
/**
 * @internal
 * Mapping chat thread REST model to chat thread SDK model
 */
const mapToChatThreadPropertiesSdkModel = (chatThread) => {
    const { createdByCommunicationIdentifier } = chatThread, rest = tslib.__rest(chatThread, ["createdByCommunicationIdentifier"]);
    if (createdByCommunicationIdentifier) {
        return Object.assign(Object.assign({}, rest), { createdBy: communicationCommon.deserializeCommunicationIdentifier(createdByCommunicationIdentifier) });
    }
    else {
        return Object.assign({}, rest);
    }
};
/**
 * @internal
 * Mapping chat thread REST model to chat thread SDK model
 */
const mapToCreateChatThreadResultSdkModel = (result) => {
    const { chatThread } = result, rest = tslib.__rest(result, ["chatThread"]);
    if (chatThread) {
        return Object.assign(Object.assign({}, rest), { chatThread: mapToChatThreadPropertiesSdkModel(chatThread) });
    }
    else {
        return Object.assign({}, rest);
    }
};
/**
 * @internal
 * Mapping read receipt REST model to read receipt SDK model
 */
const mapToReadReceiptSdkModel = (readReceipt) => {
    const { senderCommunicationIdentifier } = readReceipt, rest = tslib.__rest(readReceipt, ["senderCommunicationIdentifier"]);
    return Object.assign(Object.assign({}, rest), { sender: communicationCommon.deserializeCommunicationIdentifier(senderCommunicationIdentifier) });
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const ChatMessageReadReceiptsCollection = {
    type: {
        name: "Composite",
        className: "ChatMessageReadReceiptsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatMessageReadReceipt"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatMessageReadReceipt = {
    type: {
        name: "Composite",
        className: "ChatMessageReadReceipt",
        modelProperties: {
            senderCommunicationIdentifier: {
                serializedName: "senderCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            chatMessageId: {
                serializedName: "chatMessageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            readOn: {
                serializedName: "readOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CommunicationIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationIdentifierModel",
        modelProperties: {
            rawId: {
                serializedName: "rawId",
                type: {
                    name: "String"
                }
            },
            communicationUser: {
                serializedName: "communicationUser",
                type: {
                    name: "Composite",
                    className: "CommunicationUserIdentifierModel"
                }
            },
            phoneNumber: {
                serializedName: "phoneNumber",
                type: {
                    name: "Composite",
                    className: "PhoneNumberIdentifierModel"
                }
            },
            microsoftTeamsUser: {
                serializedName: "microsoftTeamsUser",
                type: {
                    name: "Composite",
                    className: "MicrosoftTeamsUserIdentifierModel"
                }
            }
        }
    }
};
const CommunicationUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationUserIdentifierModel",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PhoneNumberIdentifierModel = {
    type: {
        name: "Composite",
        className: "PhoneNumberIdentifierModel",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MicrosoftTeamsUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "MicrosoftTeamsUserIdentifierModel",
        modelProperties: {
            userId: {
                serializedName: "userId",
                required: true,
                type: {
                    name: "String"
                }
            },
            isAnonymous: {
                serializedName: "isAnonymous",
                type: {
                    name: "Boolean"
                }
            },
            cloud: {
                serializedName: "cloud",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommunicationErrorResponse = {
    type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ChatError"
                }
            }
        }
    }
};
const ChatError = {
    type: {
        name: "Composite",
        className: "ChatError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ChatError"
                }
            }
        }
    }
};
const SendReadReceiptRequest = {
    type: {
        name: "Composite",
        className: "SendReadReceiptRequest",
        modelProperties: {
            chatMessageId: {
                serializedName: "chatMessageId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SendChatMessageRequest = {
    type: {
        name: "Composite",
        className: "SendChatMessageRequest",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            senderDisplayName: {
                serializedName: "senderDisplayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SendChatMessageResult = {
    type: {
        name: "Composite",
        className: "SendChatMessageResult",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatMessagesCollection = {
    type: {
        name: "Composite",
        className: "ChatMessagesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatMessage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatMessage = {
    type: {
        name: "Composite",
        className: "ChatMessage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            sequenceId: {
                serializedName: "sequenceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                required: true,
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "Composite",
                    className: "ChatMessageContent"
                }
            },
            senderDisplayName: {
                serializedName: "senderDisplayName",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            senderCommunicationIdentifier: {
                serializedName: "senderCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime"
                }
            },
            editedOn: {
                serializedName: "editedOn",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ChatMessageContent = {
    type: {
        name: "Composite",
        className: "ChatMessageContent",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            topic: {
                serializedName: "topic",
                type: {
                    name: "String"
                }
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            },
            initiatorCommunicationIdentifier: {
                serializedName: "initiatorCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            }
        }
    }
};
const ChatParticipant = {
    type: {
        name: "Composite",
        className: "ChatParticipant",
        modelProperties: {
            communicationIdentifier: {
                serializedName: "communicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            shareHistoryTime: {
                serializedName: "shareHistoryTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const UpdateChatMessageRequest = {
    type: {
        name: "Composite",
        className: "UpdateChatMessageRequest",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatParticipantsCollection = {
    type: {
        name: "Composite",
        className: "ChatParticipantsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddChatParticipantsRequest = {
    type: {
        name: "Composite",
        className: "AddChatParticipantsRequest",
        modelProperties: {
            participants: {
                serializedName: "participants",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            }
        }
    }
};
const AddChatParticipantsResult = {
    type: {
        name: "Composite",
        className: "AddChatParticipantsResult",
        modelProperties: {
            invalidParticipants: {
                serializedName: "invalidParticipants",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError"
                        }
                    }
                }
            }
        }
    }
};
const CreateChatThreadRequest = {
    type: {
        name: "Composite",
        className: "CreateChatThreadRequest",
        modelProperties: {
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String"
                }
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            }
        }
    }
};
const CreateChatThreadResult = {
    type: {
        name: "Composite",
        className: "CreateChatThreadResult",
        modelProperties: {
            chatThread: {
                serializedName: "chatThread",
                type: {
                    name: "Composite",
                    className: "ChatThreadProperties"
                }
            },
            invalidParticipants: {
                serializedName: "invalidParticipants",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError"
                        }
                    }
                }
            }
        }
    }
};
const ChatThreadProperties = {
    type: {
        name: "Composite",
        className: "ChatThreadProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            createdByCommunicationIdentifier: {
                serializedName: "createdByCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ChatThreadsItemCollection = {
    type: {
        name: "Composite",
        className: "ChatThreadsItemCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatThreadItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatThreadItem = {
    type: {
        name: "Composite",
        className: "ChatThreadItem",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String"
                }
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime"
                }
            },
            lastMessageReceivedOn: {
                serializedName: "lastMessageReceivedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const UpdateChatThreadRequest = {
    type: {
        name: "Composite",
        className: "UpdateChatThreadRequest",
        modelProperties: {
            topic: {
                serializedName: "topic",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ChatMessageReadReceiptsCollection: ChatMessageReadReceiptsCollection,
    ChatMessageReadReceipt: ChatMessageReadReceipt,
    CommunicationIdentifierModel: CommunicationIdentifierModel,
    CommunicationUserIdentifierModel: CommunicationUserIdentifierModel,
    PhoneNumberIdentifierModel: PhoneNumberIdentifierModel,
    MicrosoftTeamsUserIdentifierModel: MicrosoftTeamsUserIdentifierModel,
    CommunicationErrorResponse: CommunicationErrorResponse,
    ChatError: ChatError,
    SendReadReceiptRequest: SendReadReceiptRequest,
    SendChatMessageRequest: SendChatMessageRequest,
    SendChatMessageResult: SendChatMessageResult,
    ChatMessagesCollection: ChatMessagesCollection,
    ChatMessage: ChatMessage,
    ChatMessageContent: ChatMessageContent,
    ChatParticipant: ChatParticipant,
    UpdateChatMessageRequest: UpdateChatMessageRequest,
    ChatParticipantsCollection: ChatParticipantsCollection,
    AddChatParticipantsRequest: AddChatParticipantsRequest,
    AddChatParticipantsResult: AddChatParticipantsResult,
    CreateChatThreadRequest: CreateChatThreadRequest,
    CreateChatThreadResult: CreateChatThreadResult,
    ChatThreadProperties: ChatThreadProperties,
    ChatThreadsItemCollection: ChatThreadsItemCollection,
    ChatThreadItem: ChatThreadItem,
    UpdateChatThreadRequest: UpdateChatThreadRequest
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const chatThreadId = {
    parameterPath: "chatThreadId",
    mapper: {
        serializedName: "chatThreadId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
        serializedName: "maxPageSize",
        type: {
            name: "Number"
        }
    }
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        serializedName: "skip",
        type: {
            name: "Number"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-03-07",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const sendReadReceiptRequest = {
    parameterPath: "sendReadReceiptRequest",
    mapper: SendReadReceiptRequest
};
const sendChatMessageRequest = {
    parameterPath: "sendChatMessageRequest",
    mapper: SendChatMessageRequest
};
const startTime = {
    parameterPath: ["options", "startTime"],
    mapper: {
        serializedName: "startTime",
        type: {
            name: "DateTime"
        }
    }
};
const chatMessageId = {
    parameterPath: "chatMessageId",
    mapper: {
        serializedName: "chatMessageId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/merge-patch+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const updateChatMessageRequest = {
    parameterPath: "updateChatMessageRequest",
    mapper: UpdateChatMessageRequest
};
const participantCommunicationIdentifier = {
    parameterPath: "participantCommunicationIdentifier",
    mapper: CommunicationIdentifierModel
};
const addChatParticipantsRequest = {
    parameterPath: "addChatParticipantsRequest",
    mapper: AddChatParticipantsRequest
};
const updateChatThreadRequest = {
    parameterPath: "updateChatThreadRequest",
    mapper: UpdateChatThreadRequest
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const createChatThreadRequest = {
    parameterPath: "createChatThreadRequest",
    mapper: CreateChatThreadRequest
};
const repeatabilityRequestId = {
    parameterPath: ["options", "repeatabilityRequestId"],
    mapper: {
        serializedName: "repeatability-request-id",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a ChatThread. */
class ChatThread {
    /**
     * Initialize a new instance of the class ChatThread class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Gets chat message read receipts for a thread.
     * @param chatThreadId Thread id to get the chat message read receipts for.
     * @param options The options parameters.
     */
    listChatReadReceipts(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatReadReceiptsOperationSpec);
    }
    /**
     * Sends a read receipt event to a thread, on behalf of a user.
     * @param chatThreadId Thread id to send the read receipt event to.
     * @param sendReadReceiptRequest Read receipt details.
     * @param options The options parameters.
     */
    sendChatReadReceipt(chatThreadId, sendReadReceiptRequest, options) {
        const operationArguments = {
            chatThreadId,
            sendReadReceiptRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, sendChatReadReceiptOperationSpec);
    }
    /**
     * Sends a message to a thread.
     * @param chatThreadId The thread id to send the message to.
     * @param sendChatMessageRequest Details of the message to send.
     * @param options The options parameters.
     */
    sendChatMessage(chatThreadId, sendChatMessageRequest, options) {
        const operationArguments = {
            chatThreadId,
            sendChatMessageRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, sendChatMessageOperationSpec);
    }
    /**
     * Gets a list of messages from a thread.
     * @param chatThreadId The thread id of the message.
     * @param options The options parameters.
     */
    listChatMessages(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatMessagesOperationSpec);
    }
    /**
     * Gets a message by id.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param options The options parameters.
     */
    getChatMessage(chatThreadId, chatMessageId, options) {
        const operationArguments = {
            chatThreadId,
            chatMessageId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getChatMessageOperationSpec);
    }
    /**
     * Updates a message.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param updateChatMessageRequest Details of the request to update the message.
     * @param options The options parameters.
     */
    updateChatMessage(chatThreadId, chatMessageId, updateChatMessageRequest, options) {
        const operationArguments = {
            chatThreadId,
            chatMessageId,
            updateChatMessageRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, updateChatMessageOperationSpec);
    }
    /**
     * Deletes a message.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param options The options parameters.
     */
    deleteChatMessage(chatThreadId, chatMessageId, options) {
        const operationArguments = {
            chatThreadId,
            chatMessageId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteChatMessageOperationSpec);
    }
    /**
     * Posts a typing event to a thread, on behalf of a user.
     * @param chatThreadId Id of the thread.
     * @param options The options parameters.
     */
    sendTypingNotification(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, sendTypingNotificationOperationSpec);
    }
    /**
     * Gets the participants of a thread.
     * @param chatThreadId Thread id to get participants for.
     * @param options The options parameters.
     */
    listChatParticipants(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatParticipantsOperationSpec);
    }
    /**
     * Remove a participant from a thread.
     * @param chatThreadId Thread id to remove the participant from.
     * @param participantCommunicationIdentifier Id of the thread participant to remove from the thread.
     * @param options The options parameters.
     */
    removeChatParticipant(chatThreadId, participantCommunicationIdentifier, options) {
        const operationArguments = {
            chatThreadId,
            participantCommunicationIdentifier,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, removeChatParticipantOperationSpec);
    }
    /**
     * Adds thread participants to a thread. If participants already exist, no change occurs.
     * @param chatThreadId Id of the thread to add participants to.
     * @param addChatParticipantsRequest Thread participants to be added to the thread.
     * @param options The options parameters.
     */
    addChatParticipants(chatThreadId, addChatParticipantsRequest, options) {
        const operationArguments = {
            chatThreadId,
            addChatParticipantsRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, addChatParticipantsOperationSpec);
    }
    /**
     * Updates a thread's properties.
     * @param chatThreadId The id of the thread to update.
     * @param updateChatThreadRequest Request payload for updating a chat thread.
     * @param options The options parameters.
     */
    updateChatThreadProperties(chatThreadId, updateChatThreadRequest, options) {
        const operationArguments = {
            chatThreadId,
            updateChatThreadRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, updateChatThreadPropertiesOperationSpec);
    }
    /**
     * Gets a chat thread's properties.
     * @param chatThreadId Id of the thread.
     * @param options The options parameters.
     */
    getChatThreadProperties(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getChatThreadPropertiesOperationSpec);
    }
    /**
     * ListChatReadReceiptsNext
     * @param chatThreadId Thread id to get the chat message read receipts for.
     * @param nextLink The nextLink from the previous successful call to the ListChatReadReceipts method.
     * @param options The options parameters.
     */
    listChatReadReceiptsNext(chatThreadId, nextLink, options) {
        const operationArguments = {
            chatThreadId,
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatReadReceiptsNextOperationSpec);
    }
    /**
     * ListChatMessagesNext
     * @param chatThreadId The thread id of the message.
     * @param nextLink The nextLink from the previous successful call to the ListChatMessages method.
     * @param options The options parameters.
     */
    listChatMessagesNext(chatThreadId, nextLink, options) {
        const operationArguments = {
            chatThreadId,
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatMessagesNextOperationSpec);
    }
    /**
     * ListChatParticipantsNext
     * @param chatThreadId Thread id to get participants for.
     * @param nextLink The nextLink from the previous successful call to the ListChatParticipants method.
     * @param options The options parameters.
     */
    listChatParticipantsNext(chatThreadId, nextLink, options) {
        const operationArguments = {
            chatThreadId,
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatParticipantsNextOperationSpec);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const listChatReadReceiptsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/readReceipts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessageReadReceiptsCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        skip,
        apiVersion
    ],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer
};
const sendChatReadReceiptOperationSpec = {
    path: "/chat/threads/{chatThreadId}/readReceipts",
    httpMethod: "POST",
    responses: {
        200: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: sendReadReceiptRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const sendChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: SendChatMessageResult
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: sendChatMessageRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const listChatMessagesOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessagesCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
    ],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer
};
const getChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessage
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId
    ],
    headerParameters: [accept],
    serializer
};
const updateChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "PATCH",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: updateChatMessageRequest,
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId
    ],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer
};
const deleteChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [
        endpoint,
        chatThreadId,
        chatMessageId
    ],
    headerParameters: [accept],
    serializer
};
const sendTypingNotificationOperationSpec = {
    path: "/chat/threads/{chatThreadId}/typing",
    httpMethod: "POST",
    responses: {
        200: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer
};
const listChatParticipantsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatParticipantsCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        skip,
        apiVersion
    ],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer
};
const removeChatParticipantOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants/:remove",
    httpMethod: "POST",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: participantCommunicationIdentifier,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const addChatParticipantsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants/:add",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: AddChatParticipantsResult
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: addChatParticipantsRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType],
    mediaType: "json",
    serializer
};
const updateChatThreadPropertiesOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "PATCH",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: updateChatThreadRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer
};
const getChatThreadPropertiesOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatThreadProperties
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer
};
const listChatReadReceiptsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessageReadReceiptsCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        skip,
        apiVersion
    ],
    urlParameters: [
        endpoint,
        chatThreadId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listChatMessagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatMessagesCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
    ],
    urlParameters: [
        endpoint,
        chatThreadId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};
const listChatParticipantsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatParticipantsCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        skip,
        apiVersion
    ],
    urlParameters: [
        endpoint,
        chatThreadId,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class representing a Chat. */
class Chat {
    /**
     * Initialize a new instance of the class Chat class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Creates a chat thread.
     * @param createChatThreadRequest Request payload for creating a chat thread.
     * @param options The options parameters.
     */
    createChatThread(createChatThreadRequest, options) {
        const operationArguments = {
            createChatThreadRequest,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createChatThreadOperationSpec);
    }
    /**
     * Gets the list of chat threads of a user.
     * @param options The options parameters.
     */
    listChatThreads(options) {
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatThreadsOperationSpec);
    }
    /**
     * Deletes a thread.
     * @param chatThreadId Id of the thread to be deleted.
     * @param options The options parameters.
     */
    deleteChatThread(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteChatThreadOperationSpec);
    }
    /**
     * ListChatThreadsNext
     * @param nextLink The nextLink from the previous successful call to the ListChatThreads method.
     * @param options The options parameters.
     */
    listChatThreadsNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatThreadsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = new coreHttp.Serializer(Mappers, /* isXml */ false);
const createChatThreadOperationSpec = {
    path: "/chat/threads",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: CreateChatThreadResult
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: createChatThreadRequest,
    queryParameters: [apiVersion],
    urlParameters: [endpoint],
    headerParameters: [
        accept,
        contentType,
        repeatabilityRequestId
    ],
    mediaType: "json",
    serializer: serializer$1
};
const listChatThreadsOperationSpec = {
    path: "/chat/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatThreadsItemCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
    ],
    urlParameters: [endpoint],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteChatThreadOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [endpoint, chatThreadId],
    headerParameters: [accept],
    serializer: serializer$1
};
const listChatThreadsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ChatThreadsItemCollection
        },
        401: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        maxPageSize,
        apiVersion,
        startTime
    ],
    urlParameters: [endpoint, nextLink],
    headerParameters: [accept],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "azure-communication-chat";
const packageVersion = "1.0.0";
class ChatApiClientContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the ChatApiClientContext class.
     * @param endpoint The endpoint of the Azure Communication resource.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        if (!options.userAgent) {
            const defaultUserAgent = coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}";
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2021-03-07";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
class ChatApiClient extends ChatApiClientContext {
    /**
     * Initializes a new instance of the ChatApiClient class.
     * @param endpoint The endpoint of the Azure Communication resource.
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
        this.chatThread = new ChatThread(this);
        this.chat = new Chat(this);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a new CommunicationTokenCredentialPolicy factory.
 *
 * @param credential - The CommunicationTokenCredential implementation that can supply the user credential.
 */
const createCommunicationTokenCredentialPolicy = (credential) => {
    return coreHttp.bearerTokenAuthenticationPolicy({
        getToken: (_scopes, options) => credential.getToken({ abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal })
    }, []);
};

// Copyright (c) Microsoft Corporation.
const minimumTypingIntervalInMilliSeconds = 8000;
/**
 * The client to do chat operations
 */
class ChatThreadClient {
    constructor(endpoint, threadId, credential, options = {}) {
        this.endpoint = endpoint;
        this.timeOfLastTypingRequest = undefined;
        this.threadId = threadId;
        this.tokenCredential = credential;
        const libInfo = `azsdk-js-communication-chat/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        const userAgentOptions = Object.assign({}, options.userAgentOptions);
        if (options.userAgentOptions.userAgentPrefix) {
            userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, Object.assign(Object.assign({}, options), { userAgentOptions })), {
            loggingOptions: {
                logger: logger.info
            }
        });
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new ChatApiClient(this.endpoint, pipeline);
    }
    /**
     * Gets a chat thread.
     * Returns the chat thread.
     * @param options -  Operation options.
     */
    getProperties(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatClient-GetProperties", options);
            try {
                const _a = yield this.client.chatThread.getChatThreadProperties(this.threadId, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = tslib.__rest(_a, ["_response"]);
                return mapToChatThreadPropertiesSdkModel(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Updates a thread's topic.
     * @param topic - The topic needs to be updated to.
     * @param options - Operation options.
     */
    updateTopic(topic, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-UpdateTopic", options);
            try {
                yield this.client.chatThread.updateChatThreadProperties(this.threadId, { topic: topic }, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Sends a chat message to a thread identified by threadId.
     * Returns the id of the created message.
     * @param request - Request for sending a message.
     * @param options - Operation options.
     */
    sendMessage(request, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-SendMessage", options);
            try {
                // reset typing notification clock
                this.timeOfLastTypingRequest = undefined;
                const _a = yield this.client.chatThread.sendChatMessage(this.threadId, Object.assign(Object.assign({}, request), options), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = tslib.__rest(_a, ["_response"]);
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Gets a chat message identified by messageId.
     * Returns the specific message.
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    getMessage(messageId, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-GetMessage", options);
            try {
                const _a = yield this.client.chatThread.getChatMessage(this.threadId, messageId, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = tslib.__rest(_a, ["_response"]);
                return mapToChatMessageSdkModel(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listMessagesPage(pageSettings, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listMessagesPage_1() {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            if (!pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatMessages(this.threadId, requestOptions));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
                }
            }
            while (pageSettings.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatMessagesNext(this.threadId, pageSettings.continuationToken, requestOptions));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatMessageSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listMessagesAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listMessagesAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMessagesPage({}, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets a list of message from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */
    listMessages(options = {}) {
        const { span, updatedOptions } = createSpan("ChatThreadClient-ListMessages", options);
        try {
            const iter = this.listMessagesAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listMessagesPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    deleteMessage(messageId, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-DeleteMessage", options);
            try {
                yield this.client.chatThread.deleteChatMessage(this.threadId, messageId, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Updates a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */
    updateMessage(messageId, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-UpdateMessage", options);
            try {
                yield this.client.chatThread.updateChatMessage(this.threadId, messageId, options, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Adds the details of chat participants belonging to the thread identified by threadId.
     * @param request - Thread participants' details to add in the thread roster
     * @param options - Operation options.
     */
    addParticipants(request, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-AddParticipants", options);
            try {
                const _a = yield this.client.chatThread.addChatParticipants(this.threadId, mapToAddChatParticipantsRequestRestModel(request), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions)), { _response } = _a, result = tslib.__rest(_a, ["_response"]);
                return result;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listParticipantsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listParticipantsPage_1() {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatParticipants(this.threadId, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatParticipantsNext(this.threadId, continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToChatParticipantSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listParticipantsAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listParticipantsAll_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listParticipantsPage({}, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    /**
     * Gets the participants of the thread identified by threadId.
     * Returns the lists of the participants.
     * @param options - Operation options.
     */
    listParticipants(options = {}) {
        const { span, updatedOptions } = createSpan("ChatThreadClient-ListParticipants", options);
        try {
            const iter = this.listParticipantsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listParticipantsPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Removes participant from the thread identified by threadId.
     * @param participant - Thread participant to remove from the thread roster
     * @param options - Operation options.
     */
    removeParticipant(participant, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-RemoveParticipant", options);
            try {
                yield this.client.chatThread.removeChatParticipant(this.threadId, communicationCommon.serializeCommunicationIdentifier(participant), coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Sends a typing notification to the thread.
     * Doesn't attempt to send if the time since last notification is smaller than the minimum typing interval
     * @param options - - Operation options
     * @returns True if the typing message notification could be sent, otherwise false.
     */
    sendTypingNotification(options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-SendTypingNotification", options);
            try {
                const dateNow = new Date();
                if (this.canPostTypingNotification(dateNow)) {
                    yield this.client.chatThread.sendTypingNotification(this.threadId, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
                    this.timeOfLastTypingRequest = dateNow;
                    return true;
                }
                logger.info(`Typing Notification NOT Send. [thread_id=${this.threadId}]`);
                return false;
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Sends a read receipt to the thread identified by threadId.
     * @param messageId - The message id of the message that user latest read.
     * @param request - Request for sending a read receipt
     * @param options - Operation options.
     */
    sendReadReceipt(request, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatThreadClient-SendReadReceipt", options);
            try {
                yield this.client.chatThread.sendChatReadReceipt(this.threadId, request, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listReadReceiptsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listReadReceiptsPage_1() {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatReadReceipts(this.threadId, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chatThread.listChatReadReceiptsNext(this.threadId, continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value.map(mapToReadReceiptSdkModel, this));
                }
                else {
                    break;
                }
            }
        });
    }
    listReadReceiptsAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listReadReceiptsAll_1() {
            var e_3, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listReadReceiptsPage({}, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_3) throw e_3.error; }
            }
        });
    }
    /**
     * Gets a list of read receipt from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */
    listReadReceipts(options = {}) {
        const { span, updatedOptions } = createSpan("ChatThreadClient-ListChatReadReceipts", options);
        try {
            const iter = this.listReadReceiptsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listReadReceiptsPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    canPostTypingNotification(dateNow) {
        if (this.timeOfLastTypingRequest) {
            const timeSinceLastRequestInMilliSeconds = dateNow.getTime() - this.timeOfLastTypingRequest.getTime();
            if (timeSinceLastRequestInMilliSeconds < minimumTypingIntervalInMilliSeconds) {
                logger.info(`Typing interval check failed. [last_request=${this.timeOfLastTypingRequest}]`);
                return false;
            }
        }
        return true;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The client to do chat operations
 */
class ChatClient {
    /**
     * Creates an instance of the ChatClient for a given resource and user.
     *
     * @param endpoint - The url of the Communication Services resouce.
     * @param credential - The token credential. Use AzureCommunicationTokenCredential from \@azure/communication-common to create a credential.
     * @param options - Additional client options.
     */
    constructor(endpoint, credential, options = {}) {
        this.endpoint = endpoint;
        this.signalingClient = undefined;
        this.emitter = new events.EventEmitter();
        this.isRealtimeNotificationsStarted = false;
        this.tokenCredential = credential;
        this.clientOptions = Object.assign({}, options);
        const libInfo = `azsdk-js-communication-chat/${SDK_VERSION}`;
        if (!options.userAgentOptions) {
            options.userAgentOptions = {};
        }
        const userAgentOptions = Object.assign({}, options.userAgentOptions);
        if (options.userAgentOptions.userAgentPrefix) {
            userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            userAgentOptions.userAgentPrefix = libInfo;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, Object.assign(Object.assign({}, options), { userAgentOptions })), {
            loggingOptions: {
                logger: logger.info
            }
        });
        const authPolicy = createCommunicationTokenCredentialPolicy(this.tokenCredential);
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        this.client = new ChatApiClient(this.endpoint, pipeline);
        this.signalingClient = getSignalingClient();
    }
    /**
     * Returns ChatThreadClient with the specific thread id.
     * @param threadId - Thread ID for the ChatThreadClient
     */
    getChatThreadClient(threadId) {
        return new ChatThreadClient(this.endpoint, threadId, this.tokenCredential, this.clientOptions);
    }
    /**
     * Creates a chat thread.
     * Returns thread client with the id of the created thread.
     * @param request - Request for creating a chat thread.
     * @param options - Operation options.
     */
    createChatThread(request, options = {}) {
        var _a, _b;
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatClient-CreateChatThread", options);
            try {
                // We generate an UUID if the user does not provide an idempotencyToken value
                updatedOptions.idempotencyToken = (_a = updatedOptions.idempotencyToken) !== null && _a !== void 0 ? _a : coreHttp.generateUuid();
                const updatedRestModelOptions = mapToCreateChatThreadOptionsRestModel(updatedOptions);
                const _c = yield this.client.chat.createChatThread({
                    topic: request.topic,
                    participants: (_b = options.participants) === null || _b === void 0 ? void 0 : _b.map((participant) => mapToChatParticipantRestModel(participant))
                }, coreHttp.operationOptionsToRequestOptionsBase(updatedRestModelOptions)), { _response } = _c, result = tslib.__rest(_c, ["_response"]);
                return mapToCreateChatThreadResultSdkModel(result);
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    listChatThreadsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listChatThreadsPage_1() {
            const requestOptions = coreHttp.operationOptionsToRequestOptionsBase(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chat.listChatThreads(requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value);
                }
            }
            while (continuationState.continuationToken) {
                const currentSetResponse = yield tslib.__await(this.client.chat.listChatThreadsNext(continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) {
                    yield yield tslib.__await(currentSetResponse.value);
                }
                else {
                    break;
                }
            }
        });
    }
    listChatThreadsAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listChatThreadsAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listChatThreadsPage({}, options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Gets the list of chat threads of a user.
     * @param options - List chat threads options.
     */
    listChatThreads(options = {}) {
        const { span, updatedOptions } = createSpan("ChatClient-ListChatThreads", options);
        try {
            const iter = this.listChatThreadsAll(updatedOptions);
            return {
                next() {
                    return iter.next();
                },
                [Symbol.asyncIterator]() {
                    return this;
                },
                byPage: (settings = {}) => {
                    return this.listChatThreadsPage(settings, updatedOptions);
                }
            };
        }
        catch (e) {
            span.setStatus({
                code: api.CanonicalCode.UNKNOWN,
                message: e.message
            });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Deletes a chat thread.
     * @param threadId - The ID of the thread to delete.
     * @param options -  Operation options.
     */
    deleteChatThread(threadId, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, updatedOptions } = createSpan("ChatClient-DeleteChatThread", options);
            try {
                yield this.client.chat.deleteChatThread(threadId, coreHttp.operationOptionsToRequestOptionsBase(updatedOptions));
            }
            catch (e) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: e.message
                });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Start receiving realtime notifications.
     * Call this function before subscribing to any event.
     */
    startRealtimeNotifications() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.signalingClient === undefined) {
                throw new Error("Realtime notifications are only supported in the browser.");
            }
            if (this.isRealtimeNotificationsStarted) {
                return;
            }
            this.isRealtimeNotificationsStarted = true;
            this.signalingClient.start();
            this.subscribeToSignalingEvents();
        });
    }
    /**
     * Stop receiving realtime notifications.
     * This function would unsubscribe to all events.
     */
    stopRealtimeNotifications() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (this.signalingClient === undefined) {
                throw new Error("Realtime notifications are only supported in the browser.");
            }
            this.isRealtimeNotificationsStarted = false;
            this.signalingClient.stop();
            this.emitter.removeAllListeners();
        });
    }
    on(event, listener) {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        if (!this.isRealtimeNotificationsStarted) {
            throw new Error("You must call startRealtimeNotifications before you can subscribe to events.");
        }
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.emitter.removeListener(event, listener);
    }
    subscribeToSignalingEvents() {
        if (this.signalingClient === undefined) {
            throw new Error("Realtime notifications are only supported in the browser.");
        }
        this.signalingClient.on("chatMessageReceived", (payload) => {
            this.emitter.emit("chatMessageReceived", payload);
        });
        this.signalingClient.on("chatMessageEdited", (payload) => {
            this.emitter.emit("chatMessageEdited", payload);
        });
        this.signalingClient.on("chatMessageDeleted", (payload) => {
            this.emitter.emit("chatMessageDeleted", payload);
        });
        this.signalingClient.on("typingIndicatorReceived", (payload) => {
            this.emitter.emit("typingIndicatorReceived", payload);
        });
        this.signalingClient.on("readReceiptReceived", (payload) => {
            this.emitter.emit("readReceiptReceived", payload);
        });
        this.signalingClient.on("chatThreadCreated", (payload) => {
            this.emitter.emit("chatThreadCreated", payload);
        });
        this.signalingClient.on("chatThreadDeleted", (payload) => {
            this.emitter.emit("chatThreadDeleted", payload);
        });
        this.signalingClient.on("chatThreadPropertiesUpdated", (payload) => {
            this.emitter.emit("chatThreadPropertiesUpdated", payload);
        });
        this.signalingClient.on("participantsAdded", (payload) => {
            this.emitter.emit("participantsAdded", payload);
        });
        this.signalingClient.on("participantsRemoved", (payload) => {
            this.emitter.emit("participantsRemoved", payload);
        });
    }
}

exports.ChatClient = ChatClient;
exports.ChatThreadClient = ChatThreadClient;
//# sourceMappingURL=index.js.map
