// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"ot36a":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 51163;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "7def046eb5a3cd24";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            if (err.message) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"lsDBr":[function(require,module,exports,__globalThis) {
// <Create a chat client>
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _communicationChat = require("@azure/communication-chat");
var _communicationCommon = require("@azure/communication-common");
var _botServiceJs = require("./bot-service.js");
var _botServiceJsDefault = parcelHelpers.interopDefault(_botServiceJs);
let endpointUrl = 'https://alexper-test1.unitedstates.communication.azure.com/';
let userAccessToken = 'eyJhbGciOiJSUzI1NiIsImtpZCI6IkY1M0ZEODA0RThBNDhBQzg4Qjg3NTA3M0M4MzRCRDdGNzBCMzBENDUiLCJ4NXQiOiI5VF9ZQk9pa2lzaUxoMUJ6eURTOWYzQ3pEVVUiLCJ0eXAiOiJKV1QifQ.eyJza3lwZWlkIjoiYWNzOmMyZjJiZjU0LTFiMzctNDY3Zi1hZGUzLTE1YzY0MjhkMDMxMF8wMDAwMDAyNi03MzJjLWE2NjktOWMzMi04ZTNhMGQwMDgwMDAiLCJzY3AiOjE3OTIsImNzaSI6IjE3NDMwMDY2NjMiLCJleHAiOjE3NDMwOTMwNjMsInJnbiI6ImFtZXIiLCJhY3NTY29wZSI6ImNoYXQiLCJyZXNvdXJjZUlkIjoiYzJmMmJmNTQtMWIzNy00NjdmLWFkZTMtMTVjNjQyOGQwMzEwIiwicmVzb3VyY2VMb2NhdGlvbiI6InVuaXRlZHN0YXRlcyIsImlhdCI6MTc0MzAwNjY2M30.BBApY3ipN0JqtYnzlnnxufiTP12RoHTdXDK7_4Hi63bWGqdct1ePIP0DexMZ6v_sfTHYxls1TMjuXO4zkRO2k8uAqMVhffbrUlFUIKq5o18X0glvlC7cf26qbKTq36y3pTHUPPce7_dMp6nOvzbhZTdwS6oDyhxXNgyfXFAer3NQrOXmg98PF824okMpEHkZTgtKbokeMasWBXgEx_li8vEskMgi1O9LGiFc9LCS3esXcOlj-yjcN3M874xJPE647FV-OOFN8c_LPx4mCyHJJ1vOagzDwAgyMItn2DsViTzkxMYLTFyv_frY8pAU8UsWapjtRf8m-AdO8Zux3T1aNg';
// DOM Element check
console.log("\uD83D\uDD0D Checking DOM elements...");
const customerMessagesContainer = document.getElementById('customerMessages');
const customerInput = document.getElementById('customerInput');
const customerSendButton = document.getElementById('customerSendButton');
const agentMessagesContainer = document.getElementById('agentMessages');
const agentInput = document.getElementById('agentInput');
const agentSendButton = document.getElementById('agentSendButton');
// Log if any elements are missing
if (!customerMessagesContainer) console.error("\u274C customerMessagesContainer not found");
if (!customerInput) console.error("\u274C customerInput not found");
if (!customerSendButton) console.error("\u274C customerSendButton not found");
if (!agentMessagesContainer) console.error("\u274C agentMessagesContainer not found");
if (!agentInput) console.error("\u274C agentInput not found");
if (!agentSendButton) console.error("\u274C agentSendButton not found");
console.log("\uD83D\uDCE6 All DOM elements loaded:", {
    customerMessagesContainer,
    customerInput,
    customerSendButton,
    agentMessagesContainer,
    agentInput,
    agentSendButton
});
// IMPORTANT: Define chatClient in the global scope
let chatClient;
let chatThreadClient;
let chatThreadId;
let notificationsStarted = false;
// Get our user ID from the access token
const tokenPayload = JSON.parse(atob(userAccessToken.split('.')[1]));
const ourUserId = tokenPayload.skypeid.replace('acs:', '');
console.log("\uD83C\uDD94 Our user ID:", ourUserId);
// Initialize the chat client globally
try {
    console.log("\uD83D\uDE80 Initializing Azure Communication Chat client...");
    chatClient = new (0, _communicationChat.ChatClient)(endpointUrl, new (0, _communicationCommon.AzureCommunicationTokenCredential)(userAccessToken));
    console.log("\u2705 Chat client created successfully:", chatClient);
} catch (error) {
    console.error("\u274C Error creating chat client:", error);
}
// Track message IDs we've already displayed to prevent duplicates
const displayedMessageIds = new Set();
console.log("\uD83D\uDD04 Message tracking initialized");
// Initialize bot service
const botService = new (0, _botServiceJsDefault.default)();
let isAgentActive = false;
// Initialize summary service
const summaryService = new (0, _botServiceJs.SummaryService)();
let lastMessageTime = null;
// Add takeover button handler
const takeoverButton = document.getElementById('takeoverButton');
takeoverButton.addEventListener('click', async ()=>{
    if (!isAgentActive) {
        isAgentActive = true;
        takeoverButton.disabled = true;
        // Deactivate bot and send handoff message
        const handoffMessage = await botService.deactivate();
        // Send system message about agent joining
        const agentJoinMessage = "A customer service agent has joined the conversation.";
        // Send both messages through ACS
        await sendSystemMessage(handoffMessage);
        await sendSystemMessage(agentJoinMessage);
    }
});
// Function to show error message in UI
function showErrorInUI(message) {
    console.error("\uD83D\uDEA8 Showing error in UI:", message);
    try {
        // Show in customer UI
        if (customerMessagesContainer) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'message error';
            errorDiv.style.backgroundColor = '#ffdddd';
            errorDiv.style.color = '#cc0000';
            errorDiv.style.padding = '10px 15px';
            errorDiv.style.margin = '10px 0';
            errorDiv.style.borderRadius = '8px';
            errorDiv.style.alignSelf = 'center';
            errorDiv.textContent = `Error: ${message}`;
            customerMessagesContainer.appendChild(errorDiv);
            customerMessagesContainer.scrollTop = customerMessagesContainer.scrollHeight;
        }
        // Show in agent UI
        if (agentMessagesContainer) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'agent-message error';
            errorDiv.style.backgroundColor = '#ffdddd';
            errorDiv.style.color = '#cc0000';
            errorDiv.style.padding = '10px 15px';
            errorDiv.style.margin = '10px 0';
            errorDiv.style.borderRadius = '8px';
            errorDiv.style.alignSelf = 'center';
            errorDiv.textContent = `Error: ${message}`;
            agentMessagesContainer.appendChild(errorDiv);
            agentMessagesContainer.scrollTop = agentMessagesContainer.scrollHeight;
        }
    } catch (error) {
        console.error('Failed to show error in UI:', error);
    }
}
// Create a chat thread with participants
async function createChatThread() {
    console.log("\uD83D\uDCDD Creating new chat thread...");
    if (!chatClient) throw new Error('Chat client is not initialized');
    try {
        const createChatThreadRequest = {
            topic: "Flight Information"
        };
        console.log("\uD83D\uDC65 Setting up participants...");
        const createChatThreadOptions = {
            participants: [
                {
                    id: {
                        communicationUserId: '8:acs:c2f2bf54-1b37-467f-ade3-15c6428d0310_00000026-6de7-5368-e138-8e3a0d00c891'
                    },
                    displayName: 'Sarah Jones'
                },
                {
                    id: {
                        communicationUserId: '8:acs:c2f2bf54-1b37-467f-ade3-15c6428d0310_00000026-6de8-ad3e-7137-8e3a0d00d703'
                    },
                    displayName: 'Support Agent'
                }
            ]
        };
        console.log("\u23F3 Awaiting thread creation with options:", createChatThreadOptions);
        const createChatThreadResult = await chatClient.createChatThread(createChatThreadRequest, createChatThreadOptions);
        chatThreadId = createChatThreadResult.chatThread.id;
        console.log(`\u{2728} Chat thread created with ID: ${chatThreadId}`);
        console.log("\uD83D\uDCCA Thread details:", createChatThreadResult.chatThread);
        console.log("\uD83D\uDC65 Initial participants added:", createChatThreadOptions.participants.map((p)=>p.displayName).join(', '));
        return chatThreadId;
    } catch (error) {
        console.error("\u274C Error creating chat thread:", error);
        throw error;
    }
}
// Modify addMessageToAgentUI function to handle bot messages
function addMessageToAgentUI(message, isAgent = false, sender = null, messageId = null) {
    console.log(`\u{1F5A5}\u{FE0F} Adding message to agent UI - Message: "${message}", isAgent: ${isAgent}, sender: ${sender}, messageId: ${messageId}`);
    // If this message ID has already been displayed, don't show it again
    if (messageId && displayedMessageIds.has(`agent-${messageId}`)) {
        console.log(`\u{1F4CB} Skipping duplicate agent message with ID: ${messageId}`);
        return;
    }
    // Mark this message as displayed
    if (messageId) {
        displayedMessageIds.add(`agent-${messageId}`);
        console.log(`\u{2705} Marked message ${messageId} as displayed in agent UI`);
    }
    try {
        // Check if this is a system message
        const isSystem = sender === 'System';
        if (isSystem) {
            // Create a simpler wrapper for system messages
            const messageWrapper = document.createElement('div');
            messageWrapper.className = 'message-wrapper system';
            // Create message div for system message
            const messageDiv = document.createElement('div');
            messageDiv.className = 'agent-message system';
            messageDiv.textContent = message;
            // Add to wrapper and then to container
            messageWrapper.appendChild(messageDiv);
            agentMessagesContainer.appendChild(messageWrapper);
        } else {
            // Create a wrapper for the message and avatar
            const messageWrapper = document.createElement('div');
            messageWrapper.style.display = 'flex';
            messageWrapper.style.alignItems = 'flex-start';
            messageWrapper.style.gap = '10px';
            messageWrapper.style.marginBottom = '15px';
            // Add 'bot' class if the sender is AI Assistant
            const isBot = sender === 'AI Assistant';
            // Create avatar element
            const avatarDiv = document.createElement('div');
            avatarDiv.className = isBot ? 'message-avatar bot' : isAgent ? 'message-avatar agent' : 'message-avatar customer';
            // Set avatar content based on sender
            if (isBot) avatarDiv.innerHTML = "\uD83E\uDD16";
            else if (isAgent) avatarDiv.textContent = 'SA';
            else // Customer
            avatarDiv.textContent = 'SJ';
            // Create message div
            const messageDiv = document.createElement('div');
            messageDiv.className = `agent-message ${isBot ? 'bot' : isAgent ? 'agent' : 'customer'}`;
            messageDiv.style.margin = '0';
            // Add sender if provided
            if (sender) {
                const senderDiv = document.createElement('div');
                senderDiv.className = 'sender';
                senderDiv.textContent = sender;
                messageDiv.appendChild(senderDiv);
            }
            // Add message content
            const contentDiv = document.createElement('div');
            contentDiv.textContent = message;
            messageDiv.appendChild(contentDiv);
            // Append avatar and message to wrapper
            if (isBot || isAgent) {
                // For bot and agent messages, avatar goes on the right
                messageWrapper.style.flexDirection = 'row-reverse';
                messageWrapper.appendChild(avatarDiv);
                messageWrapper.appendChild(messageDiv);
            } else {
                // For customer messages, avatar goes on the left
                messageWrapper.appendChild(avatarDiv);
                messageWrapper.appendChild(messageDiv);
            }
            // Add to agent messages container
            agentMessagesContainer.appendChild(messageWrapper);
        }
        // Scroll to bottom
        agentMessagesContainer.scrollTop = agentMessagesContainer.scrollHeight;
        console.log("\u2705 Message added to agent UI successfully");
    } catch (error) {
        console.error("\u274C Error adding message to agent UI:", error);
    }
}
// Modify addMessageToCustomerUI to handle bot messages like received messages
function addMessageToCustomerUI(message, isCustomer = false, messageId = null, isBot = false) {
    console.log(`\u{1F5A5}\u{FE0F} Adding message to customer UI - Message: "${message}", isCustomer: ${isCustomer}, messageId: ${messageId}`);
    // If this message ID has already been displayed, don't show it again
    if (messageId && displayedMessageIds.has(`customer-${messageId}`)) {
        console.log(`\u{1F4CB} Skipping duplicate customer message with ID: ${messageId}`);
        return;
    }
    // Mark this message as displayed
    if (messageId) {
        displayedMessageIds.add(`customer-${messageId}`);
        console.log(`\u{2705} Marked message ${messageId} as displayed in customer UI`);
    }
    try {
        // Check if this is a system message (passed via senderDisplayName in sendSystemMessage)
        const isSystem = messageId && messageId.includes('system');
        if (isSystem) {
            // Create a simple styled system message
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';
            messageDiv.style.alignSelf = 'center';
            messageDiv.style.background = 'transparent';
            messageDiv.style.color = '#6c757d';
            messageDiv.style.fontSize = '13px';
            messageDiv.style.padding = '5px 15px';
            messageDiv.style.textAlign = 'center';
            messageDiv.style.maxWidth = '100%';
            messageDiv.style.border = 'none';
            messageDiv.textContent = message;
            customerMessagesContainer.appendChild(messageDiv);
        } else {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isCustomer ? 'sent' : 'received'}`;
            messageDiv.textContent = message;
            // Add timestamp
            const timestamp = document.createElement('div');
            timestamp.className = 'timestamp';
            timestamp.textContent = new Date().toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit'
            });
            messageDiv.appendChild(timestamp);
            customerMessagesContainer.appendChild(messageDiv);
        }
        // Scroll to bottom
        customerMessagesContainer.scrollTop = customerMessagesContainer.scrollHeight;
        console.log("\u2705 Message added to customer UI successfully");
    } catch (error) {
        console.error("\u274C Error adding message to customer UI:", error);
    }
}
// Add function to create and display summary card
function addSummaryToAgentUI(summary) {
    const summaryDiv = document.createElement('div');
    summaryDiv.className = 'agent-message summary-card';
    summaryDiv.style.width = '80%';
    summaryDiv.style.maxWidth = '600px';
    summaryDiv.style.alignSelf = 'center';
    summaryDiv.style.background = 'white';
    summaryDiv.style.border = '1px solid #ccd';
    summaryDiv.style.borderRadius = '8px';
    summaryDiv.style.padding = '15px';
    summaryDiv.style.margin = '10px 0';
    summaryDiv.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
    // Create header
    const headerDiv = document.createElement('div');
    headerDiv.style.display = 'flex';
    headerDiv.style.alignItems = 'center';
    headerDiv.style.marginBottom = '10px';
    headerDiv.style.paddingBottom = '10px';
    headerDiv.style.borderBottom = '1px solid #e1e1e1';
    const iconSpan = document.createElement('span');
    iconSpan.textContent = "\uD83D\uDCCB";
    iconSpan.style.marginRight = '8px';
    iconSpan.style.fontSize = '16px';
    const headerText = document.createElement('span');
    headerText.textContent = 'Conversation Summary';
    headerText.style.fontWeight = '600';
    headerText.style.color = '#333';
    headerText.style.fontSize = '16px';
    const timestamp = document.createElement('span');
    timestamp.textContent = new Date().toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit'
    });
    timestamp.style.marginLeft = 'auto';
    timestamp.style.color = '#888';
    timestamp.style.fontSize = '12px';
    headerDiv.appendChild(iconSpan);
    headerDiv.appendChild(headerText);
    headerDiv.appendChild(timestamp);
    // Create content with formatted paragraphs
    const contentDiv = document.createElement('div');
    // Format summary with paragraphs
    const paragraphs = summary.split('\n').filter((p)=>p.trim() !== '');
    paragraphs.forEach((paragraph)=>{
        const p = document.createElement('p');
        p.textContent = paragraph;
        p.style.margin = '0 0 10px 0';
        p.style.lineHeight = '1.5';
        contentDiv.appendChild(p);
    });
    contentDiv.style.color = '#444';
    contentDiv.style.fontSize = '14px';
    contentDiv.style.lineHeight = '1.5';
    summaryDiv.appendChild(headerDiv);
    summaryDiv.appendChild(contentDiv);
    // Add to agent messages container
    agentMessagesContainer.appendChild(summaryDiv);
    agentMessagesContainer.scrollTop = agentMessagesContainer.scrollHeight;
}
// Add function to handle summarize button click
const handleSummarizeClick = async ()=>{
    const summarizeButton = document.getElementById('summarizeButton');
    if (!summarizeButton || !chatThreadClient) {
        console.error('Required elements not initialized');
        return;
    }
    summarizeButton.disabled = true;
    try {
        // Get all messages from the thread
        const messages = [];
        const iterator = chatThreadClient.listMessages();
        for await (const message of iterator)messages.push(message);
        const summary = await summaryService.generateSummary(messages);
        addSummaryToAgentUI(summary);
        lastMessageTime = new Date();
    } catch (error) {
        console.error('Error generating summary:', error);
        showErrorInUI('Failed to generate conversation summary');
    } finally{
        summarizeButton.disabled = false;
    }
};
// Update the bot message handling in sendCustomerMessage
async function sendCustomerMessage(content) {
    if (!content.trim()) {
        console.log("\u26A0\uFE0F Empty message - not sending");
        return;
    }
    console.log(`\u{1F4E4} Sending customer message: "${content}"`);
    try {
        // Send customer message through ACS
        const sendMessageRequest = {
            content: content
        };
        const sendMessageOptions = {
            senderDisplayName: 'Sarah Jones',
            type: 'text'
        };
        const sendChatMessageResult = await chatThreadClient.sendMessage(sendMessageRequest, sendMessageOptions);
        // Add message to customer UI immediately
        addMessageToCustomerUI(content, true, sendChatMessageResult.id, false);
        addMessageToAgentUI(content, false, 'Sarah Jones', sendChatMessageResult.id);
        // Clear input
        customerInput.value = '';
        // If bot is active, get bot response
        if (botService.isEnabled()) {
            const botResponse = await botService.processMessage(content);
            if (botResponse) {
                // Send bot response through ACS
                const botMessageRequest = {
                    content: botResponse
                };
                const botMessageOptions = {
                    senderDisplayName: 'AI Assistant',
                    type: 'text'
                };
                const botMessageResult = await chatThreadClient.sendMessage(botMessageRequest, botMessageOptions);
                // Add bot response to both UIs with bot styling
                addMessageToCustomerUI(botResponse, false, botMessageResult.id, true);
                addMessageToAgentUI(botResponse, false, 'AI Assistant', botMessageResult.id);
            }
        }
        lastMessageTime = new Date();
        const summarizeButton = document.getElementById('summarizeButton');
        if (summarizeButton) summarizeButton.disabled = false;
    } catch (error) {
        console.error("\u274C Error in message flow:", error);
        showErrorInUI('Failed to process message: ' + error.message);
    }
}
// Send a message from agent
async function sendAgentMessage(content) {
    if (!content.trim()) {
        console.log("\u26A0\uFE0F Empty message - not sending");
        return;
    }
    console.log(`\u{1F4E4} Sending agent message: "${content}"`);
    console.log("\uD83E\uDDEA Current chatThreadClient:", chatThreadClient);
    const sendMessageRequest = {
        content: content
    };
    const sendMessageOptions = {
        senderDisplayName: 'Support Agent',
        type: 'text'
    };
    console.log("\uD83D\uDCE6 Message request:", sendMessageRequest);
    console.log("\u2699\uFE0F Message options:", sendMessageOptions);
    try {
        if (!chatThreadClient) throw new Error('Chat thread client is not initialized');
        console.log("\u23F3 Awaiting sendMessage response...");
        const sendChatMessageResult = await chatThreadClient.sendMessage(sendMessageRequest, sendMessageOptions);
        console.log(`\u{2705} Agent message sent successfully! Message ID: ${sendChatMessageResult.id}`);
        console.log("\uD83D\uDCCA Send result details:", sendChatMessageResult);
        // Add message to agent UI immediately
        addMessageToAgentUI(content, true, 'Support Agent', sendChatMessageResult.id);
        agentInput.value = '';
        lastMessageTime = new Date();
        const summarizeButton = document.getElementById('summarizeButton');
        if (summarizeButton) summarizeButton.disabled = false;
    } catch (error) {
        console.error("\u274C Error sending agent message:", error);
        console.error("\uD83E\uDDEA Error details:", {
            error,
            chatThreadClient,
            threadId: chatThreadId
        });
        showErrorInUI('Failed to send agent message: ' + error.message);
    }
}
// Add function to send system messages
async function sendSystemMessage(content) {
    try {
        const messageRequest = {
            content: content
        };
        const messageOptions = {
            senderDisplayName: 'System',
            type: 'text'
        };
        const messageResult = await chatThreadClient.sendMessage(messageRequest, messageOptions);
        // Add system message to both UIs - passing the "System" sender
        // Mark the message ID to identify it as a system message
        const systemMessageId = `system-${messageResult.id}`;
        addMessageToCustomerUI(content, false, systemMessageId, false);
        addMessageToAgentUI(content, false, 'System', messageResult.id);
    } catch (error) {
        console.error("\u274C Error sending system message:", error);
    }
}
// Set up event handlers for real-time notifications
async function setupEventHandlers() {
    if (!chatClient) {
        console.error("\u274C Cannot set up event handlers - Chat client is not initialized");
        return false;
    }
    try {
        // Message received handler
        chatClient.on("chatMessageReceived", (e)=>{
            console.log("\uD83C\uDFAF chatMessageReceived event triggered");
            console.log("\uD83D\uDCE9 Message received - FULL EVENT:", JSON.stringify(e));
            // Extract the sender display name and message content
            const senderDisplayName = e.senderDisplayName || 'Unknown';
            const messageContent = e.content || e.message || 'No content';
            const messageId = e.id || '';
            console.log(`\u{1F4E9} Message received - From: ${senderDisplayName}, Content: ${messageContent}, ID: ${messageId}`);
            const isAgent = senderDisplayName === 'Support Agent';
            const isCustomer = senderDisplayName === 'Sarah Jones';
            console.log(`\u{1F9EA} Sender analysis - isAgent: ${isAgent}, isCustomer: ${isCustomer}`);
            // If the message is from the agent, show in customer view as a received message
            if (isAgent) {
                console.log("\uD83D\uDD0D Agent message detected - adding to customer UI");
                addMessageToCustomerUI(messageContent, false, messageId, false);
            }
            // If the message is from the customer, show in agent view
            if (isCustomer) {
                console.log("\uD83D\uDD0D Customer message detected - adding to agent UI");
                addMessageToAgentUI(messageContent, false, 'Sarah Jones', messageId);
            }
        });
        chatClient.on("participantsAdded", (e)=>{
            console.log("\uD83C\uDFAF participantsAdded event triggered");
            console.log("\uD83D\uDC4B New participants added:", e.participantsAdded.map((p)=>p.displayName).join(', '));
        });
        chatClient.on("participantsRemoved", (e)=>{
            console.log("\uD83C\uDFAF participantsRemoved event triggered");
            console.log("\uD83D\uDC4B Participants removed:", e.participantsRemoved.map((p)=>p.displayName).join(', '));
        });
        chatClient.on("typingIndicatorReceived", (e)=>{
            console.log("\uD83C\uDFAF typingIndicatorReceived event triggered");
            console.log(`\u{270D}\u{FE0F} ${e.sender.displayName || 'Someone'} is typing...`);
        });
        console.log("\u2705 Event handlers set up successfully");
        return true;
    } catch (error) {
        console.error("\u274C Error setting up event handlers:", error);
        return false;
    }
}
// Modify initializeChat to start bot conversation
async function initializeChat() {
    console.log("\uD83D\uDE80 Starting chat initialization...");
    try {
        // Make sure the chat client is available
        if (!chatClient) throw new Error('Chat client is not initialized. Cannot proceed with initialization.');
        // Start real-time notifications FIRST - before creating chat thread
        console.log("\uD83D\uDD04 Setting up real-time notifications...");
        try {
            await chatClient.startRealtimeNotifications();
            notificationsStarted = true;
            console.log("\u2705 Real-time notifications started");
            // Set up event handlers immediately after starting notifications
            await setupEventHandlers();
        } catch (notifError) {
            console.error("\u274C Failed to start real-time notifications:", notifError);
            showErrorInUI('Failed to start real-time notifications. Chat will not update in real-time.');
        }
        // Create thread and get thread ID
        console.log("\uD83E\uDDF5 Creating chat thread...");
        const threadId = await createChatThread();
        chatThreadId = threadId;
        // Initialize chat thread client
        console.log(`\u{1F517} Creating chat thread client for thread ID: ${threadId}`);
        chatThreadClient = chatClient.getChatThreadClient(threadId);
        if (!chatThreadClient) throw new Error('Failed to create chat thread client');
        console.log("\u2705 Chat thread client created:", chatThreadClient);
        // Start bot conversation with greeting
        const greeting = await botService.startConversation();
        // Send bot greeting through ACS
        const botMessageRequest = {
            content: greeting
        };
        const botMessageOptions = {
            senderDisplayName: 'AI Assistant',
            type: 'text'
        };
        const botMessageResult = await chatThreadClient.sendMessage(botMessageRequest, botMessageOptions);
        // Add bot greeting to both UIs with bot styling
        addMessageToCustomerUI(greeting, false, botMessageResult.id, true);
        addMessageToAgentUI(greeting, false, 'AI Assistant', botMessageResult.id);
        // Set up UI event listeners
        console.log("\uD83D\uDDB1\uFE0F Setting up UI event listeners...");
        const summarizeButton = document.getElementById('summarizeButton');
        if (summarizeButton) summarizeButton.addEventListener('click', handleSummarizeClick);
        customerSendButton.addEventListener('click', ()=>{
            console.log("\uD83D\uDDB1\uFE0F Customer send button clicked");
            sendCustomerMessage(customerInput.value);
        });
        customerInput.addEventListener('keypress', (e)=>{
            if (e.key === 'Enter') {
                console.log("\u2328\uFE0F Customer pressed Enter key");
                sendCustomerMessage(customerInput.value);
            }
        });
        agentSendButton.addEventListener('click', ()=>{
            console.log("\uD83D\uDDB1\uFE0F Agent send button clicked");
            sendAgentMessage(agentInput.value);
        });
        agentInput.addEventListener('keypress', (e)=>{
            if (e.key === 'Enter') {
                console.log("\u2328\uFE0F Agent pressed Enter key");
                sendAgentMessage(agentInput.value);
            }
        });
        console.log("\u2705 Chat initialization complete!");
    } catch (error) {
        console.error("\u274C Error initializing chat:", error);
        console.error("\uD83E\uDDEA Detailed error information:", {
            error,
            stack: error.stack,
            message: error.message
        });
        // Show error in UI
        showErrorInUI('Chat initialization failed: ' + error.message);
    }
}
// Check browser capabilities
console.log("\uD83C\uDF10 Checking browser capabilities...");
if (!window.WebSocket) {
    console.error("\u274C WebSockets not supported - real-time notifications may not work");
    showErrorInUI('Your browser does not support WebSockets. Real-time chat updates will not work.');
}
// Start the customer service chat application
console.log("\uD83D\uDE80 Starting application...");
initializeChat();
console.log("\u2705 Application startup complete - awaiting initialization to finish");

},{"@azure/communication-chat":"9DIoN","@azure/communication-common":"cyhBF","./bot-service.js":"gGuDA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9DIoN":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _options = require("./models/options");
parcelHelpers.exportAll(_options, exports);
var _requests = require("./models/requests");
parcelHelpers.exportAll(_requests, exports);
var _models = require("./models/models");
parcelHelpers.exportAll(_models, exports);
var _chatClient = require("./chatClient");
parcelHelpers.exportAll(_chatClient, exports);
var _chatThreadClient = require("./chatThreadClient");
parcelHelpers.exportAll(_chatThreadClient, exports);

},{"./models/options":false,"./models/requests":false,"./models/models":false,"./chatClient":"iifwa","./chatThreadClient":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iifwa":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/// <reference lib="esnext.asynciterable" />
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The client to do chat operations
 */ parcelHelpers.export(exports, "ChatClient", ()=>ChatClient);
var _tslib = require("tslib");
var _logger = require("./models/logger");
var _events = require("events");
var _constants = require("./constants");
var _signalingClient = require("./signaling/signalingClient");
var _coreHttp = require("@azure/core-http");
var _corePaging = require("@azure/core-paging");
var _api = require("@opentelemetry/api");
var _tracing = require("./tracing");
var _chatThreadClient = require("./chatThreadClient");
var _mappers = require("./models/mappers");
var _communicationTokenCredentialPolicy = require("./credential/communicationTokenCredentialPolicy");
var _src = require("./generated/src");
class ChatClient {
    /**
     * Returns ChatThreadClient with the specific thread id.
     * @param threadId - Thread ID for the ChatThreadClient
     */ getChatThreadClient(threadId) {
        return new (0, _chatThreadClient.ChatThreadClient)(this.endpoint, threadId, this.tokenCredential, this.clientOptions);
    }
    /**
     * Creates a chat thread.
     * Returns thread client with the id of the created thread.
     * @param request - Request for creating a chat thread.
     * @param options - Operation options.
     */ createChatThread(request, options = {}) {
        var _a, _b;
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatClient-CreateChatThread", options);
            try {
                // We generate an UUID if the user does not provide an idempotencyToken value
                updatedOptions.idempotencyToken = (_a = updatedOptions.idempotencyToken) !== null && _a !== void 0 ? _a : (0, _coreHttp.generateUuid)();
                const updatedRestModelOptions = (0, _mappers.mapToCreateChatThreadOptionsRestModel)(updatedOptions);
                const _c = yield this.client.chat.createChatThread({
                    topic: request.topic,
                    participants: (_b = options.participants) === null || _b === void 0 ? void 0 : _b.map((participant)=>(0, _mappers.mapToChatParticipantRestModel)(participant))
                }, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedRestModelOptions)), { _response } = _c, result = (0, _tslib.__rest)(_c, [
                    "_response"
                ]);
                return (0, _mappers.mapToCreateChatThreadResultSdkModel)(result);
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    listChatThreadsPage(continuationState, options = {}) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listChatThreadsPage_1() {
            const requestOptions = (0, _coreHttp.operationOptionsToRequestOptionsBase)(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chat.listChatThreads(requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value);
            }
            while(continuationState.continuationToken){
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chat.listChatThreadsNext(continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value);
                else break;
            }
        });
    }
    listChatThreadsAll(options) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listChatThreadsAll_1() {
            var e_1, _a;
            try {
                for(var _b = (0, _tslib.__asyncValues)(this.listChatThreadsPage({}, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;){
                    const page = _c.value;
                    yield (0, _tslib.__await)((yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(page))));
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        });
    }
    /**
     * Gets the list of chat threads of a user.
     * @param options - List chat threads options.
     */ listChatThreads(options = {}) {
        const { span, updatedOptions } = (0, _tracing.createSpan)("ChatClient-ListChatThreads", options);
        try {
            const iter = this.listChatThreadsAll(updatedOptions);
            return {
                next () {
                    return iter.next();
                },
                [Symbol.asyncIterator] () {
                    return this;
                },
                byPage: (settings = {})=>{
                    return this.listChatThreadsPage(settings, updatedOptions);
                }
            };
        } catch (e) {
            span.setStatus({
                code: (0, _api.CanonicalCode).UNKNOWN,
                message: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Deletes a chat thread.
     * @param threadId - The ID of the thread to delete.
     * @param options -  Operation options.
     */ deleteChatThread(threadId, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatClient-DeleteChatThread", options);
            try {
                yield this.client.chat.deleteChatThread(threadId, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions));
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Start receiving realtime notifications.
     * Call this function before subscribing to any event.
     */ startRealtimeNotifications() {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            if (this.signalingClient === undefined) throw new Error("Realtime notifications are only supported in the browser.");
            if (this.isRealtimeNotificationsStarted) return;
            this.isRealtimeNotificationsStarted = true;
            this.signalingClient.start();
            this.subscribeToSignalingEvents();
        });
    }
    /**
     * Stop receiving realtime notifications.
     * This function would unsubscribe to all events.
     */ stopRealtimeNotifications() {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            if (this.signalingClient === undefined) throw new Error("Realtime notifications are only supported in the browser.");
            this.isRealtimeNotificationsStarted = false;
            this.signalingClient.stop();
            this.emitter.removeAllListeners();
        });
    }
    on(event, listener) {
        if (this.signalingClient === undefined) throw new Error("Realtime notifications are only supported in the browser.");
        if (!this.isRealtimeNotificationsStarted) throw new Error("You must call startRealtimeNotifications before you can subscribe to events.");
        this.emitter.on(event, listener);
    }
    off(event, listener) {
        if (this.signalingClient === undefined) throw new Error("Realtime notifications are only supported in the browser.");
        this.emitter.removeListener(event, listener);
    }
    subscribeToSignalingEvents() {
        if (this.signalingClient === undefined) throw new Error("Realtime notifications are only supported in the browser.");
        this.signalingClient.on("chatMessageReceived", (payload)=>{
            this.emitter.emit("chatMessageReceived", payload);
        });
        this.signalingClient.on("chatMessageEdited", (payload)=>{
            this.emitter.emit("chatMessageEdited", payload);
        });
        this.signalingClient.on("chatMessageDeleted", (payload)=>{
            this.emitter.emit("chatMessageDeleted", payload);
        });
        this.signalingClient.on("typingIndicatorReceived", (payload)=>{
            this.emitter.emit("typingIndicatorReceived", payload);
        });
        this.signalingClient.on("readReceiptReceived", (payload)=>{
            this.emitter.emit("readReceiptReceived", payload);
        });
        this.signalingClient.on("chatThreadCreated", (payload)=>{
            this.emitter.emit("chatThreadCreated", payload);
        });
        this.signalingClient.on("chatThreadDeleted", (payload)=>{
            this.emitter.emit("chatThreadDeleted", payload);
        });
        this.signalingClient.on("chatThreadPropertiesUpdated", (payload)=>{
            this.emitter.emit("chatThreadPropertiesUpdated", payload);
        });
        this.signalingClient.on("participantsAdded", (payload)=>{
            this.emitter.emit("participantsAdded", payload);
        });
        this.signalingClient.on("participantsRemoved", (payload)=>{
            this.emitter.emit("participantsRemoved", payload);
        });
    }
    /**
     * Creates an instance of the ChatClient for a given resource and user.
     *
     * @param endpoint - The url of the Communication Services resouce.
     * @param credential - The token credential. Use AzureCommunicationTokenCredential from \@azure/communication-common to create a credential.
     * @param options - Additional client options.
     */ constructor(endpoint, credential, options = {}){
        this.endpoint = endpoint;
        this.signalingClient = undefined;
        this.emitter = new (0, _events.EventEmitter)();
        this.isRealtimeNotificationsStarted = false;
        this.tokenCredential = credential;
        this.clientOptions = Object.assign({}, options);
        const libInfo = `azsdk-js-communication-chat/${(0, _constants.SDK_VERSION)}`;
        if (!options.userAgentOptions) options.userAgentOptions = {};
        const userAgentOptions = Object.assign({}, options.userAgentOptions);
        if (options.userAgentOptions.userAgentPrefix) userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        else userAgentOptions.userAgentPrefix = libInfo;
        const internalPipelineOptions = Object.assign(Object.assign({}, Object.assign(Object.assign({}, options), {
            userAgentOptions
        })), {
            loggingOptions: {
                logger: (0, _logger.logger).info
            }
        });
        const authPolicy = (0, _communicationTokenCredentialPolicy.createCommunicationTokenCredentialPolicy)(this.tokenCredential);
        const pipeline = (0, _coreHttp.createPipelineFromOptions)(internalPipelineOptions, authPolicy);
        this.client = new (0, _src.ChatApiClient)(this.endpoint, pipeline);
        this.signalingClient = (0, _signalingClient.getSignalingClient)(credential, (0, _logger.logger));
    }
}

},{"tslib":"iC1Dx","./models/logger":"1SM0N","events":"1Gpx3","./constants":"k8iSE","./signaling/signalingClient":"iFYeD","@azure/core-http":"1W9s4","@azure/core-paging":"3sHnq","@opentelemetry/api":"4XvbA","./tracing":"LBQN1","./chatThreadClient":"h5T6K","./models/mappers":"g0ug2","./credential/communicationTokenCredentialPolicy":"elp2u","./generated/src":"hBs8j","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iC1Dx":[function(require,module,exports,__globalThis) {
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "__extends", ()=>__extends);
parcelHelpers.export(exports, "__assign", ()=>__assign);
parcelHelpers.export(exports, "__rest", ()=>__rest);
parcelHelpers.export(exports, "__decorate", ()=>__decorate);
parcelHelpers.export(exports, "__param", ()=>__param);
parcelHelpers.export(exports, "__esDecorate", ()=>__esDecorate);
parcelHelpers.export(exports, "__runInitializers", ()=>__runInitializers);
parcelHelpers.export(exports, "__propKey", ()=>__propKey);
parcelHelpers.export(exports, "__setFunctionName", ()=>__setFunctionName);
parcelHelpers.export(exports, "__metadata", ()=>__metadata);
parcelHelpers.export(exports, "__awaiter", ()=>__awaiter);
parcelHelpers.export(exports, "__generator", ()=>__generator);
parcelHelpers.export(exports, "__createBinding", ()=>__createBinding);
parcelHelpers.export(exports, "__exportStar", ()=>__exportStar);
parcelHelpers.export(exports, "__values", ()=>__values);
parcelHelpers.export(exports, "__read", ()=>__read);
/** @deprecated */ parcelHelpers.export(exports, "__spread", ()=>__spread);
/** @deprecated */ parcelHelpers.export(exports, "__spreadArrays", ()=>__spreadArrays);
parcelHelpers.export(exports, "__spreadArray", ()=>__spreadArray);
parcelHelpers.export(exports, "__await", ()=>__await);
parcelHelpers.export(exports, "__asyncGenerator", ()=>__asyncGenerator);
parcelHelpers.export(exports, "__asyncDelegator", ()=>__asyncDelegator);
parcelHelpers.export(exports, "__asyncValues", ()=>__asyncValues);
parcelHelpers.export(exports, "__makeTemplateObject", ()=>__makeTemplateObject);
parcelHelpers.export(exports, "__importStar", ()=>__importStar);
parcelHelpers.export(exports, "__importDefault", ()=>__importDefault);
parcelHelpers.export(exports, "__classPrivateFieldGet", ()=>__classPrivateFieldGet);
parcelHelpers.export(exports, "__classPrivateFieldSet", ()=>__classPrivateFieldSet);
parcelHelpers.export(exports, "__classPrivateFieldIn", ()=>__classPrivateFieldIn);
parcelHelpers.export(exports, "__addDisposableResource", ()=>__addDisposableResource);
parcelHelpers.export(exports, "__disposeResources", ()=>__disposeResources);
parcelHelpers.export(exports, "__rewriteRelativeImportExtension", ()=>__rewriteRelativeImportExtension);
var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || ({
        __proto__: []
    }) instanceof Array && function(d, b) {
        d.__proto__ = b;
    } || function(d, b) {
        for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return extendStatics(d, b);
};
function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for(var s, i = 1, n = arguments.length; i < n; i++){
            s = arguments[i];
            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
        for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
    return function(target, key) {
        decorator(target, key, paramIndex);
    };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
    }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for(var i = decorators.length - 1; i >= 0; i--){
        var context = {};
        for(var p in contextIn)context[p] = p === "access" ? {} : contextIn[p];
        for(var p in contextIn.access)context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
            if (done) throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? {
            get: descriptor.get,
            set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        } else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
}
function __runInitializers(thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for(var i = 0; i < initializers.length; i++)value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    return useValue ? value : void 0;
}
function __propKey(x) {
    return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
    if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
    return Object.defineProperty(f, "name", {
        configurable: true,
        value: prefix ? "".concat(prefix, " ", name) : name
    });
}
function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var __createBinding = Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) desc = {
        enumerable: true,
        get: function() {
            return m[k];
        }
    };
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
};
function __exportStar(m, o) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
    } catch (error) {
        e = {
            error: error
        };
    } finally{
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        } finally{
            if (e) throw e.error;
        }
    }
    return ar;
}
function __spread() {
    for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
    return ar;
}
function __spreadArrays() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
}
function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) {
        for(var i = 0, l = from.length, ar; i < l; i++)if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    function awaitReturn(f) {
        return function(v) {
            return Promise.resolve(v).then(f, reject);
        };
    }
    function verb(n, f) {
        if (g[n]) {
            i[n] = function(v) {
                return new Promise(function(a, b) {
                    q.push([
                        n,
                        v,
                        a,
                        b
                    ]) > 1 || resume(n, v);
                });
            };
            if (f) i[n] = f(i[n]);
        }
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
}
function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
    }), verb("return"), i[Symbol.iterator] = function() {
        return this;
    }, i;
    function verb(n, f) {
        i[n] = o[n] ? function(v) {
            return (p = !p) ? {
                value: __await(o[n](v)),
                done: false
            } : f ? f(v) : v;
        } : f;
    }
}
function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
}
function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) Object.defineProperty(cooked, "raw", {
        value: raw
    });
    else cooked.raw = raw;
    return cooked;
}
var __setModuleDefault = Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
};
var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o) {
        var ar = [];
        for(var k in o)if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
        return ar;
    };
    return ownKeys(o);
};
function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k = ownKeys(mod), i = 0; i < k.length; i++)if (k[i] !== "default") __createBinding(result, mod, k[i]);
    }
    __setModuleDefault(result, mod);
    return result;
}
function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
        default: mod
    };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
    if (value !== null && value !== void 0) {
        if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
        var dispose, inner;
        if (async) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            dispose = value[Symbol.asyncDispose];
        }
        if (dispose === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            dispose = value[Symbol.dispose];
            if (async) inner = dispose;
        }
        if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
        if (inner) dispose = function() {
            try {
                inner.call(this);
            } catch (e) {
                return Promise.reject(e);
            }
        };
        env.stack.push({
            value: value,
            dispose: dispose,
            async: async
        });
    } else if (async) env.stack.push({
        async: true
    });
    return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
    function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
    }
    var r, s = 0;
    function next() {
        while(r = env.stack.pop())try {
            if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
            if (r.dispose) {
                var result = r.dispose.call(r.value);
                if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
                    fail(e);
                    return next();
                });
            } else s |= 1;
        } catch (e) {
            fail(e);
        }
        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
        if (env.hasError) throw env.error;
    }
    return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
    if (typeof path === "string" && /^\.\.?\//.test(path)) return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m, tsx, d, ext, cm) {
        return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : d + ext + "." + cm.toLowerCase() + "js";
    });
    return path;
}
exports.default = {
    __extends: __extends,
    __assign: __assign,
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __esDecorate: __esDecorate,
    __runInitializers: __runInitializers,
    __propKey: __propKey,
    __setFunctionName: __setFunctionName,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __spreadArray: __spreadArray,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet,
    __classPrivateFieldIn: __classPrivateFieldIn,
    __addDisposableResource: __addDisposableResource,
    __disposeResources: __disposeResources,
    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"1SM0N":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logger", ()=>logger);
var _logger = require("@azure/logger");
const logger = (0, _logger.createClientLogger)("communication-chat");

},{"@azure/logger":"fqZlH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqZlH":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AzureLogger", ()=>AzureLogger);
/**
 * Immediately enables logging at the specified log level.
 * @param level - The log level to enable for logging.
 * Options from most verbose to least verbose are:
 * - verbose
 * - info
 * - warning
 * - error
 */ parcelHelpers.export(exports, "setLogLevel", ()=>setLogLevel);
/**
 * Retrieves the currently specified log level.
 */ parcelHelpers.export(exports, "getLogLevel", ()=>getLogLevel);
/**
 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
 * @param namespace - The name of the SDK package.
 * @hidden
 */ parcelHelpers.export(exports, "createClientLogger", ()=>createClientLogger);
var _tslib = require("tslib");
var _debug = require("./debug");
var _debugDefault = parcelHelpers.interopDefault(_debug);
var registeredLoggers = new Set();
var logLevelFromEnv = undefined;
var azureLogLevel;
var AzureLogger = (0, _debugDefault.default)("azure");
AzureLogger.log = function() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    (0, _debugDefault.default).log.apply((0, _debugDefault.default), (0, _tslib.__spread)(args));
};
var AZURE_LOG_LEVELS = [
    "verbose",
    "info",
    "warning",
    "error"
];
if (logLevelFromEnv) {
    // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
    if (isAzureLogLevel(logLevelFromEnv)) setLogLevel(logLevelFromEnv);
    else console.error("AZURE_LOG_LEVEL set to unknown log level '" + logLevelFromEnv + "'; logging is not enabled. Acceptable values: " + AZURE_LOG_LEVELS.join(", ") + ".");
}
function setLogLevel(level) {
    var e_1, _a;
    if (level && !isAzureLogLevel(level)) throw new Error("Unknown log level '" + level + "'. Acceptable values: " + AZURE_LOG_LEVELS.join(","));
    azureLogLevel = level;
    var enabledNamespaces = [];
    try {
        for(var registeredLoggers_1 = (0, _tslib.__values)(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()){
            var logger = registeredLoggers_1_1.value;
            if (shouldEnable(logger)) enabledNamespaces.push(logger.namespace);
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return)) _a.call(registeredLoggers_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    (0, _debugDefault.default).enable(enabledNamespaces.join(","));
}
function getLogLevel() {
    return azureLogLevel;
}
var levelMap = {
    verbose: 400,
    info: 300,
    warning: 200,
    error: 100
};
function createClientLogger(namespace) {
    var clientRootLogger = AzureLogger.extend(namespace);
    patchLogMethod(AzureLogger, clientRootLogger);
    return {
        error: createLogger(clientRootLogger, "error"),
        warning: createLogger(clientRootLogger, "warning"),
        info: createLogger(clientRootLogger, "info"),
        verbose: createLogger(clientRootLogger, "verbose")
    };
}
function patchLogMethod(parent, child) {
    child.log = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        parent.log.apply(parent, (0, _tslib.__spread)(args));
    };
}
function createLogger(parent, level) {
    var logger = Object.assign(parent.extend(level), {
        level: level
    });
    patchLogMethod(parent, logger);
    if (shouldEnable(logger)) {
        var enabledNamespaces = (0, _debugDefault.default).disable();
        (0, _debugDefault.default).enable(enabledNamespaces + "," + logger.namespace);
    }
    registeredLoggers.add(logger);
    return logger;
}
function shouldEnable(logger) {
    if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) return true;
    else return false;
}
function isAzureLogLevel(logLevel) {
    return AZURE_LOG_LEVELS.includes(logLevel);
}

},{"tslib":"iC1Dx","./debug":"6zUkA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6zUkA":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _tslib = require("tslib");
/* eslint-disable no-invalid-this */ var _log = require("./log");
var debugEnvVariable = undefined;
var enabledString;
var enabledNamespaces = [];
var skippedNamespaces = [];
var debuggers = [];
if (debugEnvVariable) enable(debugEnvVariable);
var debugObj = Object.assign(function(namespace) {
    return createDebugger(namespace);
}, {
    enable: enable,
    enabled: enabled,
    disable: disable,
    log: (0, _log.log)
});
function enable(namespaces) {
    var e_1, _a, e_2, _b;
    enabledString = namespaces;
    enabledNamespaces = [];
    skippedNamespaces = [];
    var wildcard = /\*/g;
    var namespaceList = namespaces.split(",").map(function(ns) {
        return ns.trim().replace(wildcard, ".*?");
    });
    try {
        for(var namespaceList_1 = (0, _tslib.__values)(namespaceList), namespaceList_1_1 = namespaceList_1.next(); !namespaceList_1_1.done; namespaceList_1_1 = namespaceList_1.next()){
            var ns = namespaceList_1_1.value;
            if (ns.startsWith("-")) skippedNamespaces.push(new RegExp("^" + ns.substr(1) + "$"));
            else enabledNamespaces.push(new RegExp("^" + ns + "$"));
        }
    } catch (e_1_1) {
        e_1 = {
            error: e_1_1
        };
    } finally{
        try {
            if (namespaceList_1_1 && !namespaceList_1_1.done && (_a = namespaceList_1.return)) _a.call(namespaceList_1);
        } finally{
            if (e_1) throw e_1.error;
        }
    }
    try {
        for(var debuggers_1 = (0, _tslib.__values)(debuggers), debuggers_1_1 = debuggers_1.next(); !debuggers_1_1.done; debuggers_1_1 = debuggers_1.next()){
            var instance = debuggers_1_1.value;
            instance.enabled = enabled(instance.namespace);
        }
    } catch (e_2_1) {
        e_2 = {
            error: e_2_1
        };
    } finally{
        try {
            if (debuggers_1_1 && !debuggers_1_1.done && (_b = debuggers_1.return)) _b.call(debuggers_1);
        } finally{
            if (e_2) throw e_2.error;
        }
    }
}
function enabled(namespace) {
    var e_3, _a, e_4, _b;
    if (namespace.endsWith("*")) return true;
    try {
        for(var skippedNamespaces_1 = (0, _tslib.__values)(skippedNamespaces), skippedNamespaces_1_1 = skippedNamespaces_1.next(); !skippedNamespaces_1_1.done; skippedNamespaces_1_1 = skippedNamespaces_1.next()){
            var skipped = skippedNamespaces_1_1.value;
            if (skipped.test(namespace)) return false;
        }
    } catch (e_3_1) {
        e_3 = {
            error: e_3_1
        };
    } finally{
        try {
            if (skippedNamespaces_1_1 && !skippedNamespaces_1_1.done && (_a = skippedNamespaces_1.return)) _a.call(skippedNamespaces_1);
        } finally{
            if (e_3) throw e_3.error;
        }
    }
    try {
        for(var enabledNamespaces_1 = (0, _tslib.__values)(enabledNamespaces), enabledNamespaces_1_1 = enabledNamespaces_1.next(); !enabledNamespaces_1_1.done; enabledNamespaces_1_1 = enabledNamespaces_1.next()){
            var enabledNamespace = enabledNamespaces_1_1.value;
            if (enabledNamespace.test(namespace)) return true;
        }
    } catch (e_4_1) {
        e_4 = {
            error: e_4_1
        };
    } finally{
        try {
            if (enabledNamespaces_1_1 && !enabledNamespaces_1_1.done && (_b = enabledNamespaces_1.return)) _b.call(enabledNamespaces_1);
        } finally{
            if (e_4) throw e_4.error;
        }
    }
    return false;
}
function disable() {
    var result = enabledString || "";
    enable("");
    return result;
}
function createDebugger(namespace) {
    var newDebugger = Object.assign(debug, {
        enabled: enabled(namespace),
        destroy: destroy,
        log: debugObj.log,
        namespace: namespace,
        extend: extend
    });
    function debug() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        if (!newDebugger.enabled) return;
        if (args.length > 0) args[0] = namespace + " " + args[0];
        newDebugger.log.apply(newDebugger, (0, _tslib.__spread)(args));
    }
    debuggers.push(newDebugger);
    return newDebugger;
}
function destroy() {
    var index = debuggers.indexOf(this);
    if (index >= 0) {
        debuggers.splice(index, 1);
        return true;
    }
    return false;
}
function extend(namespace) {
    var newDebugger = createDebugger(this.namespace + ":" + namespace);
    newDebugger.log = this.log;
    return newDebugger;
}
exports.default = debugObj;

},{"tslib":"iC1Dx","./log":"t0Yzb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"t0Yzb":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "log", ()=>log);
var _tslib = require("tslib");
function log() {
    var args = [];
    for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
    if (args.length > 0) {
        var firstArg = String(args[0]);
        if (firstArg.includes(":error")) console.error.apply(console, (0, _tslib.__spread)(args));
        else if (firstArg.includes(":warning")) console.warn.apply(console, (0, _tslib.__spread)(args));
        else if (firstArg.includes(":info")) console.info.apply(console, (0, _tslib.__spread)(args));
        else if (firstArg.includes(":verbose")) console.debug.apply(console, (0, _tslib.__spread)(args));
        else console.debug.apply(console, (0, _tslib.__spread)(args));
    }
}

},{"tslib":"iC1Dx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1Gpx3":[function(require,module,exports,__globalThis) {
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';
var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') ReflectOwnKeys = R.ownKeys;
else if (Object.getOwnPropertySymbols) ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
};
else ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
};
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === 'function') ReflectApply(handler, this, args);
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === 'function') // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [
            listener,
            existing
        ] : [
            existing,
            listener
        ];
        else if (prepend) existing.unshift(listener);
        else existing.push(listener);
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
    } else if (typeof list !== 'function') {
        position = -1;
        for(i = list.length - 1; i >= 0; i--)if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else spliceOne(list, position);
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === 'function') this.removeListener(type, listeners);
    else if (listeners !== undefined) // LIFO order
    for(i = listeners.length - 1; i >= 0; i--)this.removeListener(type, listeners[i]);
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') return emitter.listenerCount(type);
    else return listenerCount.call(emitter, type);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') return 1;
        else if (evlistener !== undefined) return evlistener.length;
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i)ret[i] = arr[i].listener || arr[i];
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') emitter.removeListener('error', errorListener);
            resolve([].slice.call(arguments));
        }
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== 'error') addErrorHandlerIfEventEmitter(emitter, errorListener, {
            once: true
        });
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) emitter.once(name, listener);
        else emitter.on(name, listener);
    } else if (typeof emitter.addEventListener === 'function') // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) emitter.removeEventListener(name, wrapListener);
        listener(arg);
    });
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
}

},{}],"k8iSE":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SDK_VERSION", ()=>SDK_VERSION);
const SDK_VERSION = "1.0.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iFYeD":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSignalingClient", ()=>getSignalingClient);
var _communicationSignaling = require("@azure/communication-signaling");
const getSignalingClient = (credential, logger)=>{
    return new (0, _communicationSignaling.CommunicationSignalingClient)(credential, logger);
};

},{"@azure/communication-signaling":"73Bzg","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"73Bzg":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var process = require("602c135dbe3c0dd");
(function(global, factory) {
    module.exports = factory();
})(this, function() {
    'use strict';
    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
    function unwrapExports(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }
    function createCommonjsModule(fn, module1) {
        return module1 = {
            exports: {}
        }, fn(module1, module1.exports), module1.exports;
    }
    var tsregistrar = createCommonjsModule(function(module1, exports) {
        !function(t, e) {
            module1.exports = e();
        }(commonjsGlobal, function() {
            return function(t) {
                function e(n) {
                    if (r[n]) return r[n].exports;
                    var o = r[n] = {
                        i: n,
                        l: !1,
                        exports: {}
                    };
                    return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports;
                }
                var r = {};
                return e.m = t, e.c = r, e.i = function(t) {
                    return t;
                }, e.d = function(t, r, n) {
                    e.o(t, r) || Object.defineProperty(t, r, {
                        configurable: !1,
                        enumerable: !0,
                        get: n
                    });
                }, e.n = function(t) {
                    var r = t && t.__esModule ? function() {
                        return t.default;
                    } : function() {
                        return t;
                    };
                    return e.d(r, "a", r), r;
                }, e.o = function(t, e) {
                    return Object.prototype.hasOwnProperty.call(t, e);
                }, e.p = "", e(e.s = 1);
            }([
                function(t, e, r) {
                    function n(t) {
                        try {
                            return JSON.stringify(t);
                        } catch (e) {
                            return "Unable to serialize object of type " + typeof t;
                        }
                    }
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }), e.toJson = n;
                    var o = function() {
                        function t() {
                            this.start = Date.now();
                        }
                        return Object.defineProperty(t.prototype, "duration", {
                            get: function() {
                                return Date.now() - this.start;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(t.prototype, "startTime", {
                            get: function() {
                                return this.start;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), t.prototype.reset = function() {
                            this.start = Date.now();
                        }, t;
                    }();
                    e.Timespan = o;
                },
                function(t, e, r) {
                    function n(t, e, r) {
                        return new f(t, e, r);
                    }
                    var o = this && this.__extends || function() {
                        var t = Object.setPrototypeOf || ({
                            __proto__: []
                        }) instanceof Array && function(t, e) {
                            t.__proto__ = e;
                        } || function(t, e) {
                            for(var r in e)e.hasOwnProperty(r) && (t[r] = e[r]);
                        };
                        return function(e, r) {
                            function n() {
                                this.constructor = e;
                            }
                            t(e, r), e.prototype = null === r ? Object.create(r) : (n.prototype = r.prototype, new n);
                        };
                    }(), i = this && this.__awaiter || function(t, e, r, n) {
                        return new (r || (r = Promise))(function(o, i) {
                            function s(t) {
                                try {
                                    c(n.next(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function a(t) {
                                try {
                                    c(n.throw(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function c(t) {
                                t.done ? o(t.value) : new r(function(e) {
                                    e(t.value);
                                }).then(s, a);
                            }
                            c((n = n.apply(t, e || [])).next());
                        });
                    }, s = this && this.__generator || function(t, e) {
                        function r(t) {
                            return function(e) {
                                return n([
                                    t,
                                    e
                                ]);
                            };
                        }
                        function n(r) {
                            if (o) throw new TypeError("Generator is already executing.");
                            for(; c;)try {
                                if (o = 1, i && (s = 2 & r[0] ? i.return : r[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, r[1])).done) return s;
                                switch(i = 0, s && (r = [
                                    2 & r[0],
                                    s.value
                                ]), r[0]){
                                    case 0:
                                    case 1:
                                        s = r;
                                        break;
                                    case 4:
                                        return c.label++, {
                                            value: r[1],
                                            done: !1
                                        };
                                    case 5:
                                        c.label++, i = r[1], r = [
                                            0
                                        ];
                                        continue;
                                    case 7:
                                        r = c.ops.pop(), c.trys.pop();
                                        continue;
                                    default:
                                        if (s = c.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === r[0] || 2 === r[0])) {
                                            c = 0;
                                            continue;
                                        }
                                        if (3 === r[0] && (!s || r[1] > s[0] && r[1] < s[3])) {
                                            c.label = r[1];
                                            break;
                                        }
                                        if (6 === r[0] && c.label < s[1]) {
                                            c.label = s[1], s = r;
                                            break;
                                        }
                                        if (s && c.label < s[2]) {
                                            c.label = s[2], c.ops.push(r);
                                            break;
                                        }
                                        s[2] && c.ops.pop(), c.trys.pop();
                                        continue;
                                }
                                r = e.call(t, c);
                            } catch (t) {
                                r = [
                                    6,
                                    t
                                ], i = 0;
                            } finally{
                                o = s = 0;
                            }
                            if (5 & r[0]) throw r[1];
                            return {
                                value: r[0] ? r[1] : void 0,
                                done: !0
                            };
                        }
                        var o, i, s, a, c = {
                            label: 0,
                            sent: function() {
                                if (1 & s[0]) throw s[1];
                                return s[1];
                            },
                            trys: [],
                            ops: []
                        };
                        return a = {
                            next: r(0),
                            throw: r(1),
                            return: r(2)
                        }, "function" == typeof Symbol && (a[Symbol.iterator] = function() {
                            return this;
                        }), a;
                    };
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var a = r(0), c = function(t) {
                        function e(e) {
                            var r = t.call(this, e) || this;
                            return r.name = "CancelationError", r;
                        }
                        return o(e, t), e;
                    }(Error), u = function() {
                        function t(e, r, n) {
                            this.logger = e, this.maxBackoffInMs = r, this.initialDelay = n, this.backoffCount = 0, this.id = ++t.idCounter;
                        }
                        return t.prototype.delay = function(t) {
                            var e = this;
                            if (void 0 !== this.timerHandle) throw new Error("Retry sequence logical failure");
                            if (-1 === this.backoffCount) return new Promise(function(t, e) {
                                e(new c("Cancelled"));
                            });
                            var r = this.calculateNextBackoffMs();
                            return this.backoffCount++, this.logger.info("[RegistrarClient] Backing off " + t + " for " + r + " milliseconds with ID " + this.id), new Promise(function(n, o) {
                                e.cancelFunc = o, e.timerHandle = setTimeout(function() {
                                    e.logger.info("[RegistrarClient] Back off for " + t + " with ID " + e.id + " complete"), e.timerHandle = void 0, n();
                                }, r);
                            });
                        }, t.prototype.cancel = function() {
                            void 0 !== this.timerHandle && (this.logger.debug("Resetting back off"), clearTimeout(this.timerHandle), void 0 !== this.cancelFunc && this.cancelFunc(new c("Cancelled"))), this.backoffCount = -1;
                        }, t.prototype.calculateNextBackoffMs = function() {
                            var t = 1 + .4 * (Math.random() - .5), e = this.initialDelay * Math.pow(2, this.backoffCount) * t;
                            return e = Math.round(e), Math.min(this.maxBackoffInMs, e);
                        }, t.idCounter = 0, t;
                    }(), f = function() {
                        function t(t, e, r) {
                            this.logger = t, this.skypeTokenProvider = e, this.options = r, this.backoffs = {};
                        }
                        return t.prototype.setTelemetryLogger = function(t) {
                            this.eventLogger = t;
                        }, t.prototype.register = function(t, e) {
                            return i(this, void 0, void 0, function() {
                                return s(this, function(r) {
                                    switch(r.label){
                                        case 0:
                                            return [
                                                4,
                                                this.performRegistration(t, e, "pr_set_registration")
                                            ];
                                        case 1:
                                            return r.sent(), this.cachedRegistrationParams = [
                                                t,
                                                e
                                            ], [
                                                2
                                            ];
                                    }
                                });
                            });
                        }, t.prototype.unregister = function() {
                            return i(this, void 0, void 0, function() {
                                var t;
                                return s(this, function(e) {
                                    switch(e.label){
                                        case 0:
                                            return this.logger.info("[RegistrarClient] sending unregister request"), t = new Request(this.options.registrarUrl + "/" + this.options.registrationId, {
                                                method: "DELETE",
                                                mode: "cors",
                                                headers: new Headers({
                                                    accept: "application/json, text/javascript"
                                                })
                                            }), [
                                                4,
                                                this.callRegistrar(t, "pr_delete_registration")
                                            ];
                                        case 1:
                                            return e.sent(), [
                                                2
                                            ];
                                    }
                                });
                            });
                        }, t.prototype.cancelPendingRequests = function() {
                            var t = this;
                            Object.keys(this.backoffs).forEach(function(e) {
                                t.backoffs[e].cancel();
                            }), this.backoffs = {};
                        }, t.prototype.resendRegistration = function() {
                            return i(this, void 0, void 0, function() {
                                return s(this, function(t) {
                                    switch(t.label){
                                        case 0:
                                            if (!this.cachedRegistrationParams) throw new Error("Re-registration failed because there is no registration parameters cached");
                                            return [
                                                4,
                                                this.performRegistration(this.cachedRegistrationParams[0], this.cachedRegistrationParams[1], "pr_resend_registration")
                                            ];
                                        case 1:
                                            return t.sent(), [
                                                2
                                            ];
                                    }
                                });
                            });
                        }, t.prototype.performRegistration = function(t, e, r) {
                            return i(this, void 0, void 0, function() {
                                var n, o;
                                return s(this, function(i) {
                                    switch(i.label){
                                        case 0:
                                            return this.logger.info("[RegistrarClient] Sending register request"), n = {
                                                clientDescription: t,
                                                registrationId: this.options.registrationId,
                                                nodeId: "",
                                                transports: e
                                            }, o = new Request(this.options.registrarUrl, {
                                                method: "POST",
                                                mode: "cors",
                                                headers: new Headers({
                                                    "content-type": "application/json",
                                                    accept: "application/json, text/javascript"
                                                }),
                                                body: a.toJson(n)
                                            }), [
                                                4,
                                                this.callRegistrar(o, r)
                                            ];
                                        case 1:
                                            return i.sent(), [
                                                2
                                            ];
                                    }
                                });
                            });
                        }, t.prototype.startBackoff = function() {
                            var t = new u(this.logger, this.options.maxRetryDelayMs, this.options.initialRetryDelayMs);
                            return this.backoffs[t.id] = t, t;
                        }, t.prototype.stopBackoff = function(t) {
                            t.cancel(), delete this.backoffs[t.id];
                        }, t.prototype.getSkypeToken = function() {
                            return i(this, void 0, void 0, function() {
                                var t, e, r, n;
                                return s(this, function(o) {
                                    switch(o.label){
                                        case 0:
                                            t = this.startBackoff(), o.label = 1;
                                        case 1:
                                            return o.trys.push([
                                                1,
                                                3,
                                                ,
                                                8
                                            ]), this.logger.info("[RegistrarClient] Asking for a new skypetoken"), [
                                                4,
                                                this.skypeTokenProvider(!0)
                                            ];
                                        case 2:
                                            return e = o.sent(), this.stopBackoff(t), [
                                                2,
                                                e
                                            ];
                                        case 3:
                                            r = o.sent(), o.label = 4;
                                        case 4:
                                            return o.trys.push([
                                                4,
                                                6,
                                                ,
                                                7
                                            ]), [
                                                4,
                                                t.delay("Fetching a new skypetoken")
                                            ];
                                        case 5:
                                            return o.sent(), [
                                                3,
                                                8
                                            ];
                                        case 6:
                                            throw n = o.sent(), this.stopBackoff(t), n;
                                        case 7:
                                            return [
                                                3,
                                                8
                                            ];
                                        case 8:
                                            return [
                                                3,
                                                1
                                            ];
                                        case 9:
                                            return [
                                                2
                                            ];
                                    }
                                });
                            });
                        }, t.prototype.callRegistrar = function(t, e) {
                            return i(this, void 0, void 0, function() {
                                var r, n, o, i, c, u, f, l, h;
                                return s(this, function(s) {
                                    switch(s.label){
                                        case 0:
                                            return r = this.startBackoff(), [
                                                4,
                                                this.skypeTokenProvider(!1)
                                            ];
                                        case 1:
                                            n = s.sent(), this.setSkypeTokenHeader(t, n), o = new a.Timespan, s.label = 2;
                                        case 2:
                                            i = void 0, s.label = 3;
                                        case 3:
                                            return s.trys.push([
                                                3,
                                                8,
                                                13,
                                                14
                                            ]), c = t.clone(), [
                                                4,
                                                this.fetchWithTimeout(c)
                                            ];
                                        case 4:
                                            return i = s.sent(), 401 !== i.status ? [
                                                3,
                                                6
                                            ] : (u = this.setSkypeTokenHeader, f = [
                                                t
                                            ], [
                                                4,
                                                this.getSkypeToken()
                                            ]);
                                        case 5:
                                            return u.apply(this, f.concat([
                                                s.sent()
                                            ])), [
                                                3,
                                                15
                                            ];
                                        case 6:
                                            if (i.status >= 500 && i.status < 600) throw new Error("Fetch for '" + t.url + "' failed with " + i.status + " " + i.statusText);
                                            s.label = 7;
                                        case 7:
                                            return [
                                                3,
                                                14
                                            ];
                                        case 8:
                                            l = s.sent(), this.logger.error("[RegistrarClient] Request failed with " + l), s.label = 9;
                                        case 9:
                                            return s.trys.push([
                                                9,
                                                11,
                                                ,
                                                12
                                            ]), [
                                                4,
                                                r.delay("Registrar call retry")
                                            ];
                                        case 10:
                                            return s.sent(), [
                                                3,
                                                15
                                            ];
                                        case 11:
                                            throw h = s.sent(), this.logger.error("[RegistrarClient] Request cancelled"), this.stopBackoff(r), h;
                                        case 12:
                                            return [
                                                3,
                                                14
                                            ];
                                        case 13:
                                            return this.sendTelemetryEvent(e, t, i, o), [
                                                7
                                            ];
                                        case 14:
                                            if (this.stopBackoff(r), i.ok) return [
                                                2,
                                                i
                                            ];
                                            throw new Error("Fetch for '" + t.url + "' failed with " + i.status + " " + i.statusText);
                                        case 15:
                                            return [
                                                3,
                                                2
                                            ];
                                        case 16:
                                            return [
                                                2
                                            ];
                                    }
                                });
                            });
                        }, t.prototype.setSkypeTokenHeader = function(t, e) {
                            t.headers.set("X-Skypetoken", e);
                        }, t.prototype.fetchWithTimeout = function(t) {
                            var e = this;
                            return new Promise(function(r, n) {
                                fetch(t).then(r).catch(n), 0 !== e.options.requestTimeoutMs && setTimeout(n, e.options.requestTimeoutMs, new Error("Fetch for '" + t.url + "' timed out"));
                            });
                        }, t.prototype.sendTelemetryEvent = function(t, e, r, n) {
                            if (void 0 !== this.eventLogger) {
                                var o = {
                                    name: t,
                                    properties: {
                                        url: {
                                            value: e.url
                                        },
                                        result_code: {
                                            value: void 0 !== r ? r.status : 0
                                        },
                                        begin_timestamp: {
                                            value: n.startTime
                                        },
                                        elapsed: {
                                            value: n.duration
                                        }
                                    }
                                };
                                this.eventLogger.logEvent(o);
                            }
                        }, t;
                    }();
                    e.RegistrarClient = f, e.createRegistrarClient = n;
                }
            ]);
        });
    });
    unwrapExports(tsregistrar);
    var tstrouter = createCommonjsModule(function(module1, exports) {
        !function(t, e) {
            module1.exports = e(tsregistrar);
        }(commonjsGlobal, function(__WEBPACK_EXTERNAL_MODULE_20__) {
            return function(t) {
                function e(o) {
                    if (n[o]) return n[o].exports;
                    var r = n[o] = {
                        i: o,
                        l: !1,
                        exports: {}
                    };
                    return t[o].call(r.exports, r, r.exports, e), r.l = !0, r.exports;
                }
                var n = {};
                return e.m = t, e.c = n, e.i = function(t) {
                    return t;
                }, e.d = function(t, n, o) {
                    e.o(t, n) || Object.defineProperty(t, n, {
                        configurable: !1,
                        enumerable: !0,
                        get: o
                    });
                }, e.n = function(t) {
                    var n = t && t.__esModule ? function() {
                        return t.default;
                    } : function() {
                        return t;
                    };
                    return e.d(n, "a", n), n;
                }, e.o = function(t, e) {
                    return Object.prototype.hasOwnProperty.call(t, e);
                }, e.p = "", e(e.s = 19);
            }([
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = function() {
                        function t(t, e) {
                            this.name = t, this.logger = e;
                        }
                        return t.prototype.debug = function(t) {
                            this.logger.debug("[" + this.name + "] " + t);
                        }, t.prototype.info = function(t) {
                            this.logger.info("[" + this.name + "] " + t);
                        }, t.prototype.warn = function(t) {
                            this.logger.warn("[" + this.name + "] " + t);
                        }, t.prototype.error = function(t) {
                            this.logger.error("[" + this.name + "] " + t);
                        }, t;
                    }();
                    e.Logger = o;
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = function() {
                        function t() {}
                        return t;
                    }();
                    e.HttpHeaders = o;
                    !function(t) {
                        t[t.Unknown = 0] = "Unknown", t[t.Connected = 2] = "Connected", t[t.Disconnected = 3] = "Disconnected", t[t.Switching = 9] = "Switching";
                    }(e.TrouterState || (e.TrouterState = {}));
                    !function(t) {
                        t[t.Unknown = 0] = "Unknown", t[t.Active = 1] = "Active", t[t.Inactive = 2] = "Inactive";
                    }(e.UserActivityState || (e.UserActivityState = {}));
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }), e.constants = {
                        TROUTER_INIT: "trouterinit",
                        TROUTER_READY_EVENT: "trouterReadyEvent",
                        TROUTER_READY_TIMEOUT: "trouterReadyTimeout",
                        TROUTER_TOKEN_REQUEST: "trouterTokenRequest",
                        TROUTER_TOKEN_GET_SUCCEEDED: "trouterTokenGetSucceeded",
                        TROUTER_TOKEN_GET_FAILED: "trouterTokenGetFailed",
                        TROUTER_RECONNECTING: "trouterReconnecting",
                        RENEWAL: "renewal",
                        NEW_CONNECTION: "newConnection",
                        ENDPOINT_REGISTRATION_FAILED: "endpointRegistrationFailed"
                    }, e.CLIENT_VERSION = "2020.37.01.1", e.HANDLED_MESSAGE_ACK = 200, e.UNHANDLED_MESSAGE_ACK = 404, e.FAILED_MESSAGE_ACK = 500;
                },
                function(t, e, n) {
                    function o(t) {
                        try {
                            return JSON.stringify(t);
                        } catch (e) {
                            return "Unable to serialize object of type " + typeof t;
                        }
                    }
                    function r(t) {
                        var e = Math.round((new Date).getTime() / 1e3);
                        return void 0 !== t && t > e ? t - e : 0;
                    }
                    function i(t) {
                        return Math.round((new Date).getTime() / 1e3) + t;
                    }
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }), e.toJson = o, e.calculateTtlInSec = r, e.calculateExpireTsInSec = i;
                    var s = function() {
                        function t() {
                            this.start = Date.now();
                        }
                        return Object.defineProperty(t.prototype, "duration", {
                            get: function() {
                                return Date.now() - this.start;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), Object.defineProperty(t.prototype, "startTime", {
                            get: function() {
                                return this.start;
                            },
                            enumerable: !0,
                            configurable: !0
                        }), t.prototype.reset = function() {
                            this.start = Date.now();
                        }, t;
                    }();
                    e.Timespan = s;
                },
                function(t, e) {
                    var n;
                    n = function() {
                        return this;
                    }();
                    try {
                        n = n || Function("return this")() || (0, eval)("this");
                    } catch (t) {
                        "object" == typeof window && (n = window);
                    }
                    t.exports = n;
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = n(3), r = function() {
                        function t(t, e, n, o, r, i, s) {
                            this.connectionId = t, this.connectedClientId = e, this.domId = n, this.unsecureUrl = o, this.url = r, this.c2cUrlBase = i, this.expirationTsSec = s;
                        }
                        return t.prototype.getRemainingTtlInSec = function() {
                            return o.calculateTtlInSec(this.expirationTsSec);
                        }, t;
                    }();
                    e.ServerState = r;
                    !function(t) {
                        t[t.Unknown = 0] = "Unknown", t[t.Modified = 1] = "Modified", t[t.Snapshot = 2] = "Snapshot", t[t.Connected = 3] = "Connected";
                    }(e.UserActivityEventReason || (e.UserActivityEventReason = {}));
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = n(2), r = function() {
                        function t(t) {
                            this.logger = t, this.messageHandlers = [];
                        }
                        return t.prototype.register = function(t) {
                            if (this.messageHandlers.some(function(e) {
                                return e === t;
                            })) throw new Error("Registering the same handler twice is not allowed");
                            this.messageHandlers.push(t);
                        }, t.prototype.clear = function() {
                            this.logger.debug("Clearing message handlers"), this.messageHandlers = [];
                        }, t.prototype.active = function() {
                            return this.messageHandlers.length > 0;
                        }, t.prototype.handleMessage = function(t) {
                            for(var e = {
                                resultCode: o.UNHANDLED_MESSAGE_ACK,
                                isHandled: !1
                            }, n = 0, r = this.messageHandlers; n < r.length; n++){
                                var i = r[n], s = this.safeExecuteHandle(i, t);
                                if (void 0 !== s && (void 0 === s.isHandled || s.isHandled)) return void 0 === s.resultCode && (s.resultCode = o.HANDLED_MESSAGE_ACK), s;
                            }
                            return e;
                        }, t.prototype.safeExecuteHandle = function(t, e) {
                            try {
                                return t.handleMessage(e);
                            } catch (t) {
                                return void this.logger.warn("A trouter message handler is throwing exceptions. exception: " + t);
                            }
                        }, t;
                    }();
                    e.MessageHandlerRegistry = r;
                },
                function(t, e, n) {
                    function o(t) {
                        var e, n = this;
                        return function(o) {
                            return r(n, void 0, void 0, function() {
                                return i(this, function(n) {
                                    return o && (e = void 0), [
                                        2,
                                        new Promise(function(n, r) {
                                            t(o).then(function(t) {
                                                e = t, n(t);
                                            }).catch(function(t) {
                                                void 0 !== e && e.length > 0 && n(e), r(t);
                                            });
                                        })
                                    ];
                                });
                            });
                        };
                    }
                    var r = this && this.__awaiter || function(t, e, n, o) {
                        return new (n || (n = Promise))(function(r, i) {
                            function s(t) {
                                try {
                                    a(o.next(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function c(t) {
                                try {
                                    a(o.throw(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function a(t) {
                                t.done ? r(t.value) : new n(function(e) {
                                    e(t.value);
                                }).then(s, c);
                            }
                            a((o = o.apply(t, e || [])).next());
                        });
                    }, i = this && this.__generator || function(t, e) {
                        function n(t) {
                            return function(e) {
                                return o([
                                    t,
                                    e
                                ]);
                            };
                        }
                        function o(n) {
                            if (r) throw new TypeError("Generator is already executing.");
                            for(; a;)try {
                                if (r = 1, i && (s = 2 & n[0] ? i.return : n[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, n[1])).done) return s;
                                switch(i = 0, s && (n = [
                                    2 & n[0],
                                    s.value
                                ]), n[0]){
                                    case 0:
                                    case 1:
                                        s = n;
                                        break;
                                    case 4:
                                        return a.label++, {
                                            value: n[1],
                                            done: !1
                                        };
                                    case 5:
                                        a.label++, i = n[1], n = [
                                            0
                                        ];
                                        continue;
                                    case 7:
                                        n = a.ops.pop(), a.trys.pop();
                                        continue;
                                    default:
                                        if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {
                                            a = 0;
                                            continue;
                                        }
                                        if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {
                                            a.label = n[1];
                                            break;
                                        }
                                        if (6 === n[0] && a.label < s[1]) {
                                            a.label = s[1], s = n;
                                            break;
                                        }
                                        if (s && a.label < s[2]) {
                                            a.label = s[2], a.ops.push(n);
                                            break;
                                        }
                                        s[2] && a.ops.pop(), a.trys.pop();
                                        continue;
                                }
                                n = e.call(t, a);
                            } catch (t) {
                                n = [
                                    6,
                                    t
                                ], i = 0;
                            } finally{
                                r = s = 0;
                            }
                            if (5 & n[0]) throw n[1];
                            return {
                                value: n[0] ? n[1] : void 0,
                                done: !0
                            };
                        }
                        var r, i, s, c, a = {
                            label: 0,
                            sent: function() {
                                if (1 & s[0]) throw s[1];
                                return s[1];
                            },
                            trys: [],
                            ops: []
                        };
                        return c = {
                            next: n(0),
                            throw: n(1),
                            return: n(2)
                        }, "function" == typeof Symbol && (c[Symbol.iterator] = function() {
                            return this;
                        }), c;
                    };
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    }), e.addCacheAsBackupTo = o;
                },
                function(t, e, n) {
                    var o = this && this.__awaiter || function(t, e, n, o) {
                        return new (n || (n = Promise))(function(r, i) {
                            function s(t) {
                                try {
                                    a(o.next(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function c(t) {
                                try {
                                    a(o.throw(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function a(t) {
                                t.done ? r(t.value) : new n(function(e) {
                                    e(t.value);
                                }).then(s, c);
                            }
                            a((o = o.apply(t, e || [])).next());
                        });
                    }, r = this && this.__generator || function(t, e) {
                        function n(t) {
                            return function(e) {
                                return o([
                                    t,
                                    e
                                ]);
                            };
                        }
                        function o(n) {
                            if (r) throw new TypeError("Generator is already executing.");
                            for(; a;)try {
                                if (r = 1, i && (s = 2 & n[0] ? i.return : n[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, n[1])).done) return s;
                                switch(i = 0, s && (n = [
                                    2 & n[0],
                                    s.value
                                ]), n[0]){
                                    case 0:
                                    case 1:
                                        s = n;
                                        break;
                                    case 4:
                                        return a.label++, {
                                            value: n[1],
                                            done: !1
                                        };
                                    case 5:
                                        a.label++, i = n[1], n = [
                                            0
                                        ];
                                        continue;
                                    case 7:
                                        n = a.ops.pop(), a.trys.pop();
                                        continue;
                                    default:
                                        if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {
                                            a = 0;
                                            continue;
                                        }
                                        if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {
                                            a.label = n[1];
                                            break;
                                        }
                                        if (6 === n[0] && a.label < s[1]) {
                                            a.label = s[1], s = n;
                                            break;
                                        }
                                        if (s && a.label < s[2]) {
                                            a.label = s[2], a.ops.push(n);
                                            break;
                                        }
                                        s[2] && a.ops.pop(), a.trys.pop();
                                        continue;
                                }
                                n = e.call(t, a);
                            } catch (t) {
                                n = [
                                    6,
                                    t
                                ], i = 0;
                            } finally{
                                r = s = 0;
                            }
                            if (5 & n[0]) throw n[1];
                            return {
                                value: n[0] ? n[1] : void 0,
                                done: !0
                            };
                        }
                        var r, i, s, c, a = {
                            label: 0,
                            sent: function() {
                                if (1 & s[0]) throw s[1];
                                return s[1];
                            },
                            trys: [],
                            ops: []
                        };
                        return c = {
                            next: n(0),
                            throw: n(1),
                            return: n(2)
                        }, "function" == typeof Symbol && (c[Symbol.iterator] = function() {
                            return this;
                        }), c;
                    };
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var i = n(3), s = n(1), c = n(0), a = n(16), u = n(18), h = function() {
                        function t(t, e, n, o) {
                            this.logFunc = t, this.options = e, this.tokenProvider = n, this.listener = o, this.logger = new c.Logger("Manager", t), this.logger.info("Created TrouterManager with options " + i.toJson(this.options)), this.fsm = new u.TrouterManagerFsm(t, this), this.baseEndpointUrl = "", this.processedMessageLoss = {};
                        }
                        return t.prototype.start = function() {
                            this.fsm.start();
                        }, t.prototype.stop = function() {
                            this.fsm.stop();
                        }, t.prototype.configure = function(t) {
                            this.options = t, void 0 !== this.firstConnection && this.firstConnection.configure(t), void 0 !== this.secondConnection && this.secondConnection.configure(t), this.logger.info("Reconfigured TrouterManager with options " + i.toJson(this.options));
                        }, t.prototype.checkConnection = function(t) {
                            void 0 !== this.firstConnection && this.firstConnection.checkConnection(t), void 0 !== this.secondConnection && this.secondConnection.checkConnection(t);
                        }, t.prototype.resendRegistration = function() {
                            return o(this, void 0, void 0, function() {
                                return r(this, function(t) {
                                    return void 0 !== this.secondConnection ? (this.logger.info("Resending registration on the second/new connection"), [
                                        2,
                                        this.secondConnection.resendRegistration()
                                    ]) : void 0 !== this.firstConnection ? (this.logger.info("Resending registration on the first/current connection"), [
                                        2,
                                        this.firstConnection.resendRegistration()
                                    ]) : (this.logger.info("No connection to resend registration on, will be done upon (re)connect"), [
                                        2
                                    ]);
                                });
                            });
                        }, t.prototype.getServerState = function() {
                            if (void 0 !== this.firstConnection) return this.firstConnection.getServerState();
                        }, t.prototype.getState = function() {
                            return this.fsm.getState();
                        }, t.prototype.startFirstConnection = function() {
                            this.firstConnection = new a.TrouterConnection(this.logFunc, this.options, this, this.tokenProvider), this.firstConnection.start();
                        }, t.prototype.startSecondConnection = function() {
                            var t = void 0 !== this.firstConnection ? this.firstConnection.getUserActivityState() : s.UserActivityState.Unknown;
                            this.secondConnection = new a.TrouterConnection(this.logFunc, this.options, this, this.tokenProvider, t), this.secondConnection.start();
                        }, t.prototype.stopFirstConnection = function(t) {
                            void 0 !== this.firstConnection && (this.firstConnection.stop(t), this.storedFirstConnection = this.firstConnection, this.firstConnection = void 0);
                        }, t.prototype.stopSecondConnection = function(t) {
                            void 0 !== this.secondConnection && (this.secondConnection.stop(t), this.secondConnection = void 0);
                        }, t.prototype.stopSecondConnectionDelayed = function() {
                            if (void 0 !== this.secondConnection) {
                                var t = this.secondConnection;
                                this.secondConnection = void 0, this.logger.info("Closing an inactive connection in " + Math.round(this.options.lingeringConnectionDelayMs / 1e3) + "s"), setTimeout(function() {
                                    t.stop(!0);
                                }, this.options.lingeringConnectionDelayMs);
                            }
                        }, t.prototype.switchConnections = function() {
                            var t = this.firstConnection;
                            this.firstConnection = this.secondConnection, this.secondConnection = t;
                        }, t.prototype.doesSecondConnectionExist = function() {
                            return void 0 !== this.secondConnection;
                        }, t.prototype.dispatchConnected = function() {
                            if (void 0 !== this.firstConnection) {
                                var t = this.firstConnection.getServerState(), e = "/" === t.url.slice(-1) ? t.url.slice(0, -1) : t.url, n = {
                                    baseEndpointUrl: e,
                                    newEndpointUrl: e !== this.baseEndpointUrl,
                                    c2cUrlBase: t.c2cUrlBase,
                                    clientId: t.connectedClientId,
                                    connectionId: t.connectionId,
                                    connectionTtlSec: t.getRemainingTtlInSec()
                                };
                                this.baseEndpointUrl = e, this.listener.onTrouterConnected(t.url, n);
                            }
                        }, t.prototype.dispatchReconnecting = function() {
                            this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();
                        }, t.prototype.dispatchStopped = function() {
                            this.listener.onTrouterDisconnected && this.listener.onTrouterDisconnected();
                        }, t.prototype.onDownstreamRequest = function(t, e, n) {
                            var o = {
                                id: e.id,
                                method: e.method,
                                path: "/" + e.shortUrl,
                                body: e.body,
                                headers: e.headers
                            }, r = {
                                id: e.id,
                                status: 0,
                                headers: {},
                                body: "",
                                send: function() {
                                    return r.status <= 100 || r.status >= 999 ? 3 : (n.writeHead(r.status, r.headers), n.end(r.body));
                                }
                            };
                            this.listener.onTrouterRequest(o, r);
                        }, t.prototype.onConnected = function(t) {
                            this.fsm.onConnected(t === this.firstConnection);
                        }, t.prototype.onRegistered = function(t) {
                            this.fsm.onRegistered(t === this.firstConnection);
                        }, t.prototype.onReconnecting = function(t) {
                            this.fsm.onReconnecting(t === this.firstConnection);
                        }, t.prototype.onReconnectIsRequired = function(t) {
                            this.fsm.onReconnectionRequired(t === this.firstConnection);
                        }, t.prototype.onDisconnected = function(t) {
                            this.fsm.onDisconnected(t === this.storedFirstConnection);
                        }, t.prototype.setUserActivityState = function(t) {
                            if (void 0 !== this.secondConnection) return this.logger.info("Setting user activity state " + s.UserActivityState[t] + " on the second/new connection"), void this.secondConnection.setUserActivityState(t);
                            if (void 0 !== this.firstConnection) return this.logger.info("Setting user activity state " + s.UserActivityState[t] + " on the first/current connection"), void this.firstConnection.setUserActivityState(t);
                            throw new Error("setUserActivityState called too early");
                        }, t.prototype.onTrouterMessageLost = function(t) {
                            var e = this;
                            if (this.listener.onTrouterMessageLoss) {
                                if (t && t.length) {
                                    var n = t.filter(function(t) {
                                        return void 0 !== e.processedMessageLoss[t.tag + "-" + t.etag];
                                    });
                                    if (n.length && (this.logger.warn("onTrouterMessageLoss - removing duplicates and sending event to server"), this.sendProcessedDroppedIndicators(n), t = t.filter(function(t) {
                                        return void 0 === e.processedMessageLoss[t.tag + "-" + t.etag];
                                    }), !t.length)) return void this.logger.warn("onTrouterMessageLoss - All the data are duplicated");
                                    var o = this.listener.onTrouterMessageLoss(t.map(function(t) {
                                        return t.tag;
                                    }));
                                    if (!o) return void this.logger.warn("onTrouterMessageLoss - flow tags have not been processed by listeners");
                                    t.forEach(function(t) {
                                        e.processedMessageLoss[t.tag + "-" + t.etag] = "";
                                    }), this.sendProcessedDroppedIndicators(t);
                                } else this.logger.warn("onTrouterMessageLoss - no flow tags have been provided");
                            }
                        }, t.prototype.sendProcessedDroppedIndicators = function(t) {
                            return void 0 !== this.firstConnection ? void this.firstConnection.sendProcessedDroppedIndicators(t) : void 0 !== this.secondConnection ? void this.secondConnection.sendProcessedDroppedIndicators(t) : void 0;
                        }, t;
                    }();
                    e.TrouterManager = h;
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = function() {
                        function t(t) {
                            this.logger = t;
                        }
                        return t.prototype.getPromise = function() {
                            var t = this;
                            return void 0 !== this.url ? (this.logger.debug("[TrouterUrlPromise] returning previously resolved url: " + this.url), Promise.resolve(this.url)) : (void 0 === this.pendingPromise ? (this.logger.debug("[TrouterUrlPromise] creating and returning promise"), this.pendingPromise = new Promise(function(e, n) {
                                t.pendingPromiseResolveRef = e, t.pendingPromiseRejectRef = n;
                            })) : this.logger.debug("[TrouterUrlPromise] returning existing promise"), this.pendingPromise);
                        }, t.prototype.resolveUrl = function(t) {
                            this.url = t, this.logger.debug("[TrouterUrlPromise] got url: " + this.url);
                            var e = this.pendingPromiseResolveRef;
                            this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e && (this.logger.debug("[TrouterUrlPromise] resolving promise"), e(t));
                        }, t.prototype.rejectUrl = function(t) {
                            this.logger.debug("[TrouterUrlPromise] aborting");
                            var e = this.pendingPromiseRejectRef;
                            this.url = void 0, this.pendingPromise = void 0, this.pendingPromiseResolveRef = void 0, this.pendingPromiseRejectRef = void 0, void 0 !== e && (this.logger.debug("[TrouterUrlPromise] rejecting promise"), e(t));
                        }, t.prototype.resetUrl = function() {
                            this.logger.debug("[TrouterUrlPromise] resetting url"), this.url = void 0;
                        }, t;
                    }();
                    e.TrouterUrlPromise = o;
                },
                function(module1, exports, __webpack_require__) {
                    (function(global, module1) {
                        !function(t, e) {
                            var n = t;
                            n.version = "0.9.6", n.protocol = 1, n.transports = [], n.j = [], n.sockets = {}, n.connect = function(t, o) {
                                var r, i, s = n.util.parseUri(t);
                                e && e.location && (s.protocol = s.protocol || e.location.protocol.slice(0, -1), s.host = s.host || (e.document ? e.document.domain : e.location.hostname), s.port = s.port || e.location.port), r = n.util.uniqueUri(s);
                                var c = {
                                    host: s.host,
                                    secure: "https" == s.protocol,
                                    port: s.port || ("https" == s.protocol ? 443 : 80),
                                    query: s.query || ""
                                };
                                return n.util.merge(c, o), !c["force new connection"] && n.sockets[r] || (i = new n.Socket(c)), !c["force new connection"] && i && (n.sockets[r] = i), i = i || n.sockets[r], i.of(s.path.length > 1 ? s.path : "");
                            };
                        }(module1.exports, void 0 === global ? window : global);
                        var io = module1.exports;
                        !function(t, e) {
                            var n = t.util = {}, o = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, r = [
                                "source",
                                "protocol",
                                "authority",
                                "userInfo",
                                "user",
                                "password",
                                "host",
                                "port",
                                "relative",
                                "path",
                                "directory",
                                "file",
                                "query",
                                "anchor"
                            ];
                            n.parseUri = function(t) {
                                for(var e = o.exec(t || ""), n = {}, i = 14; i--;)n[r[i]] = e[i] || "";
                                return n;
                            }, n.uniqueUri = function(t) {
                                var n = t.protocol, o = t.host, r = t.port;
                                return "document" in e ? (o = o || document.domain, r = r || ("https" == n && "https:" !== document.location.protocol ? 443 : document.location.port)) : (o = o || "localhost", r || "https" != n || (r = 443)), (n || "http") + "://" + o + ":" + (r || 80);
                            }, n.query = function(t, e) {
                                var o = n.chunkQuery(t || ""), r = [];
                                n.merge(o, n.chunkQuery(e || ""));
                                for(var i in o)o.hasOwnProperty(i) && r.push(i + "=" + o[i]);
                                return r.length ? "?" + r.join("&") : "";
                            }, n.chunkQuery = function(t) {
                                for(var e, n = {}, o = t.split("&"), r = 0, i = o.length; r < i; ++r)e = o[r].split("="), e[0] && (n[e[0]] = e[1]);
                                return n;
                            };
                            var i = !1;
                            n.load = function(t) {
                                if ("document" in e && "complete" === document.readyState || i) return t();
                                n.on(e, "load", t, !1);
                            }, n.on = function(t, e, n, o) {
                                t.attachEvent ? t.attachEvent("on" + e, n) : t.addEventListener && t.addEventListener(e, n, o);
                            }, n.request = function(t) {
                                if (t && "undefined" != typeof XDomainRequest) return new XDomainRequest;
                                if ("undefined" != typeof XMLHttpRequest && (!t || n.ua.hasCORS)) return new XMLHttpRequest;
                                if (!t) try {
                                    return new window[[
                                        "Active"
                                    ].concat("Object").join("X")]("Microsoft.XMLHTTP");
                                } catch (t) {}
                                return null;
                            }, "undefined" != typeof window && n.load(function() {
                                i = !0;
                            }), n.defer = function(t) {
                                if (!n.ua.webkit || "undefined" != typeof importScripts) return t();
                                n.load(function() {
                                    setTimeout(t, 100);
                                });
                            }, n.merge = function(t, e, o, r) {
                                var i, s = r || [], c = void 0 === o ? 2 : o;
                                for(i in e)e.hasOwnProperty(i) && n.indexOf(s, i) < 0 && ("object" == typeof t[i] && c ? n.merge(t[i], e[i], c - 1, s) : (t[i] = e[i], s.push(e[i])));
                                return t;
                            }, n.mixin = function(t, e) {
                                n.merge(t.prototype, e.prototype);
                            }, n.inherit = function(t, e) {
                                function n() {}
                                n.prototype = e.prototype, t.prototype = new n;
                            }, n.isArray = Array.isArray || function(t) {
                                return "[object Array]" === Object.prototype.toString.call(t);
                            }, n.intersect = function(t, e) {
                                for(var o = [], r = t.length > e.length ? t : e, i = t.length > e.length ? e : t, s = 0, c = i.length; s < c; s++)~n.indexOf(r, i[s]) && o.push(i[s]);
                                return o;
                            }, n.indexOf = function(t, e, n) {
                                for(var o = t.length, n = n < 0 ? n + o < 0 ? 0 : n + o : n || 0; n < o && t[n] !== e; n++);
                                return o <= n ? -1 : n;
                            }, n.toArray = function(t) {
                                for(var e = [], n = 0, o = t.length; n < o; n++)e.push(t[n]);
                                return e;
                            }, n.ua = {}, n.ua.hasCORS = "undefined" != typeof XMLHttpRequest && function() {
                                try {
                                    var t = new XMLHttpRequest;
                                } catch (t) {
                                    return !1;
                                }
                                return void 0 != t.withCredentials;
                            }(), n.ua.webkit = "undefined" != typeof navigator && /webkit/i.test(navigator.userAgent);
                        }(void 0 !== io ? io : module1.exports, void 0 === global ? window : global), function(t, e) {
                            function n() {}
                            t.EventEmitter = n, n.prototype.on = function(t, n) {
                                return this.$events || (this.$events = {}), this.$events[t] ? e.util.isArray(this.$events[t]) ? this.$events[t].push(n) : this.$events[t] = [
                                    this.$events[t],
                                    n
                                ] : this.$events[t] = n, this;
                            }, n.prototype.addListener = n.prototype.on, n.prototype.once = function(t, e) {
                                function n() {
                                    o.removeListener(t, n), e.apply(this, arguments);
                                }
                                var o = this;
                                return n.listener = e, this.on(t, n), this;
                            }, n.prototype.removeListener = function(t, n) {
                                if (this.$events && this.$events[t]) {
                                    var o = this.$events[t];
                                    if (e.util.isArray(o)) {
                                        for(var r = -1, i = 0, s = o.length; i < s; i++)if (o[i] === n || o[i].listener && o[i].listener === n) {
                                            r = i;
                                            break;
                                        }
                                        if (r < 0) return this;
                                        o.splice(r, 1), o.length || delete this.$events[t];
                                    } else (o === n || o.listener && o.listener === n) && delete this.$events[t];
                                }
                                return this;
                            }, n.prototype.removeAllListeners = function(t) {
                                return this.$events && this.$events[t] && (this.$events[t] = null), this;
                            }, n.prototype.listeners = function(t) {
                                return this.$events || (this.$events = {}), this.$events[t] || (this.$events[t] = []), e.util.isArray(this.$events[t]) || (this.$events[t] = [
                                    this.$events[t]
                                ]), this.$events[t];
                            }, n.prototype.emit = function(t) {
                                if (!this.$events) return !1;
                                var n = this.$events[t];
                                if (!n) return !1;
                                var o = Array.prototype.slice.call(arguments, 1);
                                if ("function" == typeof n) n.apply(this, o);
                                else {
                                    if (!e.util.isArray(n)) return !1;
                                    for(var r = n.slice(), i = 0, s = r.length; i < s; i++)r[i].apply(this, o);
                                }
                                return !0;
                            };
                        }(void 0 !== io ? io : module1.exports, void 0 !== io ? io : module1.parent.exports), function(exports, nativeJSON) {
                            function f(t) {
                                return t < 10 ? "0" + t : t;
                            }
                            function date(t, e) {
                                return isFinite(t.valueOf()) ? t.getUTCFullYear() + "-" + f(t.getUTCMonth() + 1) + "-" + f(t.getUTCDate()) + "T" + f(t.getUTCHours()) + ":" + f(t.getUTCMinutes()) + ":" + f(t.getUTCSeconds()) + "Z" : null;
                            }
                            function quote(t) {
                                return escapable.lastIndex = 0, escapable.test(t) ? '"' + t.replace(escapable, function(t) {
                                    var e = meta[t];
                                    return "string" == typeof e ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
                                }) + '"' : '"' + t + '"';
                            }
                            function str(t, e) {
                                var n, o, r, i, s, c = gap, a = e[t];
                                switch(a instanceof Date && (a = date(t)), "function" == typeof rep && (a = rep.call(e, t, a)), typeof a){
                                    case "string":
                                        return quote(a);
                                    case "number":
                                        return isFinite(a) ? String(a) : "null";
                                    case "boolean":
                                    case "null":
                                        return String(a);
                                    case "object":
                                        if (!a) return "null";
                                        if (gap += indent, s = [], "[object Array]" === Object.prototype.toString.apply(a)) {
                                            for(i = a.length, n = 0; n < i; n += 1)s[n] = str(n, a) || "null";
                                            return r = 0 === s.length ? "[]" : gap ? "[\n" + gap + s.join(",\n" + gap) + "\n" + c + "]" : "[" + s.join(",") + "]", gap = c, r;
                                        }
                                        if (rep && "object" == typeof rep) for(i = rep.length, n = 0; n < i; n += 1)"string" == typeof rep[n] && (o = rep[n], (r = str(o, a)) && s.push(quote(o) + (gap ? ": " : ":") + r));
                                        else for(o in a)Object.prototype.hasOwnProperty.call(a, o) && (r = str(o, a)) && s.push(quote(o) + (gap ? ": " : ":") + r);
                                        return r = 0 === s.length ? "{}" : gap ? "{\n" + gap + s.join(",\n" + gap) + "\n" + c + "}" : "{" + s.join(",") + "}", gap = c, r;
                                }
                            }
                            if (nativeJSON && nativeJSON.parse) return exports.JSON = {
                                parse: nativeJSON.parse,
                                stringify: nativeJSON.stringify
                            };
                            var JSON1 = exports.JSON = {}, cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
                                "\b": "\\b",
                                "\t": "\\t",
                                "\n": "\\n",
                                "\f": "\\f",
                                "\r": "\\r",
                                '"': '\\"',
                                "\\": "\\\\"
                            }, rep;
                            JSON1.stringify = function(t, e, n) {
                                var o;
                                if (gap = "", indent = "", "number" == typeof n) for(o = 0; o < n; o += 1)indent += " ";
                                else "string" == typeof n && (indent = n);
                                if (rep = e, e && "function" != typeof e && ("object" != typeof e || "number" != typeof e.length)) throw new Error("JSON.stringify");
                                return str("", {
                                    "": t
                                });
                            }, JSON1.parse = function(text, reviver) {
                                function walk(t, e) {
                                    var n, o, r = t[e];
                                    if (r && "object" == typeof r) for(n in r)Object.prototype.hasOwnProperty.call(r, n) && (o = walk(r, n), void 0 !== o ? r[n] = o : delete r[n]);
                                    return reviver.call(t, e, r);
                                }
                                var j;
                                if (text = String(text), cx.lastIndex = 0, cx.test(text) && (text = text.replace(cx, function(t) {
                                    return "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
                                })), /^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, ""))) return j = eval("(" + text + ")"), "function" == typeof reviver ? walk({
                                    "": j
                                }, "") : j;
                                throw new SyntaxError("JSON.parse");
                            };
                        }(void 0 !== io ? io : module1.exports, "undefined" != typeof JSON ? JSON : void 0), function(t, e) {
                            var n = t.parser = {}, o = n.packets = [
                                "disconnect",
                                "connect",
                                "heartbeat",
                                "message",
                                "json",
                                "event",
                                "ack",
                                "error",
                                "noop"
                            ], r = n.reasons = [
                                "transport not supported",
                                "client not handshaken",
                                "unauthorized"
                            ], i = n.advice = [
                                "reconnect"
                            ], s = e.JSON, c = e.util.indexOf;
                            n.encodePacket = function(t) {
                                var e = c(o, t.type), n = t.id || "", a = t.endpoint || "", u = t.ack, h = null;
                                switch(t.type){
                                    case "error":
                                        var l = t.reason ? c(r, t.reason) : "", p = t.advice ? c(i, t.advice) : "";
                                        "" === l && "" === p || (h = l + ("" !== p ? "+" + p : ""));
                                        break;
                                    case "message":
                                        "" !== t.data && (h = t.data);
                                        break;
                                    case "event":
                                        var d = {
                                            name: t.name
                                        };
                                        t.args && t.args.length && (d.args = t.args), h = s.stringify(d);
                                        break;
                                    case "json":
                                        h = s.stringify(t.data);
                                        break;
                                    case "connect":
                                        t.qs && (h = t.qs);
                                        break;
                                    case "ack":
                                        h = t.ackId + (t.args && t.args.length ? "+" + s.stringify(t.args) : "");
                                }
                                var f = [
                                    e,
                                    n + ("data" == u ? "+" : ""),
                                    a
                                ];
                                return null !== h && void 0 !== h && f.push(h), f.join(":");
                            }, n.encodePayload = function(t) {
                                var e = "";
                                if (1 == t.length) return t[0];
                                for(var n = 0, o = t.length; n < o; n++)e += "\uFFFD" + t[n].length + "\uFFFD" + t[n];
                                return e;
                            };
                            var a = /([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/;
                            n.decodePacket = function(t) {
                                var e = t.match(a);
                                if (!e) return {};
                                var n = e[2] || "", t = e[5] || "", c = {
                                    type: o[e[1]],
                                    endpoint: e[4] || ""
                                };
                                switch(n && (c.id = n, e[3] ? c.ack = "data" : c.ack = !0), c.type){
                                    case "error":
                                        var e = t.split("+");
                                        c.reason = r[e[0]] || "", c.advice = i[e[1]] || "";
                                        break;
                                    case "message":
                                        c.data = t || "";
                                        break;
                                    case "event":
                                        try {
                                            var u = s.parse(t);
                                            c.name = u.name, c.args = u.args;
                                        } catch (t) {}
                                        c.args = c.args || [];
                                        break;
                                    case "json":
                                        try {
                                            c.data = s.parse(t);
                                        } catch (t) {}
                                        break;
                                    case "connect":
                                        c.qs = t || "";
                                        break;
                                    case "ack":
                                        var e = t.match(/^([0-9]+)(\+)?(.*)/);
                                        if (e && (c.ackId = e[1], c.args = [], e[3])) try {
                                            c.args = e[3] ? s.parse(e[3]) : [];
                                        } catch (t) {}
                                }
                                return c;
                            }, n.decodePayload = function(t) {
                                if ("\uFFFD" == t.charAt(0)) {
                                    for(var e = [], o = 1, r = ""; o < t.length; o++)"\uFFFD" == t.charAt(o) ? (e.push(n.decodePacket(t.substr(o + 1).substr(0, r))), o += Number(r) + 1, r = "") : r += t.charAt(o);
                                    return e;
                                }
                                return [
                                    n.decodePacket(t)
                                ];
                            };
                        }(void 0 !== io ? io : module1.exports, void 0 !== io ? io : module1.parent.exports), function(t, e) {
                            function n(t, e) {
                                this.socket = t, this.sessid = e, this.connectErrorCallback = void 0, this.isOpened = !1;
                            }
                            t.Transport = n, e.util.mixin(n, e.EventEmitter), n.prototype.onData = function(t) {
                                if (this.clearCloseTimeout(), (this.socket.connected || this.socket.connecting || this.socket.reconnecting) && this.setCloseTimeout(), "" !== t) {
                                    var n = e.parser.decodePayload(t);
                                    if (n && n.length) for(var o = 0, r = n.length; o < r; o++)this.onPacket(n[o]);
                                }
                                return this;
                            }, n.prototype.onPacket = function(t) {
                                return this.socket.setHeartbeatTimeout(), "heartbeat" == t.type ? this.onHeartbeat() : ("connect" == t.type && "" == t.endpoint && this.onConnect(), "error" == t.type && "reconnect" == t.advice && (this.isOpened = !1), this.socket.onPacket(t), this);
                            }, n.prototype.setCloseTimeout = function() {
                                if (!this.closeTimeout) {
                                    var t = this;
                                    this.closeTimeout = setTimeout(function() {
                                        t.onDisconnect();
                                    }, this.socket.closeTimeout);
                                }
                            }, n.prototype.onDisconnect = function() {
                                return this.close && this.isOpened && this.close(), this.clearTimeouts(), this.socket.onDisconnect(), this;
                            }, n.prototype.onConnect = function() {
                                return this.socket.onConnect(), this.connectErrorCallback = void 0, this;
                            }, n.prototype.clearCloseTimeout = function() {
                                this.closeTimeout && (clearTimeout(this.closeTimeout), this.closeTimeout = null);
                            }, n.prototype.clearTimeouts = function() {
                                this.clearCloseTimeout(), this.reopenTimeout && clearTimeout(this.reopenTimeout);
                            }, n.prototype.packet = function(t) {
                                this.send(e.parser.encodePacket(t));
                            }, n.prototype.onHeartbeat = function(t) {
                                this.packet({
                                    type: "heartbeat"
                                });
                            }, n.prototype.onOpen = function() {
                                this.isOpened = !0, this.clearCloseTimeout(), this.socket.onOpen();
                            }, n.prototype.onClose = function() {
                                this.isOpened = !1, this.socket.onClose(), this.onDisconnect();
                            }, n.prototype.prepareUrl = function() {
                                var t = this.socket.options;
                                return this.scheme() + "://" + t.host + ":" + t.port + "/" + t.resource + "/" + e.protocol + "/" + this.name + "/" + this.sessid;
                            }, n.prototype.ready = function(t, e) {
                                e.call(this);
                            }, n.prototype.clearEventHandlers = function() {
                                return this;
                            };
                        }(void 0 !== io ? io : module1.exports, void 0 !== io ? io : module1.parent.exports), function(t, e, n) {
                            function o(t) {
                                if (this.options = {
                                    port: 80,
                                    secure: !1,
                                    document: "document" in n && document,
                                    resource: "socket.io",
                                    transports: e.transports.slice(),
                                    "connect timeout": 1e4,
                                    "try multiple transports": !0,
                                    reconnect: !0,
                                    "reconnection delay": 500,
                                    "reconnection limit": 1 / 0,
                                    "reopen delay": 3e3,
                                    "max reconnection attempts": 10,
                                    "sync disconnect on unload": !0,
                                    "auto connect": !0,
                                    "flash policy port": 10843
                                }, e.util.merge(this.options, t), this.connected = !1, this.open = !1, this.connecting = !1, this.reconnecting = !1, this.namespaces = {}, this.buffer = [], this.doBuffer = !1, this.options["sync disconnect on unload"] && (!this.isXDomain() || e.util.ua.hasCORS)) {
                                    var o = this;
                                    e.util.on(n, "unload", function() {
                                        o.disconnectSync();
                                    }, !1);
                                }
                                this.options["auto connect"] && this.connect();
                            }
                            function r() {}
                            t.Socket = o, e.util.mixin(o, e.EventEmitter), o.prototype.of = function(t) {
                                return this.namespaces[t] || (this.namespaces[t] = new e.SocketNamespace(this, t), "" !== t && this.namespaces[t].packet({
                                    type: "connect"
                                })), this.namespaces[t];
                            }, o.prototype.publish = function() {
                                this.emit.apply(this, arguments);
                                var t;
                                for(var e in this.namespaces)this.namespaces.hasOwnProperty(e) && (t = this.of(e), t.$emit.apply(t, arguments));
                            }, o.prototype.handshake = function(t) {
                                function n(e) {
                                    e instanceof Error ? o.onError(e.message) : t.apply(null, e.split(":"));
                                }
                                var o = this, i = this.options, s = [
                                    "http" + (i.secure ? "s" : "") + ":/",
                                    i.host + ":" + i.port,
                                    i.resource,
                                    e.protocol,
                                    e.util.query(this.options.query, "t=" + +new Date)
                                ].join("/");
                                if (this.isXDomain() && !e.util.ua.hasCORS) {
                                    var c = document.getElementsByTagName("script")[0], a = document.createElement("script");
                                    a.src = s + "&jsonp=" + e.j.length, c.parentNode.insertBefore(a, c), e.j.push(function(t) {
                                        n(t), a.parentNode.removeChild(a);
                                    });
                                } else {
                                    var u = e.util.request();
                                    u.open("GET", s, !0), u.withCredentials = !0, u.onreadystatechange = function() {
                                        4 == u.readyState && (u.onreadystatechange = r, 200 == u.status ? n(u.responseText) : !o.reconnecting && o.onError(u.responseText));
                                    }, u.send(null);
                                }
                            }, o.prototype.getTransport = function(t) {
                                for(var n, o = t || this.transports, r = 0; n = o[r]; r++)if (e.Transport[n] && e.Transport[n].check(this) && (!this.isXDomain() || e.Transport[n].xdomainCheck())) return new e.Transport[n](this, this.sessionid);
                                return null;
                            }, o.prototype.connect = function(t) {
                                if (this.connecting) return this;
                                var n = this;
                                return this.handshake(function(o, r, i, s) {
                                    function c() {
                                        if (!n.connected) {
                                            if (n.connecting = !1, clearTimeout(n.connectTimeoutTimer), n.options["try multiple transports"]) {
                                                for(; n.remainingTransports.length > 0 && n.remainingTransports.splice(0, 1)[0] != n.transport.name;);
                                                n.remainingTransports.length ? a(n.remainingTransports) : n.publish("connect_failed");
                                            } else n.publish("connect_failed");
                                        }
                                    }
                                    function a(t) {
                                        if (n.transport && (n.transport.clearTimeouts(), n.transport.clearEventHandlers()), n.transport = n.getTransport(t), !n.transport) return n.publish("connect_failed");
                                        n.transport.ready(n, function() {
                                            n.connecting = !0, n.publish("connecting", n.transport.name), n.transport.open(c), n.options["connect timeout"] && (n.connectTimeoutTimer = setTimeout(function() {
                                                c();
                                            }, n.options["connect timeout"]));
                                        });
                                    }
                                    n.sessionid = o, n.closeTimeout = 1e3 * i + 2e3, n.heartbeatTimeout = 1e3 * r + 2e3, n.transports = s ? e.util.intersect(s.split(","), n.options.transports) : n.options.transports, n.setHeartbeatTimeout(), n.remainingTransports = n.transports.slice(0), a(n.transports), n.once("connect", function() {
                                        clearTimeout(n.connectTimeoutTimer), t && "function" == typeof t && t();
                                    });
                                }), this;
                            }, o.prototype.setHeartbeatTimeout = function() {
                                clearTimeout(this.heartbeatTimeoutTimer);
                                var t = this;
                                this.heartbeatTimeoutTimer = setTimeout(function() {
                                    t.transport.onClose();
                                }, this.heartbeatTimeout);
                            }, o.prototype.packet = function(t) {
                                return this.connected && !this.doBuffer ? this.transport.packet(t) : this.buffer.push(t), this;
                            }, o.prototype.setBuffer = function(t) {
                                this.doBuffer = t, !t && this.connected && this.buffer.length && (this.transport.payload(this.buffer), this.buffer = []);
                            }, o.prototype.disconnect = function() {
                                return (this.connected || this.connecting) && (this.open && this.of("").packet({
                                    type: "disconnect"
                                }), this.onDisconnect("booted")), this;
                            }, o.prototype.disconnectSync = function() {
                                var t = e.util.request(), n = this.resource + "/" + e.protocol + "/" + this.sessionid;
                                t.open("GET", n, !0), this.onDisconnect("booted");
                            }, o.prototype.isXDomain = function() {
                                var t = n.location.port || ("https:" == n.location.protocol ? 443 : 80);
                                return this.options.host !== n.location.hostname || this.options.port != t;
                            }, o.prototype.onConnect = function() {
                                this.connected || (this.connected = !0, this.connecting = !1, this.doBuffer || this.setBuffer(!1), this.emit("connect"));
                            }, o.prototype.onOpen = function() {
                                this.open = !0;
                            }, o.prototype.onClose = function() {
                                this.open = !1, clearTimeout(this.heartbeatTimeoutTimer);
                            }, o.prototype.onPacket = function(t) {
                                this.of(t.endpoint).onPacket(t);
                            }, o.prototype.onError = function(t) {
                                t && t.advice && "reconnect" === t.advice && (this.connected || this.connecting) && (this.disconnect(), this.options.reconnect && this.reconnect()), this.publish("error", t && t.reason ? t.reason : t);
                            }, o.prototype.onDisconnect = function(t) {
                                var e = this.connected, n = this.connecting;
                                this.connected = !1, this.connecting = !1, this.open = !1, (e || n) && (this.transport.close(), this.transport.clearTimeouts(), e && (this.publish("disconnect", t), "booted" != t && this.options.reconnect && !this.reconnecting && this.reconnect()));
                            }, o.prototype.reconnect = function() {
                                function t() {
                                    if (n.connected) {
                                        for(var t in n.namespaces)n.namespaces.hasOwnProperty(t) && "" !== t && n.namespaces[t].packet({
                                            type: "connect"
                                        });
                                        n.publish("reconnect", n.transport.name, n.reconnectionAttempts);
                                    }
                                    clearTimeout(n.reconnectionTimer), n.removeListener("connect_failed", e), n.removeListener("connect", e), n.reconnecting = !1, delete n.reconnectionAttempts, delete n.reconnectionDelay, delete n.reconnectionTimer, delete n.redoTransports, n.options["try multiple transports"] = r;
                                }
                                function e() {
                                    if (n.reconnecting) return n.connected ? t() : n.connecting && n.reconnecting ? n.reconnectionTimer = setTimeout(e, 1e3) : void (n.reconnectionAttempts++ >= o ? n.redoTransports ? (n.publish("reconnect_failed"), t()) : (n.on("connect_failed", e), n.options["try multiple transports"] = !0, n.transport = n.getTransport(), n.redoTransports = !0, n.connect()) : (n.reconnectionDelay < i && (n.reconnectionDelay *= 2), n.connect(), n.publish("reconnecting", n.reconnectionDelay, n.reconnectionAttempts), n.reconnectionTimer = setTimeout(e, n.reconnectionDelay)));
                                }
                                this.reconnecting = !0, this.reconnectionAttempts = 0, this.reconnectionDelay = this.options["reconnection delay"];
                                var n = this, o = this.options["max reconnection attempts"], r = this.options["try multiple transports"], i = this.options["reconnection limit"];
                                this.options["try multiple transports"] = !1, this.reconnectionTimer = setTimeout(e, this.reconnectionDelay), this.on("connect", e);
                            };
                        }(void 0 !== io ? io : module1.exports, void 0 !== io ? io : module1.parent.exports, void 0 === global ? window : global), function(t, e) {
                            function n(t, e) {
                                this.socket = t, this.name = e || "", this.flags = {}, this.json = new o(this, "json"), this.ackPackets = 0, this.acks = {};
                            }
                            function o(t, e) {
                                this.namespace = t, this.name = e;
                            }
                            t.SocketNamespace = n, e.util.mixin(n, e.EventEmitter), n.prototype.$emit = e.EventEmitter.prototype.emit, n.prototype.of = function() {
                                return this.socket.of.apply(this.socket, arguments);
                            }, n.prototype.packet = function(t) {
                                return t.endpoint = this.name, this.socket.packet(t), this.flags = {}, this;
                            }, n.prototype.send = function(t, e) {
                                var n = {
                                    type: this.flags.json ? "json" : "message",
                                    data: t
                                };
                                return "function" == typeof e && (n.id = ++this.ackPackets, n.ack = !0, this.acks[n.id] = e), this.packet(n);
                            }, n.prototype.emit = function(t) {
                                var e = Array.prototype.slice.call(arguments, 1), n = e[e.length - 1], o = {
                                    type: "event",
                                    name: t
                                };
                                return "function" == typeof n && (o.id = ++this.ackPackets, o.ack = "data", this.acks[o.id] = n, e = e.slice(0, e.length - 1)), o.args = e, this.packet(o);
                            }, n.prototype.disconnect = function() {
                                return "" === this.name ? this.socket.disconnect() : (this.packet({
                                    type: "disconnect"
                                }), this.$emit("disconnect")), this;
                            }, n.prototype.onPacket = function(t) {
                                function n() {
                                    o.packet({
                                        type: "ack",
                                        args: e.util.toArray(arguments),
                                        ackId: t.id
                                    });
                                }
                                var o = this;
                                switch(t.type){
                                    case "connect":
                                        this.$emit("connect");
                                        break;
                                    case "disconnect":
                                        "" === this.name ? this.socket.onDisconnect(t.reason || "booted") : this.$emit("disconnect", t.reason);
                                        break;
                                    case "message":
                                    case "json":
                                        var r = [
                                            "message",
                                            t.data
                                        ];
                                        "data" == t.ack ? r.push(n) : t.ack && this.packet({
                                            type: "ack",
                                            ackId: t.id
                                        }), this.$emit.apply(this, r);
                                        break;
                                    case "event":
                                        var r = [
                                            t.name
                                        ].concat(t.args);
                                        "data" == t.ack && r.push(n), this.$emit.apply(this, r);
                                        break;
                                    case "ack":
                                        this.acks[t.ackId] && (this.acks[t.ackId].apply(this, t.args), delete this.acks[t.ackId]);
                                        break;
                                    case "error":
                                        t.advice ? this.socket.onError(t) : "unauthorized" == t.reason ? this.$emit("connect_failed", t.reason) : this.$emit("error", t.reason);
                                }
                            }, o.prototype.send = function() {
                                this.namespace.flags[this.name] = !0, this.namespace.send.apply(this.namespace, arguments);
                            }, o.prototype.emit = function() {
                                this.namespace.flags[this.name] = !0, this.namespace.emit.apply(this.namespace, arguments);
                            };
                        }(void 0 !== io ? io : module1.exports, void 0 !== io ? io : module1.parent.exports), function(t, e, n) {
                            function o(t) {
                                e.Transport.apply(this, arguments);
                            }
                            function r() {}
                            t.websocket = o, e.util.inherit(o, e.Transport), o.prototype.name = "websocket", o.prototype.open = function(t) {
                                var o, r = e.util.query(this.socket.options.query), i = this;
                                return this.connectErrorCallback = t, o || (o = n.MozWebSocket || n.WebSocket), this.websocket = new o(this.prepareUrl() + r), this.websocket.onopen = function() {
                                    i.onOpen(), i.socket.setBuffer(!1);
                                }, this.websocket.onmessage = function(t) {
                                    i.onData(t.data);
                                }, this.websocket.onclose = function() {
                                    i.onClose(), i.socket.setBuffer(!0);
                                }, this.websocket.onerror = function(t) {
                                    i.onError(t);
                                }, this;
                            }, o.prototype.send = function(t) {
                                return this.websocket.send(t), this;
                            }, o.prototype.payload = function(t) {
                                for(var e = 0, n = t.length; e < n; e++)this.packet(t[e]);
                                return this;
                            }, o.prototype.close = function() {
                                return this.websocket.close(), this;
                            }, o.prototype.onError = function(t) {
                                void 0 !== this.connectErrorCallback && (this.connectErrorCallback(), this.connectErrorCallback = void 0), this.socket.onError(t);
                            }, o.prototype.scheme = function() {
                                return this.socket.options.secure ? "wss" : "ws";
                            }, o.check = function() {
                                return "WebSocket" in n && !("__addTask" in WebSocket) || "MozWebSocket" in n;
                            }, o.xdomainCheck = function() {
                                return !0;
                            }, o.prototype.clearEventHandlers = function() {
                                return this.websocket && (this.websocket.onopen = this.websocket.onmessage = this.websocket.onclose = this.websocket.onerror = r), this;
                            }, e.transports.push("websocket");
                        }(void 0 !== io ? io.Transport : module1.exports, void 0 !== io ? io : module1.parent.exports, void 0 === global ? window : global), function(t, e, n) {
                            function o(t) {
                                t && (e.Transport.apply(this, arguments), this.sendBuffer = []);
                            }
                            function r() {}
                            t.XHR = o, e.util.inherit(o, e.Transport), o.prototype.open = function() {
                                return this.socket.setBuffer(!1), this.onOpen(), this.get(), this.setCloseTimeout(), this;
                            }, o.prototype.payload = function(t) {
                                for(var n = [], o = 0, r = t.length; o < r; o++)n.push(e.parser.encodePacket(t[o]));
                                this.send(e.parser.encodePayload(n));
                            }, o.prototype.send = function(t) {
                                return this.post(t), this;
                            }, o.prototype.post = function(t) {
                                function e() {
                                    4 == this.readyState && (this.onreadystatechange = r, i.posting = !1, 200 == this.status ? (i.socket.setBuffer(!1), clearTimeout(i.sendXHR.ackTimeoutTimer)) : i.onClose());
                                }
                                function o() {
                                    this.onload = r, i.socket.setBuffer(!1);
                                }
                                var i = this;
                                this.socket.setBuffer(!0), this.sendXHR = this.request("POST"), n.XDomainRequest && this.sendXHR instanceof XDomainRequest ? this.sendXHR.onload = this.sendXHR.onerror = o : this.sendXHR.onreadystatechange = e, this.sendXHR.send(t), i.sendXHR.ackTimeoutTimer = setTimeout(function() {
                                    i.onClose();
                                }, i.socket.options.ackTimeoutMs);
                            }, o.prototype.close = function() {
                                return this.onClose(), this;
                            }, o.prototype.request = function(t) {
                                var n = e.util.request(this.socket.isXDomain()), o = e.util.query(this.socket.options.query, "t=" + +new Date);
                                if (n.open(t || "GET", this.prepareUrl() + o, !0), "POST" == t) try {
                                    n.setRequestHeader ? n.setRequestHeader("Content-type", "text/plain;charset=UTF-8") : n.contentType = "text/plain";
                                } catch (t) {}
                                return n;
                            }, o.prototype.scheme = function() {
                                return this.socket.options.secure ? "https" : "http";
                            }, o.check = function(t, o) {
                                try {
                                    var r = e.util.request(o), i = n.XDomainRequest && r instanceof XDomainRequest, s = t && t.options && t.options.secure ? "https:" : "http:", c = s != n.location.protocol;
                                    if (r && (!i || !c)) return !0;
                                } catch (t) {}
                                return !1;
                            }, o.xdomainCheck = function() {
                                return o.check(null, !0);
                            }, o.prototype.clearEventHandlers = function() {
                                return this.sendXHR && (this.sendXHR.onreadystatechange = this.sendXHR.onload = r), this;
                            };
                        }(void 0 !== io ? io.Transport : module1.exports, void 0 !== io ? io : module1.parent.exports, void 0 === global ? window : global), function(t, e, n) {
                            function o() {
                                e.Transport.XHR.apply(this, arguments);
                            }
                            function r() {}
                            t["xhr-polling"] = o, e.util.inherit(o, e.Transport.XHR), e.util.merge(o, e.Transport.XHR), o.prototype.name = "xhr-polling", o.prototype.open = function(t) {
                                var n = this;
                                return n.connectErrorCallback = t, e.Transport.XHR.prototype.open.call(n), !1;
                            }, o.prototype.get = function() {
                                function t() {
                                    4 == this.readyState && (this.onreadystatechange = r, 200 == this.status ? (i.connectErrorCallback = void 0, i.onData(this.responseText), i.get()) : (i.onClose(), void 0 !== i.connectErrorCallback && (i.connectErrorCallback(), i.connectErrorCallback = void 0)));
                                }
                                function e() {
                                    i.connectErrorCallback = void 0, this.onload = r, this.onerror = r, i.onData(this.responseText), i.get();
                                }
                                function o() {
                                    i.onClose(), void 0 !== i.connectErrorCallback && (i.connectErrorCallback(), i.connectErrorCallback = void 0);
                                }
                                if (this.isOpened) {
                                    var i = this;
                                    this.xhr = this.request(), n.XDomainRequest && this.xhr instanceof XDomainRequest ? (this.xhr.onload = e, this.xhr.onerror = o) : this.xhr.onreadystatechange = t, this.xhr.send(null);
                                }
                            }, o.prototype.onClose = function() {
                                if (e.Transport.XHR.prototype.onClose.call(this), this.xhr) {
                                    this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = r;
                                    try {
                                        this.xhr.abort();
                                    } catch (t) {}
                                    this.xhr = null;
                                }
                            }, o.prototype.ready = function(t, n) {
                                var o = this;
                                e.util.defer(function() {
                                    n.call(o);
                                });
                            }, o.prototype.clearEventHandlers = function() {
                                return e.Transport.XHR.prototype.clearEventHandlers.call(this), this.xhr && (this.xhr.onreadystatechange = this.xhr.onload = this.xhr.onerror = r), this;
                            }, e.transports.push("xhr-polling");
                        }(void 0 !== io ? io.Transport : module1.exports, void 0 !== io ? io : module1.parent.exports, void 0 === global ? window : global), exports.io = io;
                    }).call(exports, __webpack_require__(4), __webpack_require__(13)(module1));
                },
                function(t, e, n) {
                    (function(e, o) {
                        !function(e, n) {
                            t.exports = n();
                        }(0, function() {
                            function t(t) {
                                return "function" == typeof t || "object" == typeof t && null !== t;
                            }
                            function r(t) {
                                return "function" == typeof t;
                            }
                            function i(t) {
                                $ = t;
                            }
                            function s(t) {
                                V = t;
                            }
                            function c() {
                                return void 0 !== X ? function() {
                                    X(u);
                                } : a();
                            }
                            function a() {
                                var t = setTimeout;
                                return function() {
                                    return t(u, 1);
                                };
                            }
                            function u() {
                                for(var t = 0; t < J; t += 2)(0, Y[t])(Y[t + 1]), Y[t] = void 0, Y[t + 1] = void 0;
                                J = 0;
                            }
                            function h(t, e) {
                                var n = arguments, o = this, r = new this.constructor(p);
                                void 0 === r[tt] && O(r);
                                var i = o._state;
                                return i ? function() {
                                    var t = n[i - 1];
                                    V(function() {
                                        return _(i, r, t, o._result);
                                    });
                                }() : C(o, r, t, e), r;
                            }
                            function l(t) {
                                var e = this;
                                if (t && "object" == typeof t && t.constructor === e) return t;
                                var n = new e(p);
                                return k(n, t), n;
                            }
                            function p() {}
                            function d() {
                                return new TypeError("You cannot resolve a promise with itself");
                            }
                            function f() {
                                return new TypeError("A promises callback cannot return that same promise.");
                            }
                            function g(t) {
                                try {
                                    return t.then;
                                } catch (t) {
                                    return rt.error = t, rt;
                                }
                            }
                            function m(t, e, n, o) {
                                try {
                                    t.call(e, n, o);
                                } catch (t) {
                                    return t;
                                }
                            }
                            function v(t, e, n) {
                                V(function(t) {
                                    var o = !1, r = m(n, e, function(n) {
                                        o || (o = !0, e !== n ? k(t, n) : w(t, n));
                                    }, function(e) {
                                        o || (o = !0, b(t, e));
                                    }, "Settle: " + (t._label || " unknown promise"));
                                    !o && r && (o = !0, b(t, r));
                                }, t);
                            }
                            function y(t, e) {
                                e._state === nt ? w(t, e._result) : e._state === ot ? b(t, e._result) : C(e, void 0, function(e) {
                                    return k(t, e);
                                }, function(e) {
                                    return b(t, e);
                                });
                            }
                            function T(t, e, n) {
                                e.constructor === t.constructor && n === h && e.constructor.resolve === l ? y(t, e) : n === rt ? b(t, rt.error) : void 0 === n ? w(t, e) : r(n) ? v(t, e, n) : w(t, e);
                            }
                            function k(e, n) {
                                e === n ? b(e, d()) : t(n) ? T(e, n, g(n)) : w(e, n);
                            }
                            function S(t) {
                                t._onerror && t._onerror(t._result), R(t);
                            }
                            function w(t, e) {
                                t._state === et && (t._result = e, t._state = nt, 0 !== t._subscribers.length && V(R, t));
                            }
                            function b(t, e) {
                                t._state === et && (t._state = ot, t._result = e, V(S, t));
                            }
                            function C(t, e, n, o) {
                                var r = t._subscribers, i = r.length;
                                t._onerror = null, r[i] = e, r[i + nt] = n, r[i + ot] = o, 0 === i && t._state && V(R, t);
                            }
                            function R(t) {
                                var e = t._subscribers, n = t._state;
                                if (0 !== e.length) {
                                    for(var o = void 0, r = void 0, i = t._result, s = 0; s < e.length; s += 3)o = e[s], r = e[s + n], o ? _(n, o, r, i) : r(i);
                                    t._subscribers.length = 0;
                                }
                            }
                            function I() {
                                this.error = null;
                            }
                            function E(t, e) {
                                try {
                                    return t(e);
                                } catch (t) {
                                    return it.error = t, it;
                                }
                            }
                            function _(t, e, n, o) {
                                var i = r(n), s = void 0, c = void 0, a = void 0, u = void 0;
                                if (i) {
                                    if (s = E(n, o), s === it ? (u = !0, c = s.error, s = null) : a = !0, e === s) return void b(e, f());
                                } else s = o, a = !0;
                                e._state !== et || (i && a ? k(e, s) : u ? b(e, c) : t === nt ? w(e, s) : t === ot && b(e, s));
                            }
                            function M(t, e) {
                                try {
                                    e(function(e) {
                                        k(t, e);
                                    }, function(e) {
                                        b(t, e);
                                    });
                                } catch (e) {
                                    b(t, e);
                                }
                            }
                            function P() {
                                return st++;
                            }
                            function O(t) {
                                t[tt] = st++, t._state = void 0, t._result = void 0, t._subscribers = [];
                            }
                            function U(t, e) {
                                this._instanceConstructor = t, this.promise = new t(p), this.promise[tt] || O(this.promise), F(e) ? (this._input = e, this.length = e.length, this._remaining = e.length, this._result = new Array(this.length), 0 === this.length ? w(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(), 0 === this._remaining && w(this.promise, this._result))) : b(this.promise, x());
                            }
                            function x() {
                                return new Error("Array Methods must be provided an Array");
                            }
                            function A(t) {
                                return new U(this, t).promise;
                            }
                            function D(t) {
                                var e = this;
                                return new e(F(t) ? function(n, o) {
                                    for(var r = t.length, i = 0; i < r; i++)e.resolve(t[i]).then(n, o);
                                } : function(t, e) {
                                    return e(new TypeError("You must pass an array to race."));
                                });
                            }
                            function L(t) {
                                var e = this, n = new e(p);
                                return b(n, t), n;
                            }
                            function j() {
                                throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                            }
                            function q() {
                                throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                            }
                            function N(t) {
                                this[tt] = P(), this._result = this._state = void 0, this._subscribers = [], p !== t && ("function" != typeof t && j(), this instanceof N ? M(this, t) : q());
                            }
                            function H() {
                                var t = void 0;
                                if (void 0 !== o) t = o;
                                else if ("undefined" != typeof self) t = self;
                                else try {
                                    t = Function("return this")();
                                } catch (t) {
                                    throw new Error("polyfill failed because global object is unavailable in this environment");
                                }
                                var e = t.Promise;
                                if (e) {
                                    var n = null;
                                    try {
                                        n = Object.prototype.toString.call(e.resolve());
                                    } catch (t) {}
                                    if ("[object Promise]" === n && !e.cast) return;
                                }
                                t.Promise = N;
                            }
                            var B = void 0;
                            B = Array.isArray ? Array.isArray : function(t) {
                                return "[object Array]" === Object.prototype.toString.call(t);
                            };
                            var F = B, J = 0, X = void 0, $ = void 0, V = function(t, e) {
                                Y[J] = t, Y[J + 1] = e, 2 === (J += 2) && ($ ? $(u) : Z());
                            }, G = "undefined" != typeof window ? window : void 0, K = G || {}, W = K.MutationObserver || K.WebKitMutationObserver, Q = "undefined" == typeof self && void 0 !== e && "[object process]" === ({}).toString.call(e), z = "undefined" != typeof Uint8ClampedArray && "undefined" != typeof importScripts && "undefined" != typeof MessageChannel, Y = new Array(1e3), Z = void 0;
                            Z = Q ? function() {
                                return function() {
                                    return e.nextTick(u);
                                };
                            }() : W ? function() {
                                var t = 0, e = new W(u), n = document.createTextNode("");
                                return e.observe(n, {
                                    characterData: !0
                                }), function() {
                                    n.data = t = ++t % 2;
                                };
                            }() : z ? function() {
                                var t = new MessageChannel;
                                return t.port1.onmessage = u, function() {
                                    return t.port2.postMessage(0);
                                };
                            }() : void 0 === G ? function() {
                                try {
                                    var t = n(21);
                                    return X = t.runOnLoop || t.runOnContext, c();
                                } catch (t) {
                                    return a();
                                }
                            }() : a();
                            var tt = Math.random().toString(36).substring(16), et = void 0, nt = 1, ot = 2, rt = new I, it = new I, st = 0;
                            return U.prototype._enumerate = function() {
                                for(var t = this.length, e = this._input, n = 0; this._state === et && n < t; n++)this._eachEntry(e[n], n);
                            }, U.prototype._eachEntry = function(t, e) {
                                var n = this._instanceConstructor, o = n.resolve;
                                if (o === l) {
                                    var r = g(t);
                                    if (r === h && t._state !== et) this._settledAt(t._state, e, t._result);
                                    else if ("function" != typeof r) this._remaining--, this._result[e] = t;
                                    else if (n === N) {
                                        var i = new n(p);
                                        T(i, t, r), this._willSettleAt(i, e);
                                    } else this._willSettleAt(new n(function(e) {
                                        return e(t);
                                    }), e);
                                } else this._willSettleAt(o(t), e);
                            }, U.prototype._settledAt = function(t, e, n) {
                                var o = this.promise;
                                o._state === et && (this._remaining--, t === ot ? b(o, n) : this._result[e] = n), 0 === this._remaining && w(o, this._result);
                            }, U.prototype._willSettleAt = function(t, e) {
                                var n = this;
                                C(t, void 0, function(t) {
                                    return n._settledAt(nt, e, t);
                                }, function(t) {
                                    return n._settledAt(ot, e, t);
                                });
                            }, N.all = A, N.race = D, N.resolve = l, N.reject = L, N._setScheduler = i, N._setAsap = s, N._asap = V, N.prototype = {
                                constructor: N,
                                then: h,
                                catch: function(t) {
                                    return this.then(null, t);
                                }
                            }, N.polyfill = H, N.Promise = N, N;
                        });
                    }).call(e, n(12), n(4));
                },
                function(t, e) {
                    function n() {
                        throw new Error("setTimeout has not been defined");
                    }
                    function o() {
                        throw new Error("clearTimeout has not been defined");
                    }
                    function r(t) {
                        if (h === setTimeout) return setTimeout(t, 0);
                        if ((h === n || !h) && setTimeout) return h = setTimeout, setTimeout(t, 0);
                        try {
                            return h(t, 0);
                        } catch (e) {
                            try {
                                return h.call(null, t, 0);
                            } catch (e) {
                                return h.call(this, t, 0);
                            }
                        }
                    }
                    function i(t) {
                        if (l === clearTimeout) return clearTimeout(t);
                        if ((l === o || !l) && clearTimeout) return l = clearTimeout, clearTimeout(t);
                        try {
                            return l(t);
                        } catch (e) {
                            try {
                                return l.call(null, t);
                            } catch (e) {
                                return l.call(this, t);
                            }
                        }
                    }
                    function s() {
                        g && d && (g = !1, d.length ? f = d.concat(f) : m = -1, f.length && c());
                    }
                    function c() {
                        if (!g) {
                            var t = r(s);
                            g = !0;
                            for(var e = f.length; e;){
                                for(d = f, f = []; ++m < e;)d && d[m].run();
                                m = -1, e = f.length;
                            }
                            d = null, g = !1, i(t);
                        }
                    }
                    function a(t, e) {
                        this.fun = t, this.array = e;
                    }
                    function u() {}
                    var h, l, p = t.exports = {};
                    !function() {
                        try {
                            h = "function" == typeof setTimeout ? setTimeout : n;
                        } catch (t) {
                            h = n;
                        }
                        try {
                            l = "function" == typeof clearTimeout ? clearTimeout : o;
                        } catch (t) {
                            l = o;
                        }
                    }();
                    var d, f = [], g = !1, m = -1;
                    p.nextTick = function(t) {
                        var e = new Array(arguments.length - 1);
                        if (arguments.length > 1) for(var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n];
                        f.push(new a(t, e)), 1 !== f.length || g || r(c);
                    }, a.prototype.run = function() {
                        this.fun.apply(null, this.array);
                    }, p.title = "browser", p.browser = !0, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = u, p.addListener = u, p.once = u, p.off = u, p.removeListener = u, p.removeAllListeners = u, p.emit = u, p.prependListener = u, p.prependOnceListener = u, p.listeners = function(t) {
                        return [];
                    }, p.binding = function(t) {
                        throw new Error("process.binding is not supported");
                    }, p.cwd = function() {
                        return "/";
                    }, p.chdir = function(t) {
                        throw new Error("process.chdir is not supported");
                    }, p.umask = function() {
                        return 0;
                    };
                },
                function(t, e) {
                    t.exports = function(t) {
                        return t.webpackPolyfill || (t.deprecate = function() {}, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                            enumerable: !0,
                            get: function() {
                                return t.l;
                            }
                        }), Object.defineProperty(t, "id", {
                            enumerable: !0,
                            get: function() {
                                return t.i;
                            }
                        }), t.webpackPolyfill = 1), t;
                    };
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = n(3), r = n(2), i = n(0), s = function() {
                        function t(t) {
                            this.id = t, this.status = 200, this.headers = {}, this.body = "";
                        }
                        return t;
                    }();
                    e.ResponseData = s;
                    var c;
                    !function(t) {
                        t.Connected = "trouter_js_client_connected", t.Disconnected = "trouter_js_client_disconnected", t.Error = "trouter_js_client_error", t.Progress = "trouter_js_client_progress", t.Response = "trouter_js_client_response", t.Request = "trouter_js_client_request", t.CheckConnection = "trouter_js_client_check_connection", t.Registration = "trouter_js_client_registration", t.Unregistration = "trouter_js_client_unregistration";
                    }(c = e.ClientEventName || (e.ClientEventName = {}));
                    var a = function() {
                        function t(t, e, n, o, r) {
                            this.stepName = t, this.operation = e, this.delta = n, this.ts = o, this.error = r;
                        }
                        return t;
                    }();
                    e.TrackerStep = a;
                    var u = function() {
                        function t() {}
                        return t;
                    }();
                    e.Properties = u;
                    var h = function() {
                        function t() {
                            this.numberOfPingReplies = 0, this.connectedTimestamp = 0, this.isNewUrl = !1, this.transportType = "", this.connectionNumber = 0;
                        }
                        return t;
                    }(), l = function() {
                        function t() {
                            this.enabled = !1, this.numberOfStepsToMaintain = 40, this.logHealthCheckError = !1, this.sendProgressTimeoutSecs = 55, this.logSendPingError = !1, this.maxBackoffInMs = 12e4, this.trouter_js_client_connected = !1, this.trouter_js_client_disconnected = !1, this.trouter_js_client_error = !1, this.trouter_js_client_progress = !1, this.trouter_js_client_response = !1, this.trouter_js_client_request = !1, this.trouter_js_client_registration = !1, this.trouter_js_client_unregistration = !1, this.trouter_js_client_check_connection = !0;
                        }
                        return t;
                    }(), p = function() {
                        function t(t, e, n, r, s, c, a) {
                            this.clientId = e, this.clientInfo = n, this.getServerState = r, this.endpointId = s, this.clientCorrelationID = c, this.environment = a, this.logger = new i.Logger("ConnectionTracker", t), this.clientCorrelationID = void 0 !== c ? c : "", this.steps = [], this.connectionAttempt = 0, this.totalStepCount = 0, this.beginTimestamp = new o.Timespan, this.eventLogSettings = new l, this.connectedInfo = new h;
                        }
                        return t.prototype.enable = function(t) {
                            this.eventLogSettings.enabled = !0, this.eventLogger = t;
                        }, t.prototype.disable = function() {
                            this.eventLogSettings.enabled = !1;
                        }, t.prototype.sendProgress = function(t) {
                            this.steps.length > 0 && this.sendTelemetry(c.Progress, t, this.steps);
                        }, t.prototype.cancelProgressTimer = function() {
                            void 0 !== this.progressTimeout && (clearTimeout(this.progressTimeout), this.progressTimeout = void 0);
                        }, t.prototype.resetProgressSendTimer = function() {
                            var t = this;
                            this.cancelProgressTimer(), void 0 !== this.eventLogSettings.sendProgressTimeoutSecs && this.eventLogSettings.sendProgressTimeoutSecs > 0 && (this.progressTimeout = setTimeout(function() {
                                t.sendProgress({
                                    reason: "timeout",
                                    timeoutSecs: t.eventLogSettings.sendProgressTimeoutSecs
                                });
                            }, 1e3 * this.eventLogSettings.sendProgressTimeoutSecs));
                        }, t.prototype.setConnectedInfo = function(t, e) {
                            this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = Date.now(), this.connectedInfo.isNewUrl = t, this.connectedInfo.transportType = e, ++this.connectedInfo.connectionNumber;
                        }, t.prototype.clearConnectedInfo = function() {
                            this.connectedInfo.numberOfPingReplies = 0, this.connectedInfo.connectedTimestamp = 0, this.connectedInfo.isNewUrl = !0, this.connectedInfo.transportType = "";
                        }, t.prototype.copyProperties = function(t, e) {
                            for(var n = 0, o = Object.keys(e); n < o.length; n++){
                                var r = o[n];
                                e.hasOwnProperty(r) && void 0 !== e[r] && (t[r.replace(/-/g, "_")] = {
                                    value: e[r]
                                });
                            }
                        }, t.prototype.increasePingResponseCount = function() {
                            ++this.connectedInfo.numberOfPingReplies;
                        }, t.prototype.sendTelemetry = function(t, e, n) {
                            try {
                                if (!0 === this.eventLogSettings.enabled && !0 === this.eventLogSettings[t] && void 0 !== this.eventLogger) {
                                    var i = this.getServerState(), s = {
                                        name: t,
                                        properties: {
                                            connectionAttempt: {
                                                value: this.connectionAttempt
                                            },
                                            epid: {
                                                value: this.endpointId
                                            },
                                            clientCorrelationID: {
                                                value: this.clientCorrelationID
                                            },
                                            steps: {
                                                value: o.toJson(n)
                                            },
                                            clientID: {
                                                value: this.clientId
                                            },
                                            eventVersion: {
                                                value: 3
                                            },
                                            environment: {
                                                value: this.environment
                                            },
                                            cv: {
                                                value: r.CLIENT_VERSION
                                            },
                                            ua: {
                                                value: this.clientInfo.ua
                                            },
                                            connectionId: {
                                                value: i.connectionId
                                            },
                                            connectedClientId: {
                                                value: i.connectedClientId
                                            },
                                            domId: {
                                                value: i.domId
                                            },
                                            url: {
                                                value: i.unsecureUrl
                                            },
                                            surl: {
                                                value: i.url
                                            },
                                            ttlInSecs: {
                                                value: i.getRemainingTtlInSec()
                                            },
                                            numberOfPingReplies: {
                                                value: this.connectedInfo.numberOfPingReplies
                                            },
                                            connectedTimestamp: {
                                                value: this.connectedInfo.connectedTimestamp
                                            },
                                            isNewUrl: {
                                                value: this.connectedInfo.isNewUrl
                                            },
                                            transportType: {
                                                value: this.connectedInfo.transportType
                                            },
                                            connectionNumber: {
                                                value: this.connectedInfo.connectionNumber
                                            }
                                        }
                                    };
                                    this.copyProperties(s.properties, e), this.eventLogger.logEvent(s);
                                }
                            } catch (e) {
                                this.logger.warn("error in sending event " + t + ": " + o.toJson(e));
                            }
                        }, t.prototype.createStep = function(t, e, n) {
                            return new a(t, e, this.beginTimestamp.duration, Date.now(), n);
                        }, t.prototype.addStep = function(t, e, n) {
                            if (!1 !== this.eventLogSettings.enabled && (0 === this.steps.length && this.beginTimestamp.reset(), this.steps.push(this.createStep(t, e, n)), ++this.totalStepCount, void 0 !== this.eventLogSettings.numberOfStepsToMaintain && this.steps.length > this.eventLogSettings.numberOfStepsToMaintain)) {
                                var o = this.steps.slice(0);
                                this.steps.length = 0, this.sendTelemetry(c.Progress, {
                                    reason: "flush"
                                }, o);
                            }
                        }, t.prototype.trackStart = function(t) {
                            this.addStep(t, "start");
                        }, t.prototype.trackEnd = function(t) {
                            this.addStep(t, "end");
                        }, t.prototype.trackError = function(t, e, n, o) {
                            void 0 === n && (n = !0), "health" === t && !0 !== this.eventLogSettings.logHealthCheckError || "ping" === t && !1 === this.eventLogSettings.logSendPingError || (void 0 === o && (o = "error"), !0 === n && this.addStep(t, o, e), this.sendTelemetry(c.Error, {}, [
                                this.createStep(t, o, e)
                            ]));
                        }, t.prototype.trackProgress = function(t, e) {
                            this.addStep(t, e);
                        }, t.prototype.trackConnected = function(t, e) {
                            this.setConnectedInfo(t, e);
                            var n = this.steps.slice(0), o = this.totalStepCount, r = this.beginTimestamp.duration;
                            this.steps.length = 0, this.totalStepCount = 0, this.sendTelemetry(c.Connected, {
                                stepCount: n.length,
                                totalStepCount: o,
                                connectionEstablishmentMs_Total: r
                            }, n), this.cancelProgressTimer();
                        }, t.prototype.trackDisconnected = function(t) {
                            t.sessionLengthMS = Date.now() - this.connectedInfo.connectedTimestamp, this.sendTelemetry(c.Disconnected, t, []), this.resetProgressSendTimer();
                        }, t.prototype.trackNewConnection = function() {
                            ++this.connectionAttempt;
                        }, t.prototype.trackRequest = function(t, e) {
                            var n = {};
                            void 0 !== e && (n.hasError = !0, n.error = e);
                            try {
                                if (t) {
                                    n.requestID = t.id, n.httpMethod = t.method, n.url = t.url, n.bodyLength = t.body.length, n.shortUrl = t.shortUrl, n.requestTimeStamp = t.startTS, n.correlationVector = t.correlationVector;
                                    for(var r = t.headers, i = 0, s = Object.keys(r); i < s.length; i++){
                                        var a = s[i];
                                        r.hasOwnProperty(a) && (n[a] = r[a]);
                                    }
                                }
                            } catch (t) {
                                n.hasError = !0, n.error = n.error + " error creating request context " + o.toJson(t);
                            }
                            this.sendTelemetry(c.Request, n, []);
                        }, t.prototype.trackResponse = function(t, e, n, r) {
                            var i = {};
                            void 0 !== r && (i.hasError = !0, i.error = r);
                            try {
                                if (i.responseTimestamp = void 0 !== n ? n.sentTS : Date.now(), t) {
                                    i.requestID = t.id, i.httpMethod = t.method, i.shortUrl = t.shortUrl, i.correlationVector = t.correlationVector;
                                    for(var s = t.headers, a = 0, u = Object.keys(s); a < u.length; a++){
                                        var h = u[a];
                                        s.hasOwnProperty(h) && (i[h] = s[h]);
                                    }
                                }
                                n && (i.latencyMS = e, i.responseCode = n.status, i.responseLength = n.body.length);
                            } catch (t) {
                                i.hasError = !0, i.error = i.error + " error creating response context " + o.toJson(t);
                            }
                            this.sendTelemetry(c.Response, i, []);
                        }, t.prototype.sendResponseError = function(t, e, n) {
                            this.trackResponse(e, void 0, n, t);
                        }, t.prototype.close = function() {
                            this.sendProgress({
                                reason: "closed"
                            }), this.steps.length = 0, this.cancelProgressTimer();
                        }, t.prototype.mergeSettings = function(t) {
                            if (t) {
                                this.eventLogSettings.numberOfStepsToMaintain = Math.min(40, Math.max(10, void 0 !== t.numberOfStepsToMaintain ? t.numberOfStepsToMaintain : 0));
                                var e = Math.min(3600, Math.max(55, void 0 !== t.sendProgressTimeoutSecs ? t.sendProgressTimeoutSecs : 0));
                                this.eventLogSettings.logHealthCheckError = t.logHealthCheckError, this.eventLogSettings.logSendPingError = t.logSendPingError;
                                for(var n = 0, o = Object.keys(c).map(function(t) {
                                    return c[t];
                                }); n < o.length; n++){
                                    var r = o[n];
                                    t.hasOwnProperty(r) && void 0 !== t[r] && (this.eventLogSettings[r] = t[r]);
                                }
                                this.eventLogSettings.sendProgressTimeoutSecs !== e && (this.eventLogSettings.sendProgressTimeoutSecs = e, this.resetProgressSendTimer());
                            }
                        }, t;
                    }();
                    e.ConnectionTracker = p;
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = function() {
                        function t(t, e) {
                            this.logger = t, this.maxBackoffInMs = e, this.backoffId = 0, this.backoffCount = 0;
                        }
                        return t.calculateNextBackoffMs = function(t, e) {
                            var n = 1 + .4 * (Math.random() - .5), o = 1e3 * Math.pow(2, t) * n;
                            return o = Math.round(o), Math.min(e, o);
                        }, t.prototype.setMaxBackoffMs = function(t) {
                            this.maxBackoffInMs = t;
                        }, t.prototype.backoff = function(e, n) {
                            var o = this;
                            void 0 !== this.timerHandle && (this.logger.debug("Clearing current back off"), clearTimeout(this.timerHandle), this.timerHandle = void 0);
                            var r = t.calculateNextBackoffMs(this.backoffCount, this.maxBackoffInMs);
                            this.backoffId++, this.backoffCount++, this.logger.info("Backing off " + e + " for " + r + " milliseconds with ID " + this.backoffId), this.timerHandle = setTimeout(function() {
                                o.logger.info("Back off for " + e + " with ID " + o.backoffId + " complete, invoking handler"), o.timerHandle = void 0, n();
                            }, r);
                        }, t.prototype.reset = function() {
                            void 0 !== this.timerHandle && (this.logger.debug("Resetting back off"), clearTimeout(this.timerHandle), this.timerHandle = void 0), this.backoffCount = 0;
                        }, t;
                    }();
                    e.ExponentialBackoff = o;
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = n(20), r = n(11), i = n(3), s = n(14), c = n(2), a = n(15), u = n(1), h = n(5), l = n(0), p = n(17), d = n(10), f = function() {
                        function t() {
                            this.cv = c.CLIENT_VERSION, this.ua = "", this.hr = "", this.v = "";
                        }
                        return t;
                    }(), g = function() {
                        function t() {
                            this["force new connection"] = !0, this.reconnect = !1, this.query = "", this.ackTimeoutMs = 5e3;
                        }
                        return t;
                    }(), m = "MS-CV", v = function() {
                        function t(t) {
                            this.cvCounter = 0;
                            var e = JSON.parse(t);
                            this.startTS = e.hasOwnProperty("startTS") ? e.startTS : 0, this.url = e.hasOwnProperty("url") ? e.url : "", this.shortUrl = e.hasOwnProperty("shortUrl") ? e.shortUrl : "", this.body = e.hasOwnProperty("body") ? e.body : "", this.headers = e.hasOwnProperty("headers") ? e.headers : {}, this.id = e.hasOwnProperty("id") && "number" == typeof e.id ? e.id : -1, this.method = e.hasOwnProperty("method") ? e.method : "", this.replied = !1, this.timedout = !1, this.timeoutTimerId = 0, this.receivedCv = this.headers[m], this.updateCvHeader();
                        }
                        return Object.defineProperty(t.prototype, "correlationVector", {
                            get: function() {
                                return this.receivedCv ? this.receivedCv + "." + this.cvCounter : "";
                            },
                            enumerable: !0,
                            configurable: !0
                        }), t.prototype.on = function(t, e) {
                            "data" === t ? this.dataCallback = e : "end" === t && ("function" == typeof this.dataCallback && this.dataCallback(this.body), e());
                        }, t.prototype.incrementCorrelationVector = function() {
                            ++this.cvCounter, this.updateCvHeader();
                        }, t.prototype.updateCvHeader = function() {
                            var t = this.correlationVector;
                            t && (this.headers[m] = t);
                        }, t;
                    }(), y = function() {
                        function t(t, e, n) {
                            this.request = t, this.responseData = e, this.sendResponse = n;
                        }
                        return t.prototype.writeHead = function(t, e) {
                            this.responseData.status = t, this.responseData.headers = e;
                        }, t.prototype.write = function(t) {
                            this.responseData.body += t;
                        }, t.prototype.end = function(t) {
                            return t && (this.responseData.body += t), this.sendResponse(this.request, this.responseData);
                        }, t;
                    }(), T = function() {
                        function t(t) {
                            this.name = t, this.args = {}, this.timeoutTimerId = 0;
                        }
                        return t;
                    }(), k = function() {
                        function t(t, e, n, r, i) {
                            var h = this;
                            this.options = e, this.manager = n, this.tokenProvider = r, this.connectionId = "", this.inIncallMode = !1, this.connectionAttempt = 0, this.connectedClientId = "", this.c2cUrlBase = "", this.pendingTimers = {}, this.UNKNOWN_TRANSPORT = "unknown_transport", this.logger = new l.Logger("Connection", t), this.timeoutOptions = this.options.timeoutOptions, this.healthBackoff = new a.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs), this.tokenBackoff = new a.ExponentialBackoff(this.logger, this.timeoutOptions.maxBackoffMs), this.clientID = Date.now(), "undefined" != typeof window && window.location && (this.domId = window.location.hostname), this.clientInfo = new f, this.clientInfo.cv = c.CLIENT_VERSION, this.clientInfo.ua = "", this.options && this.options.clientInfo && (this.clientInfo.ua = this.safeString(this.options.clientInfo.ua), this.clientInfo.v = this.safeString(this.options.clientInfo.v)), this.connectionTracker = new s.ConnectionTracker(t, this.clientID, this.clientInfo, function() {
                                return h.getServerState();
                            }, this.options.endpointId, this.options.clientCorrelationID, this.options.environment), this.applyConnectionTrackerOptions(e);
                            var d = this.options.incallModeTimeoutMs > 0;
                            if (this.fsm = new p.TrouterFsm(t, this, d), e.registration) {
                                var g = {
                                    registrarUrl: e.registration.registrarUrl,
                                    registrationId: e.registration.registrationId,
                                    requestTimeoutMs: e.timeoutOptions.fetchTimeoutMs,
                                    initialRetryDelayMs: 1e3,
                                    maxRetryDelayMs: e.timeoutOptions.maxBackoffMs
                                };
                                this.registrarClient = o.createRegistrarClient(t, this.tokenProvider, g);
                            }
                            this.userActivityState = i || u.UserActivityState.Unknown;
                        }
                        return t.prototype.start = function() {
                            this.logger.info("Starting"), this.fsm.start();
                        }, t.prototype.stop = function(t) {
                            this.logger.info("Stopping"), this.connectionTracker.close(), this.fsm.stop(t);
                        }, t.prototype.configure = function(t) {
                            var e = this.options.trouterUrl !== t.trouterUrl;
                            this.options = t, this.applyConnectionTrackerOptions(t), e && this.onTrouterReconnect();
                        }, t.prototype.checkConnection = function(t) {
                            this.logger.info("checkConnection called with " + t), this.fsm.checkConnection(t), t && this.connectionTracker.sendTelemetry(s.ClientEventName.CheckConnection, {
                                disconnectDetected: t
                            }, []);
                        }, t.prototype.getServerState = function() {
                            return new h.ServerState(this.connectionId, this.connectedClientId, this.domId ? this.domId : "", this.allocateResult ? this.allocateResult.url : "", this.allocateResult ? this.allocateResult.surl : "", this.c2cUrlBase, this.connectionExpireTimestampInSecs);
                        }, t.prototype.getUserActivityState = function() {
                            return this.userActivityState;
                        }, t.prototype.getToken = function(t, e) {
                            var n = this;
                            this.logger.info("Getting token " + (e ? "with backoff" : "without backoff"));
                            var o = function() {
                                n.connectionTracker.trackStart("token"), n.tokenProvider(!t).then(function(t) {
                                    n.logger.debug("token is received"), n.connectionTracker.trackEnd("token"), n.fsm.onTokenReceived(t);
                                }).catch(function(e) {
                                    var o = i.toJson(e.stack);
                                    n.logger.error("Getting token failed, will retry after timeout. Error: " + o), n.connectionTracker.trackError("token", o), n.getToken(t, !0);
                                });
                            };
                            e ? this.tokenBackoff.backoff("getting token", o) : (this.tokenBackoff.reset(), o());
                        }, t.prototype.startConnectionTimer = function() {
                            var t = this;
                            this.stopConnectionTimer(), this.logger.debug("Starting connection timeout for " + this.timeoutOptions.connectionTimeoutMs + " ms"), this.connectionTimeoutId = setTimeout(function() {
                                t.logger.info("Connection timeout is fired"), t.fsm.onConnectingTimeout();
                            }, this.timeoutOptions.connectionTimeoutMs);
                        }, t.prototype.stopConnectionTimer = function() {
                            this.connectionTimeoutId && (this.logger.debug("Stopping connection timeout"), clearTimeout(this.connectionTimeoutId), this.connectionTimeoutId = void 0);
                        }, t.prototype.startPingTimer = function() {
                            var t = this;
                            "websocket" === this.transportTypeName ? (this.logger.debug("Starting ping timeout for " + this.timeoutOptions.pingTimeoutMs + " ms"), this.pingTimerId = setInterval(function() {
                                t.logger.info("Ping interval fired"), t.fsm.onPingInterval();
                            }, this.timeoutOptions.pingTimeoutMs)) : this.logger.debug("Not starting ping for transport " + this.transportTypeName);
                        }, t.prototype.stopPingTimer = function() {
                            this.pingTimerId && (this.logger.debug("Stopping ping timeout"), this.clearPingResponseTimer(), clearInterval(this.pingTimerId), this.pingTimerId = void 0);
                        }, t.prototype.shouldSkipRegistration = function() {
                            return void 0 === this.options.registration;
                        }, t.prototype.hasCustomRegisterTtl = function() {
                            return this.options.registration && this.options.registration.registrarTtlSec;
                        }, t.prototype.startRegisterTimer = function() {
                            var t = this;
                            if (void 0 !== this.registrationTimerId) return void this.logger.error("Another registration timer is set - don't create another one");
                            var e = this.getRegistrationTtl() - 30;
                            this.logger.debug("Starting registration timeout for " + e + " sec"), this.registrationTimerId = setTimeout(function() {
                                t.logger.info("Registration timeout is fired"), t.registrationTimerId = void 0, t.fsm.onRegistrationTimeout();
                            }, 1e3 * e);
                        }, t.prototype.stopRegisterTimer = function() {
                            this.registrationTimerId && (this.logger.debug("Stopping registration timeout"), clearTimeout(this.registrationTimerId), this.registrationTimerId = void 0);
                        }, t.prototype.resendRegistration = function() {
                            if (!this.registrarClient) throw new Error("Trouter Client not configured to handle registrations");
                            return this.registrarClient.resendRegistration();
                        }, t.prototype.buildSocketIoUrlParams = function() {
                            if (!this.allocateResult) throw new Error("Allocate result is undefined in buildSocketIoUrlParams()");
                            var t = {};
                            if (this.allocateResult.connectparams) for(var e = this.allocateResult.connectparams, n = 0, o = Object.keys(e); n < o.length; n++){
                                var r = o[n];
                                e.hasOwnProperty(r) && void 0 !== e[r] && (t[r] = e[r]);
                            }
                            return t.v = "v4", t.tc = encodeURI(i.toJson(this.clientInfo)), t.timeout = this.timeoutOptions.pingTimeoutMs / 1e3, t.auth = "true", this.options.endpointId && (t.epid = this.options.endpointId), this.userActivityState !== u.UserActivityState.Unknown && (t.userActivity = encodeURI(i.toJson(this.createUserActivityObject(this.userActivityState)))), this.appendConnectedClientIds(this.buildQuery(t), !0);
                        }, t.prototype.startSocketIo = function() {
                            var t = this;
                            if (this.logger.info("Starting socket io"), this.connectionTracker.trackStart("connectSocket"), !this.allocateResult) throw new Error("Allocate result is undefined in startSocketIo()");
                            var e = this.options.ioOptions || new g;
                            if (e["force new connection"] = !0, e.reconnect = !1, e.query = this.buildSocketIoUrlParams(), this.logger.info("connecting to " + this.allocateResult.socketio + "?" + e.query), this.stopSocketIo(), this.socket = (this.options.io || d).connect(this.allocateResult.socketio, e), void 0 === this.socket) throw new Error("Can't create Socket.io object");
                            this.socket.on("connecting", function(e) {
                                t.onSocketConnecting(e);
                            }), this.socket.on("connect", function() {
                                t.onSocketConnect();
                            }), this.socket.on("connect_failed", function(e) {
                                t.onSocketConnectFailed(e);
                            }), this.socket.on("disconnect", function() {
                                t.onSocketDisconnect();
                            }), this.socket.on("reconnect", function() {
                                t.onSocketReconnect();
                            }), this.socket.on("reconnect_failed", function(e) {
                                t.onSocketReconnectFailed(e);
                            }), this.socket.on("reconnecting", function() {
                                t.onSocketReconnecting();
                            }), this.socket.on("error", function(e) {
                                t.onSocketError(e);
                            }), this.socket.on("message", function(e) {
                                t.onSocketMessage(e);
                            }), this.socket.on("trouter.connected", function(e) {
                                t.onTrouterConnected(e);
                            }), this.socket.on("trouter.reconnect", function() {
                                t.onTrouterReconnect();
                            }), this.socket.on("trouter.message_loss", function(e) {
                                t.onTrouterMessageLoss(e);
                            });
                        }, t.prototype.stopSocketIo = function() {
                            if (this.socket) {
                                this.logger.info("clearing socket.io");
                                try {
                                    for(var t = 0, e = [
                                        "connecting",
                                        "connect",
                                        "connect_failed",
                                        "disconnect",
                                        "reconnect",
                                        "reconnect_failed",
                                        "reconnecting",
                                        "error",
                                        "message",
                                        "trouter.connected",
                                        "trouter.reconnect",
                                        "trouter.message_loss"
                                    ]; t < e.length; t++){
                                        var n = e[t];
                                        this.socket.removeAllListeners(n);
                                    }
                                    this.socket.disconnect(), this.logger.debug("cleared socket"), this.socket = void 0;
                                } catch (t) {
                                    this.logger.error("exception in disconnecting previous socket. Error: " + i.toJson(t.stack));
                                }
                            }
                        }, t.prototype.dispatchConnected = function() {
                            this.logger.info("dispatching connected"), this.manager.onConnected(this);
                        }, t.prototype.dispatchRegistered = function() {
                            this.logger.info("dispatching connected"), this.manager.onRegistered(this);
                        }, t.prototype.dispatchDownstreamRequest = function(t) {
                            var e = this;
                            this.logger.info("dispatching downstream request");
                            try {
                                var n = new y(t, new s.ResponseData(t.id), function(t, n) {
                                    return e.logger.info("sending response to downstream"), e.sendResponse(t, n);
                                });
                                this.manager.onDownstreamRequest(this, t, n);
                            } catch (t) {
                                this.logger.error("exception in socket.on message. Error : " + i.toJson(t.stack));
                            }
                        }, t.prototype.dispatchReconnecting = function() {
                            this.logger.info("dispatching reconnecting"), this.manager.onReconnecting(this);
                        }, t.prototype.dispatchReconnectIsRequired = function() {
                            this.logger.info("dispatching reconnect is required by server"), this.manager.onReconnectIsRequired(this);
                        }, t.prototype.dispatchDisconnected = function() {
                            this.logger.info("dispatching disconnected"), this.manager.onDisconnected(this);
                        }, t.prototype.dispatchTrouterMessageLost = function(t) {
                            this.logger.info("dispatching trouter lost message"), this.manager.onTrouterMessageLost(t);
                        }, t.prototype.sendProcessedDroppedIndicators = function(t) {
                            var e = this;
                            try {
                                this.logger.info("emitting processed flow tags to the server");
                                var n = new T("trouter.processed_message_loss");
                                n.args = {
                                    droppedIndicators: t
                                }, this.sendDownstreamEvent(n, function() {
                                    e.logger.info("emitted processed flow tags to the server");
                                });
                            } catch (t) {
                                var o = i.toJson(t.stack);
                                this.logger.error("unable to send processed message loss event. Error: " + o), this.connectionTracker.trackError("trouter.processed_message_loss", o, !1);
                            }
                        }, t.prototype.resetAllocationConnectionParams = function() {
                            this.allocateResult && (this.logger.info("Resetting allocation connection parameters"), this.allocateResult.connectparams = void 0);
                        }, t.prototype.sendAllocateRequest = function(t) {
                            var e = this;
                            this.connectionAttempt++, this.connectionTracker.trackNewConnection();
                            var n = this.appendCorrelationIds(this.options.trouterUrl, !1);
                            this.allocateResult && this.allocateResult.connectparams && (n += "&" + this.buildQuery(this.allocateResult.connectparams), this.allocateResult.connectparams.v || (n += "&v=v4"));
                            var o = new Request(n, {
                                method: "POST",
                                mode: "cors",
                                headers: new Headers({
                                    "X-Skypetoken": t,
                                    "Content-Type": "text/plain"
                                })
                            });
                            this.logger.info("sendAllocateRequest: POST " + n), this.connectionTracker.trackStart("allocation");
                            var r = -1;
                            this.fetchWithTimeout(o, this.timeoutOptions.fetchTimeoutMs).then(function(t) {
                                if (r = t.status, !t.ok) throw new Error(t.statusText);
                                var n = t.headers.get("content-type");
                                if (!n || "application/json" !== n && "application/json;" !== n.substring(0, 17)) throw new Error("Content-type '" + n + "' is unexpected");
                                return e.connectionTracker.trackEnd("allocation"), t.json();
                            }).then(function(t) {
                                e.onAllocationResponse(t);
                            }).catch(function(t) {
                                var n = t + ", status code " + r;
                                e.logger.error("Allocation request failed. Error: " + n), e.connectionTracker.trackError("allocation", n), e.fsm.onAllocationFailed(401 === r);
                            });
                        }, t.prototype.sendPingRequest = function() {
                            var t = this;
                            if (this.socket && void 0 === this.pingResponseTimerId) try {
                                this.logger.info("emitting ping event"), this.socket.emit("ping", function() {
                                    t.onPingResponse();
                                }), this.pingResponseTimerId = setTimeout(function() {
                                    t.logger.error("Ping response timeout is fired"), t.clearPingResponseTimer(), t.fsm.onPingResponseTimeout();
                                }, this.timeoutOptions.pongTimeoutMs);
                            } catch (t) {
                                var e = i.toJson(t.stack);
                                this.logger.error("unable to send ping. Error: " + e), this.connectionTracker.trackError("ping", e, !1);
                            }
                        }, t.prototype.setUserActivityState = function(t) {
                            var e = t !== this.userActivityState;
                            this.userActivityState = t, this.fsm.onSetUserActivityState(t, e);
                        }, t.prototype.sendUserActivityState = function(t, e) {
                            this.userActivityState !== u.UserActivityState.Unknown && ("websocket" === this.transportTypeName && e ? t === h.UserActivityEventReason.Connected ? this.sendUserActivityStateMultiple(2) : this.sendUserActivityStateMultiple(1) : "xhr-polling" === this.transportTypeName && t === h.UserActivityEventReason.Modified && this.fsm.forceReconnect());
                        }, t.prototype.sendRegisterRequest = function() {
                            var t = this;
                            if (!this.options.registration || !this.registrarClient) throw new Error("Internal error - options.registration is undefined");
                            if (!this.allocateResult) throw new Error("Allocate result is undefined in sendRegisterRequest()");
                            this.logger.info("sending register request");
                            var e = new i.Timespan;
                            this.connectionTracker.trackStart("registration"), this.registrarClient.register({
                                appId: this.options.registration.pnhAppId,
                                aesKey: "",
                                languageId: "en-US",
                                platform: this.options.registration.platform,
                                templateKey: this.options.registration.pnhTemplateKey,
                                platformUIVersion: this.options.registration.platformUIVersion,
                                productContext: this.options.registration.productContext
                            }, {
                                TROUTER: [
                                    {
                                        context: this.options.registration.context,
                                        path: this.allocateResult.surl,
                                        ttl: this.getRegistrationTtl()
                                    }
                                ]
                            }).then(function() {
                                t.logger.info("Register request successful"), t.connectionTracker.trackEnd("registration"), t.fsm.onRegistrationSucceed(), t.connectionTracker.sendTelemetry(s.ClientEventName.Registration, {
                                    duration: e.duration
                                }, []);
                            }).catch(function(n) {
                                t.logger.error("Register request failed. Error: " + n), t.connectionTracker.trackError("registration", n.message), t.connectionTracker.sendTelemetry(s.ClientEventName.Registration, {
                                    duration: e.duration
                                }, []);
                            });
                        }, t.prototype.sendUnregisterRequest = function() {
                            var t = this;
                            this.logger.info("sending unregister request");
                            var e = new i.Timespan;
                            if (!this.options.registration || !this.registrarClient) throw new Error("Internal error - options.registration is undefined");
                            this.connectionTracker.trackStart("unregistration"), this.registrarClient.unregister().then(function() {
                                t.logger.info("Unregister request successful"), t.connectionTracker.trackEnd("unregistration"), t.fsm.onUnregistrationSucceed(), t.connectionTracker.sendTelemetry(s.ClientEventName.Unregistration, {
                                    duration: e.duration
                                }, []);
                            }).catch(function(n) {
                                t.logger.error("Unregister request failed. Error: " + n), t.connectionTracker.trackError("unregistration", n.message), t.fsm.onUnregistrationFailed(!1), t.connectionTracker.sendTelemetry(s.ClientEventName.Unregistration, {
                                    duration: e.duration
                                }, []);
                            });
                        }, t.prototype.fetchWithTimeout = function(t, e) {
                            return new r.Promise(function(n, o) {
                                fetch(t).then(n).catch(o), 0 !== e && setTimeout(o, e, new Error("Fetch for '" + t.url + "' timed out"));
                            });
                        }, t.prototype.resetTokenBackoff = function() {
                            this.tokenBackoff.reset();
                        }, t.prototype.resetRegisterBackoff = function() {
                            this.registrarClient && this.registrarClient.cancelPendingRequests();
                        }, t.prototype.clearTimers = function() {
                            this.logger.debug("Clearing all pending downstream events related timers");
                            for(var t = 0, e = Object.keys(this.pendingTimers); t < e.length; t++){
                                var n = e[t];
                                this.clearTimer(Number(n));
                            }
                        }, t.prototype.restartIncallModeTimer = function() {
                            var t = this;
                            this.clearIncallModeTimerId(), this.logger.debug("Restarting incall mode timer"), this.incallModeTimerId = setTimeout(function() {
                                t.logger.info("Call mode timer fired"), t.fsm.onIncallModeTimer();
                            }, this.options.incallModeTimeoutMs);
                        }, t.prototype.enterIncallMode = function() {
                            this.logger.info("Entering incall mode"), this.timeoutOptions = this.options.incallTimeoutOptions, this.healthBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = !0;
                        }, t.prototype.exitIncallMode = function() {
                            this.logger.info("Exiting incall mode"), this.clearIncallModeTimerId(), this.timeoutOptions = this.options.timeoutOptions, this.healthBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.tokenBackoff.setMaxBackoffMs(this.timeoutOptions.maxBackoffMs), this.inIncallMode = !1;
                        }, t.prototype.isIncallMode = function() {
                            return this.inIncallMode;
                        }, t.prototype.onSocketConnecting = function(t) {
                            this.logger.info("onSocketConnecting(" + t + ")"), this.transportTypeName = t, this.connectionTracker.trackProgress("connecting", this.transportTypeName), this.fsm.onConnecting();
                        }, t.prototype.onSocketConnect = function() {
                            this.logger.info("onSocketConnect");
                        }, t.prototype.onSocketConnectFailed = function(t) {
                            this.logger.error("onSocketConnectFailed"), this.connectionTracker.trackError("connect_failed", t, !0, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), this.fsm.onConnectingFailed();
                        }, t.prototype.onSocketDisconnect = function() {
                            this.logger.error("onSocketDisconnect"), this.connectionTracker.trackDisconnected({
                                serverClosed: !this.fsm.isActive()
                            }), this.connectionTracker.clearConnectedInfo(), this.fsm.onSocketError(void 0), this.connectionExpireTimestampInSecs = void 0;
                        }, t.prototype.onSocketReconnect = function() {
                            this.logger.error("onSocketReconnect"), this.fsm.onTrouterConnected();
                        }, t.prototype.onSocketReconnectFailed = function(t) {
                            this.logger.error("onSocketReconnectFailed with '" + t + "'"), this.fsm.onSocketError("string" == typeof t ? t : void 0);
                        }, t.prototype.onSocketReconnecting = function() {
                            this.logger.error("onSocketReconnecting");
                        }, t.prototype.onSocketError = function(t) {
                            this.logger.error("onSocketError with '" + i.toJson(t) + "'"), this.connectionTracker.trackError("connectSocket", t), this.fsm.onSocketError("string" == typeof t ? t : void 0);
                        }, t.prototype.onSocketMessage = function(t) {
                            var e = this;
                            this.logger.info("onSocketMessage");
                            var n;
                            try {
                                n = new v(t);
                                var o = n.headers && n.headers["X-Microsoft-Skype-Chain-ID"], r = o ? " Chain-Id " + o : "";
                                this.logger.info("Received request N " + n.id + r + " CV " + n.correlationVector + " to '" + n.url + "'"), n.startTS = Date.now(), n.url && this.urlPath && 0 === n.url.indexOf(this.urlPath) && (n.shortUrl = n.url.substring(this.urlPath.length));
                            } catch (t) {
                                var c = i.toJson(t.stack);
                                return this.logger.error("unable to parse request. Error: " + c), this.connectionTracker.trackRequest(void 0, c), void this.connectionTracker.sendResponseError("unable to parse request, error: " + t);
                            }
                            n.timeoutTimerId = setTimeout(function() {
                                if (!n.replied) {
                                    e.logger.error("Request " + n.id + " timed out");
                                    var t = new s.ResponseData(n.id);
                                    t.status = 504, t.headers = {
                                        "Trouter-Responder": "ClientLib"
                                    }, e.sendResponse(n, t), n.timedout = !0;
                                }
                            }, this.timeoutOptions.requestTimeoutMs);
                            try {
                                this.connectionTracker.trackRequest(n), this.fsm.onDownstreamRequest(n);
                            } catch (t) {
                                this.logger.error("exception in socket.on message. Error: " + i.toJson(t.stack)), this.connectionTracker.sendResponseError(t.message, n, void 0);
                            }
                        }, t.prototype.onTrouterConnected = function(t) {
                            if (!this.allocateResult) return void this.logger.error("Invalid internal state - received onTrouterConnected while allocateResult is not set");
                            this.logger.info("onTrouterConnected: " + this.allocateResult.url), this.socket && this.socket.socket && this.socket.socket.options && this.socket.socket.options.query && (this.socket.socket.options.query += "&connected=true"), this.urlPath = this.allocateResult.url.replace(/https?:\/\/([A-z0-9\:\$\-\_\.\+\!\*\"\(\)\,]*)\//, "/");
                            var e = this.connectedUrl !== this.allocateResult.url;
                            this.connectedUrl = this.allocateResult.url, this.connectionExpireTimestampInSecs = i.calculateExpireTsInSec(t.ttl), this.connectionTracker.trackEnd("connectSocket"), this.connectionTracker.trackConnected(e, this.transportTypeName ? this.transportTypeName : this.UNKNOWN_TRANSPORT), this.fsm.onTrouterConnected();
                        }, t.prototype.onTrouterReconnect = function() {
                            this.logger.info("onTrouterReconnect"), this.fsm.onReconnectRequired();
                        }, t.prototype.onTrouterMessageLoss = function(t) {
                            this.logger.info("onTrouterMessageLoss"), this.fsm.onTrouterMessageLost(t.droppedIndicators);
                        }, t.prototype.onAllocationResponse = function(t) {
                            this.logger.info("Received allocation response " + JSON.stringify(t)), this.allocateResult = t;
                            var e = +t.ttl;
                            if (this.connectionExpireTimestampInSecs = i.calculateExpireTsInSec(e), this.connectionId = this.allocateResult.id || "", this.connectedClientId = this.allocateResult.ccid, this.logger.info("connected client id set {connectedClientId:" + this.connectedClientId + "}"), this.c2cUrlBase = t.curlb || "", "" === this.c2cUrlBase) {
                                var n = t.surl.indexOf("://");
                                n >= 0 && (n = t.surl.indexOf("/", n + 3)) >= 5 && ":3443" === t.surl.substr(n - 5, 5) && (this.c2cUrlBase = t.surl.substr(0, n - 5));
                            }
                            this.fsm.onAllocationSucceed();
                        }, t.prototype.onPingResponse = function() {
                            this.logger.info("onPingResponse"), this.connectionTracker.increasePingResponseCount(), this.clearPingResponseTimer(), this.fsm.onPingResponse();
                        }, t.prototype.clearPingResponseTimer = function() {
                            void 0 !== this.pingResponseTimerId && (clearTimeout(this.pingResponseTimerId), this.pingResponseTimerId = void 0);
                        }, t.prototype.buildQuery = function(t) {
                            for(var e = [], n = 0, o = Object.keys(t); n < o.length; n++){
                                var r = o[n];
                                t.hasOwnProperty(r) && void 0 !== t[r] && e.push(r + "=" + t[r]);
                            }
                            return e.join("&");
                        }, t.prototype.appendConnectedClientIds = function(t, e) {
                            var n = "";
                            t.indexOf("ccid=") < 0 && (n = "ccid=" + this.connectedClientId + "&"), this.domId && (n += "dom=" + this.domId + "&"), n.length > 0 && (n = n.slice(0, -1));
                            var o = e || -1 !== t.indexOf("?") ? "&" : "?";
                            return this.appendCorrelationIds(t + o + n, e);
                        }, t.prototype.appendCorrelationIds = function(t, e) {
                            var n = e || -1 !== t.indexOf("?") ? "&" : "?";
                            return t.indexOf("cor_id") < 0 ? "" + t + n + "cor_id=" + this.options.clientCorrelationID + "&con_num=" + this.clientID + "_" + this.connectionAttempt : t;
                        }, t.prototype.getHealthUrl = function(t) {
                            return t.substring(0, t.lastIndexOf("/a")) + "/h";
                        }, t.prototype.safeString = function(t) {
                            return "string" == typeof t ? t : "";
                        }, t.prototype.sendResponse = function(t, e) {
                            if (t.timedout) return this.logger.error("Request " + t.id + " already timed out"), 1;
                            if (t.replied) return this.logger.error("Response for request " + t.id + " already sent"), 2;
                            clearTimeout(t.timeoutTimerId), t.timeoutTimerId = 0, t.replied = !0, e.headers = e.headers || {};
                            var n = t.correlationVector;
                            this.logger.info("Sending response for request N " + t.id + " CV " + n + " with status " + e.status), n && (e.headers[m] = n), t.headers && t.headers["trouter-request"] && !e.headers["trouter-request"] && (e.headers["trouter-request"] = t.headers["trouter-request"]);
                            var o = Date.now() - t.startTS;
                            if (e.headers["trouter-client"] = i.toJson({
                                cd: o
                            }), this.logger.debug("response: " + i.toJson(e)), !this.socket) return this.connectionTracker.sendResponseError("no socket", t, e), 4;
                            try {
                                return this.socket.send(i.toJson(e)), e.sentTS = Date.now(), t.incrementCorrelationVector(), this.connectionTracker.trackResponse(t, o, e), "websocket" === this.transportTypeName && this.sendPingRequest(), 0;
                            } catch (n) {
                                var r = "unable to send data on response.end. Error: " + i.toJson(n.stack);
                                return this.logger.error(r), this.connectionTracker.sendResponseError(r, t, e), 4;
                            }
                        }, t.prototype.sendUserActivityStateMultiple = function(t) {
                            var e = this, n = new T("user.activity");
                            n.args = this.createUserActivityObject(this.userActivityState), this.logger.debug("Sending user activity '" + u.UserActivityState[this.userActivityState] + "', remaining " + (t - 1)), this.sendDownstreamEvent(n, function() {
                                if (e.onDownstreamEventResponse(n), e.clearTimer(n.timeoutTimerId), t > 1) {
                                    var o = setTimeout(function() {
                                        e.clearTimer(o), e.sendUserActivityStateMultiple(t - 1);
                                    }, e.options.userActivitySecondResendDelayMs);
                                    e.registerTimer(o, "user.activity/resend");
                                }
                            }), n.timeoutTimerId = setTimeout(function() {
                                e.logger.error("Activity state response timeout is fired"), e.fsm.onActivityStateResponseTimeout(), e.clearTimer(n.timeoutTimerId);
                            }, this.timeoutOptions.userActivityResponseTimeoutMs), this.registerTimer(n.timeoutTimerId, "user.activity/response");
                        }, t.prototype.sendDownstreamEvent = function(t, e) {
                            this.logger.info("Sending downstream event " + t.name), this.socket && this.socket.emit(t.name, t.args, e);
                        }, t.prototype.onDownstreamEventResponse = function(t) {
                            this.logger.info("onDownstreamEventResponse(" + t.name + ")");
                        }, t.prototype.registerTimer = function(t, e) {
                            this.logger.debug("registering timer " + t + " -> " + e), this.pendingTimers[t] = e;
                        }, t.prototype.clearTimer = function(t) {
                            var e = this.pendingTimers[t];
                            this.logger.debug("clearing timer " + t + " -> " + e), delete this.pendingTimers[t], clearTimeout(t);
                        }, t.prototype.getRegistrationTtl = function() {
                            var t = i.calculateTtlInSec(this.connectionExpireTimestampInSecs);
                            return this.logger.debug("Current connectionID will expire in " + t + " seconds"), this.options.registration && this.options.registration.registrarTtlSec && t > 0 ? Math.min(this.options.registration.registrarTtlSec, t) : this.options.registration && this.options.registration.registrarTtlSec ? this.options.registration.registrarTtlSec : t > 0 ? t : 3600;
                        }, t.prototype.clearIncallModeTimerId = function() {
                            void 0 !== this.incallModeTimerId && (this.logger.debug("Clearing in-call mode timer"), clearTimeout(this.incallModeTimerId), this.incallModeTimerId = void 0);
                        }, t.prototype.applyConnectionTrackerOptions = function(t) {
                            try {
                                t.eventLogger && "function" == typeof t.eventLogger.logEvent ? (this.connectionTracker.mergeSettings(t.telemetrySettings), this.connectionTracker.enable(t.eventLogger)) : this.logger.warn("Trouter client event logging disabled due to invalid configuration.");
                            } catch (t) {
                                this.logger.warn("Trouter client event logging disabled. Error: " + i.toJson(t.stack)), this.connectionTracker.disable();
                            }
                        }, t.prototype.createUserActivityObject = function(t) {
                            var e;
                            switch(t){
                                case u.UserActivityState.Active:
                                    e = "active";
                                    break;
                                case u.UserActivityState.Inactive:
                                    e = "inactive";
                                    break;
                                case u.UserActivityState.Unknown:
                                    e = "unknown";
                                    break;
                                default:
                                    e = "undefined";
                            }
                            return {
                                state: e
                            };
                        }, t;
                    }();
                    e.TrouterConnection = k;
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o, r = n(1), i = n(5), s = n(0);
                    !function(t) {
                        t[t.Initial = 0] = "Initial", t[t.RetrievingToken = 1] = "RetrievingToken", t[t.Allocating = 2] = "Allocating", t[t.Handshaking = 3] = "Handshaking", t[t.Connecting = 4] = "Connecting", t[t.Connected = 5] = "Connected", t[t.UnregisteringRetrievingToken = 6] = "UnregisteringRetrievingToken", t[t.Unregistering = 7] = "Unregistering";
                    }(o = e.State || (e.State = {}));
                    var c;
                    !function(t) {
                        t[t.Initial = 0] = "Initial", t[t.RetrievingToken = 1] = "RetrievingToken", t[t.Registering = 2] = "Registering", t[t.Registered = 3] = "Registered", t[t.NotRegistered = 4] = "NotRegistered";
                    }(c || (c = {}));
                    var a = function() {
                        function t(t, e, n) {
                            this.worker = e, this.incallModeEnabled = n, this.state = o.Initial, this.connectionErrors = 0, this.logger = new s.Logger("ConnectionFsm", t), this.connectedSubstate = c.Initial, this.userActivityState = r.UserActivityState.Unknown;
                        }
                        return t.prototype.getState = function() {
                            return this.state;
                        }, t.prototype.isActive = function() {
                            return this.state === o.Allocating || this.state === o.Connected || this.state === o.Handshaking || this.state === o.Connecting || this.state === o.RetrievingToken;
                        }, t.prototype.start = function() {
                            return this.state === o.Initial ? (this.setState(o.RetrievingToken), this.worker.getToken(!0, !1), !0) : (this.showIgnored("start"), !1);
                        }, t.prototype.stop = function(t) {
                            t && (this.connectedSubstate = c.Initial), this.worker.isIncallMode() && this.worker.exitIncallMode(), this.worker.resetTokenBackoff(), this.worker.resetRegisterBackoff(), this.worker.stopConnectionTimer(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.state !== o.Connecting && this.state !== o.Handshaking && this.state !== o.Connected || this.worker.stopSocketIo(), this.isRegistered() ? (this.setState(o.UnregisteringRetrievingToken), this.worker.stopRegisterTimer(), this.worker.getToken(!0, !1)) : (this.setState(o.Initial), this.worker.dispatchDisconnected());
                        }, t.prototype.onTokenReceived = function(t) {
                            this.state === o.RetrievingToken ? (this.setState(o.Allocating), this.worker.startConnectionTimer(), this.worker.sendAllocateRequest(t)) : this.state === o.Connected && this.connectedSubstate === c.RetrievingToken ? (this.connectedSubstate = c.Registering, this.worker.sendRegisterRequest()) : this.state === o.UnregisteringRetrievingToken ? (this.setState(o.Unregistering), this.worker.sendUnregisterRequest()) : this.showIgnored("onTokenReceived");
                        }, t.prototype.checkConnection = function(t) {
                            t && this.onPingInterval();
                        }, t.prototype.onAllocationSucceed = function() {
                            return this.state === o.Allocating ? (this.setState(o.Handshaking), this.connectedSubstate = c.Initial, this.worker.startSocketIo(), !0) : (this.showIgnored("onAllocationSucceed"), !1);
                        }, t.prototype.onAllocationFailed = function(t) {
                            this.state === o.Allocating ? (this.setState(o.RetrievingToken), this.worker.stopConnectionTimer(), this.worker.getToken(!t, !0)) : this.showIgnored("onAllocationFailed");
                        }, t.prototype.onConnectingTimeout = function() {
                            this.state === o.Allocating || this.state === o.Connecting || this.state === o.Handshaking ? (this.setState(o.RetrievingToken), this.resetAllocationIfNecessary(void 0), this.worker.stopSocketIo(), this.worker.getToken(!0, !1)) : this.showIgnored("onConnectingTimeout");
                        }, t.prototype.onConnecting = function() {
                            this.state === o.Handshaking ? this.setState(o.Connecting) : this.showIgnored("onConnecting");
                        }, t.prototype.onConnectingFailed = function() {
                            this.state === o.Connecting ? this.onConnectingTimeout() : this.state === o.Handshaking ? (this.logger.error("Unexpected error in Socket.io - no valid transports"), this.onConnectingTimeout()) : this.showIgnored("onConnectingFailed");
                        }, t.prototype.onSocketError = function(t) {
                            this.state === o.Handshaking || this.state === o.Connected ? (this.worker.stopSocketIo(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopConnectionTimer(), this.state !== o.Connected && this.worker.resetAllocationConnectionParams(), this.setState(o.RetrievingToken), this.worker.dispatchReconnecting(), this.worker.getToken(!0, !1)) : this.showIgnored("onSocketError");
                        }, t.prototype.onTrouterConnected = function() {
                            this.state === o.Connecting ? (this.setState(o.Connected), this.worker.resetTokenBackoff(), this.worker.stopConnectionTimer(), this.worker.sendUserActivityState(i.UserActivityEventReason.Connected, !0), this.worker.startPingTimer(), this.worker.dispatchConnected(), this.connectionErrors = 0, this.worker.shouldSkipRegistration() ? (this.connectedSubstate = c.NotRegistered, this.worker.dispatchRegistered()) : (this.connectedSubstate = c.RetrievingToken, this.worker.getToken(!0, !1))) : this.showIgnored("onTrouterConnected");
                        }, t.prototype.onReconnectRequired = function() {
                            this.worker.dispatchReconnectIsRequired();
                        }, t.prototype.onDownstreamRequest = function(t) {
                            this.state === o.Connected ? (this.switchToIncallModeIfEnabled(), this.worker.dispatchDownstreamRequest(t)) : this.showIgnored("onDownstreamRequest");
                        }, t.prototype.onTrouterMessageLost = function(t) {
                            this.state === o.Connected ? this.worker.dispatchTrouterMessageLost(t) : this.showIgnored("onTrouterMessageLost");
                        }, t.prototype.onPingInterval = function() {
                            this.state === o.Connected ? this.worker.sendPingRequest() : this.showIgnored("onPingInterval");
                        }, t.prototype.onPingResponseTimeout = function() {
                            this.onMissedResponse("onPingResponseTimeout");
                        }, t.prototype.onPingResponse = function() {
                            this.state === o.Connected || this.showIgnored("onPingResponse");
                        }, t.prototype.onRegistrationFailed = function(t) {
                            this.state === o.Connected && this.connectedSubstate === c.Registering ? (this.connectedSubstate = c.RetrievingToken, this.worker.getToken(!t, !0)) : this.showIgnored("onRegistrationFailed");
                        }, t.prototype.onRegistrationSucceed = function() {
                            this.state === o.Connected ? (this.connectedSubstate === c.Registering && (this.connectedSubstate = c.Registered, this.worker.dispatchRegistered()), this.worker.hasCustomRegisterTtl() && this.worker.startRegisterTimer()) : this.showIgnored("onRegistrationSucceed");
                        }, t.prototype.onRegistrationTimeout = function() {
                            this.state === o.Connected && this.connectedSubstate !== c.NotRegistered ? (this.connectedSubstate = c.RetrievingToken, this.worker.getToken(!0, !1)) : this.showIgnored("onRegistrationTimeout");
                        }, t.prototype.onUnregistrationFailed = function(t) {
                            this.state === o.Unregistering ? (this.setState(o.UnregisteringRetrievingToken), this.worker.getToken(!t, !t)) : this.showIgnored("onUnregistrationFailed");
                        }, t.prototype.onUnregistrationSucceed = function() {
                            this.state === o.Unregistering ? (this.setState(o.Initial), this.worker.dispatchDisconnected()) : this.showIgnored("onUnregistrationSucceed");
                        }, t.prototype.onIncallModeTimer = function() {
                            this.worker.exitIncallMode(), this.state === o.Connected ? (this.worker.stopPingTimer(), this.worker.startPingTimer()) : this.showIgnored("onIncallModeTimer");
                        }, t.prototype.onSetUserActivityState = function(t, e) {
                            e ? (this.logger.info("Changing user activity state to '" + r.UserActivityState[t] + "'"), this.worker.sendUserActivityState(i.UserActivityEventReason.Modified, this.state === o.Connected)) : this.logger.debug("Not changing the same user activity state '" + r.UserActivityState[t] + "'");
                        }, t.prototype.onActivityStateResponseTimeout = function() {
                            this.onMissedResponse("onActivityStateResponseTimeout");
                        }, t.prototype.forceReconnect = function() {
                            this.setState(o.RetrievingToken), this.worker.resetTokenBackoff(), this.worker.stopConnectionTimer(), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopSocketIo(), this.worker.dispatchReconnecting(), this.worker.getToken(!0, !1);
                        }, t.prototype.onMissedResponse = function(t) {
                            this.state === o.Connected ? (this.setState(o.RetrievingToken), this.worker.stopPingTimer(), this.worker.clearTimers(), this.worker.stopSocketIo(), this.worker.dispatchReconnecting(), this.worker.getToken(!0, !1)) : this.showIgnored(t);
                        }, t.prototype.showIgnored = function(t) {
                            this.logger.debug("Ignoring event '" + t + "' in state '" + o[this.state] + "'");
                        }, t.prototype.setState = function(t) {
                            if (this.logger.info("Switching from state '" + o[this.state] + "' to state '" + o[t] + "'"), this.state === t) return void this.logger.error("Attempt to switching into the current state '" + o[t] + "'");
                            this.state = t;
                        }, t.prototype.resetAllocationIfNecessary = function(t) {
                            this.connectionErrors++, this.connectionErrors >= 2 || void 0 !== t && /^4\d\d /.test(t) ? (this.logger.error("Connection error count is " + this.connectionErrors + " - will reset allocation"), this.connectionErrors = 0) : this.logger.info("Connection error count is " + this.connectionErrors + " - will NOT reset allocation");
                        }, t.prototype.isRegistered = function() {
                            return this.connectedSubstate === c.Registered || this.connectedSubstate === c.Registering;
                        }, t.prototype.switchToIncallModeIfEnabled = function() {
                            this.incallModeEnabled && (this.worker.isIncallMode() || (this.worker.enterIncallMode(), this.worker.stopPingTimer(), this.worker.startPingTimer()), this.worker.restartIncallModeTimer());
                        }, t;
                    }();
                    e.TrouterFsm = a;
                },
                function(t, e, n) {
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var o = n(1), r = n(0), i = function() {
                        function t(t, e) {
                            this.worker = e, this.state = o.TrouterState.Unknown, this.logger = new r.Logger("ManagerFsm", t);
                        }
                        return t.prototype.start = function() {
                            this.state === o.TrouterState.Unknown ? (this.setState(o.TrouterState.Disconnected), this.worker.startFirstConnection()) : this.showIgnored("start");
                        }, t.prototype.stop = function() {
                            this.state !== o.TrouterState.Unknown ? (this.setState(o.TrouterState.Unknown), this.worker.stopFirstConnection(!1), this.worker.stopSecondConnection(!1)) : this.showIgnored("stop");
                        }, t.prototype.getState = function() {
                            return this.state;
                        }, t.prototype.onConnected = function(t) {
                            this.state === o.TrouterState.Disconnected && t ? this.worker.doesSecondConnectionExist() ? this.setState(o.TrouterState.Switching) : (this.setState(o.TrouterState.Connected), this.worker.dispatchConnected()) : this.showIgnored("onConnected(" + t + ")");
                        }, t.prototype.onRegistered = function(t) {
                            this.state !== o.TrouterState.Disconnected || t ? this.state !== o.TrouterState.Switching || t ? this.showIgnored("onRegistered(" + t + ")") : (this.setState(o.TrouterState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnectionDelayed(), this.worker.dispatchConnected()) : (this.setState(o.TrouterState.Connected), this.worker.switchConnections(), this.worker.stopSecondConnection(!0), this.worker.dispatchConnected());
                        }, t.prototype.onReconnecting = function(t) {
                            this.state === o.TrouterState.Connected && t ? (this.setState(o.TrouterState.Disconnected), this.worker.dispatchReconnecting()) : this.state === o.TrouterState.Switching && t ? (this.setState(o.TrouterState.Disconnected), this.worker.dispatchReconnecting()) : this.showIgnored("onReconnecting(" + t + ")");
                        }, t.prototype.onReconnectionRequired = function(t) {
                            this.state === o.TrouterState.Connected && t ? (this.setState(o.TrouterState.Switching), this.worker.startSecondConnection()) : this.state === o.TrouterState.Disconnected && t ? this.worker.startSecondConnection() : this.showIgnored("onReconnectionRequired(" + t + ")");
                        }, t.prototype.onDisconnected = function(t) {
                            this.state === o.TrouterState.Unknown && t ? this.worker.dispatchStopped() : this.showIgnored("onDisconnected(" + t + ")");
                        }, t.prototype.showIgnored = function(t) {
                            this.logger.info("Ignoring event '" + t + "' in state '" + o.TrouterState[this.state] + "'");
                        }, t.prototype.setState = function(t) {
                            if (this.logger.info("Switching from state '" + o.TrouterState[this.state] + "' to state '" + o.TrouterState[t] + "'"), this.state === t) return void this.logger.error("Attempt to switching into the current state '" + o.TrouterState[t] + "'");
                            this.state = t;
                        }, t;
                    }();
                    e.TrouterManagerFsm = i;
                },
                function(t, e, n) {
                    function o(t, e) {
                        if (!e) return t;
                        var n = a({}, t, {
                            enabled: e.TelemetryEnabled
                        });
                        return void 0 !== e.ClientTelemetryEventEnabled && (n = a({}, n, e.ClientTelemetryEventEnabled)), n;
                    }
                    function r(t, e) {
                        return {
                            clientInfo: {
                                ua: t.trouterSettings.productName,
                                v: t.trouterSettings.version
                            },
                            ioOptions: {
                                ackTimeoutMs: 5e3
                            },
                            clientCorrelationID: t.trouterSettings.sessionId,
                            environment: t.trouterSettings.environment,
                            telemetrySettings: o(t.telemetryConfig.settings, e),
                            eventLogger: t.telemetryConfig.eventLogger,
                            endpointId: t.trouterSettings.registrationId,
                            trouterUrl: e && e.TrouterConnectionUrl || t.trouterSettings.trouterServiceUrl,
                            registration: t.trouterSettings.registrarServiceUrl ? {
                                registrarUrl: t.trouterSettings.registrarServiceUrl,
                                registrationId: t.trouterSettings.registrationId || "",
                                pnhAppId: t.trouterSettings.pnhAppId || "",
                                platform: t.trouterSettings.platform || "",
                                pnhTemplateKey: t.trouterSettings.pnhTemplate || "",
                                platformUIVersion: t.trouterSettings.platformUIVersion || "",
                                productContext: t.trouterSettings.pnhProductContext || void 0,
                                context: t.trouterSettings.pnhContext || "",
                                registrarTtlSec: (t.trouterSettings.maxRegistrationTimeInMs || 0) / 1e3
                            } : void 0,
                            timeoutOptions: a({
                                connectionTimeoutMs: t.trouterSettings.trouterConnectTimeoutInMs || 3e4,
                                fetchTimeoutMs: 1e4,
                                pingTimeoutMs: 4e4,
                                pongTimeoutMs: 5e3,
                                maxBackoffMs: 3e4,
                                requestTimeoutMs: 5e3,
                                userActivityResponseTimeoutMs: 1e4
                            }, t.trouterSettings.timeoutOptions),
                            incallTimeoutOptions: a({
                                connectionTimeoutMs: 1e4,
                                fetchTimeoutMs: 5e3,
                                pingTimeoutMs: 5e3,
                                pongTimeoutMs: 2e3,
                                maxBackoffMs: 1e4,
                                requestTimeoutMs: 5e3,
                                userActivityResponseTimeoutMs: 1e4
                            }, t.trouterSettings.incallTimeoutOptions),
                            incallModeTimeoutMs: t.trouterSettings.incallModeTimeoutMs || 0,
                            lingeringConnectionDelayMs: 6e4,
                            userActivitySecondResendDelayMs: t.trouterSettings.userActivitySecondResendDelayMs || 1e4
                        };
                    }
                    function i(t) {
                        return new y(t);
                    }
                    function s() {
                        return l.CLIENT_VERSION;
                    }
                    function c(t, e) {
                        var n = t.indexOf("://");
                        if (n >= 0) {
                            var o = t.indexOf("/", n + 3);
                            if (o >= 0) return e + t.substr(o);
                        }
                        return "";
                    }
                    var a = this && this.__assign || Object.assign || function(t) {
                        for(var e, n = 1, o = arguments.length; n < o; n++){
                            e = arguments[n];
                            for(var r in e)Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                        }
                        return t;
                    }, u = this && this.__awaiter || function(t, e, n, o) {
                        return new (n || (n = Promise))(function(r, i) {
                            function s(t) {
                                try {
                                    a(o.next(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function c(t) {
                                try {
                                    a(o.throw(t));
                                } catch (t) {
                                    i(t);
                                }
                            }
                            function a(t) {
                                t.done ? r(t.value) : new n(function(e) {
                                    e(t.value);
                                }).then(s, c);
                            }
                            a((o = o.apply(t, e || [])).next());
                        });
                    }, h = this && this.__generator || function(t, e) {
                        function n(t) {
                            return function(e) {
                                return o([
                                    t,
                                    e
                                ]);
                            };
                        }
                        function o(n) {
                            if (r) throw new TypeError("Generator is already executing.");
                            for(; a;)try {
                                if (r = 1, i && (s = 2 & n[0] ? i.return : n[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, n[1])).done) return s;
                                switch(i = 0, s && (n = [
                                    2 & n[0],
                                    s.value
                                ]), n[0]){
                                    case 0:
                                    case 1:
                                        s = n;
                                        break;
                                    case 4:
                                        return a.label++, {
                                            value: n[1],
                                            done: !1
                                        };
                                    case 5:
                                        a.label++, i = n[1], n = [
                                            0
                                        ];
                                        continue;
                                    case 7:
                                        n = a.ops.pop(), a.trys.pop();
                                        continue;
                                    default:
                                        if (s = a.trys, !(s = s.length > 0 && s[s.length - 1]) && (6 === n[0] || 2 === n[0])) {
                                            a = 0;
                                            continue;
                                        }
                                        if (3 === n[0] && (!s || n[1] > s[0] && n[1] < s[3])) {
                                            a.label = n[1];
                                            break;
                                        }
                                        if (6 === n[0] && a.label < s[1]) {
                                            a.label = s[1], s = n;
                                            break;
                                        }
                                        if (s && a.label < s[2]) {
                                            a.label = s[2], a.ops.push(n);
                                            break;
                                        }
                                        s[2] && a.ops.pop(), a.trys.pop();
                                        continue;
                                }
                                n = e.call(t, a);
                            } catch (t) {
                                n = [
                                    6,
                                    t
                                ], i = 0;
                            } finally{
                                r = s = 0;
                            }
                            if (5 & n[0]) throw n[1];
                            return {
                                value: n[0] ? n[1] : void 0,
                                done: !0
                            };
                        }
                        var r, i, s, c, a = {
                            label: 0,
                            sent: function() {
                                if (1 & s[0]) throw s[1];
                                return s[1];
                            },
                            trys: [],
                            ops: []
                        };
                        return c = {
                            next: n(0),
                            throw: n(1),
                            return: n(2)
                        }, "function" == typeof Symbol && (c[Symbol.iterator] = function() {
                            return this;
                        }), c;
                    };
                    Object.defineProperty(e, "__esModule", {
                        value: !0
                    });
                    var l = n(2), p = n(1);
                    e.TrouterState = p.TrouterState, e.UserActivityState = p.UserActivityState;
                    var d = n(0), f = n(6), g = n(7), m = n(8), v = n(9), y = function() {
                        function t(t) {
                            this.logProvider = t, this.stateChangedListeners = [], this.logger = new d.Logger("Trouter", t), this.trouterUrlPromise = new v.TrouterUrlPromise(t), this.messageHandlers = new f.MessageHandlerRegistry(t), this.listeners = {}, this.connectionInfo = null, this.logger.info("Created TrouterService version " + l.CLIENT_VERSION);
                        }
                        return t.prototype.start = function(t) {
                            if (this.logger.info("Start"), !t.trouterSettings.disableInternalSkypeTokenCache) {
                                var e = t.skypeTokenProvider;
                                t.skypeTokenProvider = g.addCacheAsBackupTo(e);
                            }
                            this.trouterCfg = t;
                            var n = r(t, this.ecsCfg);
                            void 0 === this.trouterServer && (this.trouterServer = new m.TrouterManager(this.logProvider, n, t.skypeTokenProvider, this)), this.trouterServer.start();
                        }, t.prototype.stop = function() {
                            this.logger.info("close connection"), this.trouterUrlPromise.rejectUrl(new Error("TrouterService is stopped")), void 0 !== this.trouterServer && this.trouterServer.stop();
                        }, t.prototype.setEcsConfig = function(t) {
                            return u(this, void 0, void 0, function() {
                                var e = this;
                                return h(this, function(n) {
                                    return [
                                        2,
                                        new Promise(function(n, o) {
                                            if (e.ecsCfg = t.TrouterJScriptClient, e.logger.info("Setting ECS configuration to " + JSON.stringify(e.ecsCfg)), void 0 !== e.trouterServer && void 0 !== e.trouterCfg) {
                                                var i = r(e.trouterCfg, e.ecsCfg);
                                                e.trouterServer.configure(i);
                                            }
                                            n();
                                        })
                                    ];
                                });
                            });
                        }, t.prototype.checkConnection = function(t) {
                            void 0 !== this.trouterServer && this.trouterServer.checkConnection(t || !1);
                        }, t.prototype.resendRegistration = function() {
                            return u(this, void 0, void 0, function() {
                                return h(this, function(t) {
                                    if (!this.trouterServer) throw new Error("resendRegistration called too early");
                                    return [
                                        2,
                                        this.trouterServer.resendRegistration()
                                    ];
                                });
                            });
                        }, t.prototype.registerListener = function(t, e) {
                            return "" === e || "/" !== e[0] || e.indexOf("?") >= 0 || e.indexOf("#") >= 0 ? (this.logger.error("Listener path '" + e + "' is not valid"), !1) : this.listeners[e] ? (this.logger.error("Another listener is already registered for path '" + e + "'"), !1) : (this.listeners[e] = t, this.logger.debug("Listener for path '" + e + "' registered"), this.connectionInfo && t.onTrouterConnected(this.connectionInfo.baseEndpointUrl + e, this.connectionInfo), !0);
                        }, t.prototype.unregisterListener = function(t) {
                            for(var e = [], n = 0, o = Object.keys(this.listeners); n < o.length; n++){
                                var r = o[n];
                                this.listeners[r] === t && e.push(r);
                            }
                            if (0 === e.length) return !1;
                            for(var i = 0, s = e; i < s.length; i++){
                                var r = s[i];
                                delete this.listeners[r];
                            }
                            return this.logger.debug("Listener for path(s) '" + e.join("', '") + "' unregistered"), !0;
                        }, t.prototype.onTrouterConnected = function(t, e) {
                            this.logger.debug("Trouter is now connected");
                            for(var n = 0, o = Object.keys(this.listeners); n < o.length; n++){
                                var r = o[n];
                                try {
                                    this.listeners[r].onTrouterConnected(e.baseEndpointUrl + r, e);
                                } catch (t) {
                                    this.logger.error("Listener '" + r + "' threw an exception from onTrouterConnected(): " + t);
                                }
                            }
                            this.connectionInfo = e, this.trouterUrlPromise.resolveUrl(t), this.notifyStateChanged(p.TrouterState.Connected, {
                                url: t,
                                getRemainingTtlInSec: function() {
                                    return e.connectionTtlSec;
                                }
                            });
                        }, t.prototype.onTrouterDisconnected = function() {
                            this.logger.debug("Trouter is now disconnected"), this.connectionInfo = null;
                            for(var t = 0, e = Object.keys(this.listeners); t < e.length; t++){
                                var n = e[t], o = this.listeners[n].onTrouterDisconnected;
                                if (o) try {
                                    o();
                                } catch (t) {
                                    this.logger.error("Listener '" + n + "' threw an exception from onTrouterDisconnected(): " + t);
                                }
                            }
                            this.notifyStateChanged(p.TrouterState.Disconnected);
                        }, t.prototype.onTrouterRequest = function(t, e) {
                            for(var n = "", o = 0, r = Object.keys(this.listeners); o < r.length; o++){
                                var i = r[o];
                                t.path.substring(0, i.length) === i && i.length > n.length && (n = i);
                            }
                            if ("" === n) this.tryMessageHandlers(t, e) || (e.status = 404, e.headers = {
                                "Trouter-Responder": "ClientLib"
                            }, e.send());
                            else try {
                                this.listeners[n].onTrouterRequest(t, e);
                            } catch (t) {
                                this.logger.error("Listener '" + n + "' threw an exception from onTrouterRequest(): " + t), e.status = 500, e.headers = {
                                    "Trouter-Responder": "ClientLib"
                                }, e.send();
                            }
                        }, t.prototype.onTrouterMessageLoss = function(t) {
                            this.logger.info("onTrouterMessageLoss called with value " + t);
                            for(var e = !0, n = 0, o = Object.keys(this.listeners); n < o.length; n++){
                                var r = o[n], i = this.listeners[r].onTrouterMessageLoss;
                                if (i) try {
                                    e = i(t) && e, void 0 === e && (this.logger.error("Listener '" + r + "' did not response with boolean value onTrouterMessageLoss()"), e = !1);
                                } catch (t) {
                                    this.logger.error("Listener '" + r + "' threw an exception from onTrouterMessageLoss(): " + t), e = !1;
                                }
                            }
                            return e;
                        }, t.prototype.setUserActivityState = function(t) {
                            if (t !== p.UserActivityState.Active && t !== p.UserActivityState.Inactive) throw new Error("setUserActivityState called with unsupported value " + t);
                            if (this.logger.info("setUserActivityState called with value " + p.UserActivityState[t]), !this.trouterServer || this.state() === p.TrouterState.Unknown) throw new Error("setUserActivityState called too early");
                            this.trouterServer.setUserActivityState(t);
                        }, t.prototype.state = function() {
                            return void 0 !== this.trouterServer ? this.trouterServer.getState() : p.TrouterState.Unknown;
                        }, t.prototype.getServerState = function() {
                            if (void 0 !== this.trouterServer) return this.trouterServer.getServerState();
                        }, t.prototype.getTrouterUrlAsync = function() {
                            return void 0 !== this.trouterServer ? this.trouterUrlPromise.getPromise() : Promise.reject(new Error("TrouterService has not been started"));
                        }, t.prototype.onStateChanged = function(t) {
                            if (this.logger.info("onStateChanged called"), void 0 === t) this.stateChangedListeners = this.stateChangedListeners.filter(function(t) {
                                return void 0 === t.wrappedCallback;
                            });
                            else {
                                this.offStateChanged(t);
                                var e = function(e, n) {
                                    t(e, n ? n.url : "");
                                };
                                e.wrappedCallback = t, this.stateChangedListeners.push(e);
                            }
                        }, t.prototype.offStateChanged = function(t) {
                            this.logger.info("offStateChanged called");
                            var e = this.stateChangedListeners.length;
                            return this.stateChangedListeners = this.stateChangedListeners.filter(function(e) {
                                return e.wrappedCallback !== t;
                            }), e > this.stateChangedListeners.length;
                        }, t.prototype.addCallback = function(t) {
                            this.logger.info("addListener called"), -1 === this.stateChangedListeners.indexOf(t, 0) && void 0 !== t && this.stateChangedListeners.push(t);
                        }, t.prototype.removeCallback = function(t) {
                            this.logger.info("removeListener called");
                            var e = this.stateChangedListeners.indexOf(t, 0);
                            return e > -1 && (this.stateChangedListeners.splice(e, 1), !0);
                        }, t.prototype.registerMessageHandler = function(t) {
                            this.logger.info("registerMessageHandler is called"), this.messageHandlers.register(t);
                        }, t.prototype.clearMessageHandlers = function() {
                            this.logger.info("clearMessageHandlers is called"), this.messageHandlers.clear();
                        }, t.prototype.notifyStateChanged = function(t, e) {
                            var n = this;
                            this.logger.info("notifyStateChanged called, will forward to " + this.stateChangedListeners.length + " listeners"), this.stateChangedListeners.forEach(function(o) {
                                try {
                                    o(t, e);
                                } catch (t) {
                                    n.logger.error("Error in callback " + t);
                                }
                            });
                        }, t.prototype.tryMessageHandlers = function(t, e) {
                            if (!this.messageHandlers.active()) return !1;
                            var n, o = null;
                            try {
                                n = JSON.parse(t.body), o = n && (n.evt || n.eventId) || null;
                            } catch (t) {}
                            var r = {
                                eventId: o,
                                url: (this.connectionInfo ? this.connectionInfo.baseEndpointUrl : "") + t.path,
                                body: n,
                                rawBody: t.body,
                                headers: t.headers
                            }, i = this.messageHandlers.handleMessage(r);
                            return !!i.isHandled && (e.status = i.resultCode, i.responseHeaders && (e.headers = i.responseHeaders), i.responseBody && (e.body = i.responseBody), e.send(), !0);
                        }, t;
                    }();
                    e.TrouterService = y, e.createTrouterService = i, e.getTrouterServiceVersion = s, e.replaceTrouterUrlBase = c;
                },
                function(t, e) {
                    t.exports = __WEBPACK_EXTERNAL_MODULE_20__;
                },
                function(t, e) {}
            ]);
        });
    });
    unwrapExports(tstrouter);
    var TrouterUtils = createCommonjsModule(function(module1, exports) {
        // Copyright (c) Microsoft Corporation.
        // Licensed under the MIT license.
        exports.__esModule = true;
        var eventIds = new Map([
            [
                "chatMessageReceived",
                200
            ],
            [
                "typingIndicatorReceived",
                245
            ],
            [
                "readReceiptReceived",
                246
            ],
            [
                "chatMessageEdited",
                247
            ],
            [
                "chatMessageDeleted",
                248
            ],
            [
                "chatThreadCreated",
                257
            ],
            [
                "chatThreadPropertiesUpdated",
                258
            ],
            [
                "chatThreadDeleted",
                259
            ],
            [
                "participantsAdded",
                260
            ],
            [
                "participantsRemoved",
                261
            ]
        ]);
        var publicTeamsUserPrefix = '8:orgid:';
        var dodTeamsUserPrefix = '8:dod:';
        var gcchTeamsUserPrefix = '8:gcch:';
        var teamsVisitorUserPrefix = '8:teamsvisitor:';
        var phoneNumberPrefix = '4:';
        var acsUserPrefix = '8:acs:';
        var spoolUserPrefix = '8:spool:';
        exports.toMessageHandler = function(event, listener) {
            var eventId = eventIds.get(event);
            return {
                handleMessage: function(message) {
                    var genericPayload = null;
                    if (message === null || message === void 0 ? void 0 : message.rawBody) genericPayload = JSON.parse(message.rawBody);
                    if (genericPayload === null || genericPayload._eventId !== eventId) return undefined;
                    var eventPayload = toEventPayload(event, genericPayload);
                    if (eventPayload === null) return undefined;
                    listener(eventPayload);
                    return {
                        isHandled: true,
                        resultCode: 200
                    };
                }
            };
        };
        var toEventPayload = function(event, genericPayload) {
            if (event === "chatMessageReceived") {
                var payload = genericPayload;
                var eventPayload = {
                    threadId: payload.groupId,
                    sender: constructIdentifierKindFromMri(payload.senderId),
                    senderDisplayName: payload.senderDisplayName,
                    recipient: constructIdentifierKindFromMri("8:" + payload.recipientId),
                    id: payload.messageId,
                    createdOn: new Date(payload.originalArrivalTime),
                    version: payload.version,
                    type: payload.messageType,
                    message: payload.messageBody
                };
                return eventPayload;
            }
            if (event === "chatMessageEdited") {
                var payload = genericPayload;
                var eventPayload = {
                    threadId: payload.groupId,
                    sender: constructIdentifierKindFromMri(payload.senderId),
                    senderDisplayName: payload.senderDisplayName,
                    recipient: constructIdentifierKindFromMri("8:" + payload.recipientId),
                    id: payload.messageId,
                    createdOn: new Date(payload.originalArrivalTime),
                    version: payload.version,
                    message: payload.messageBody,
                    editedOn: new Date(payload.edittime),
                    type: payload.messageType
                };
                return eventPayload;
            }
            if (event === "chatMessageDeleted") {
                var payload = genericPayload;
                var eventPayload = {
                    threadId: payload.groupId,
                    sender: constructIdentifierKindFromMri(payload.senderId),
                    senderDisplayName: payload.senderDisplayName,
                    recipient: constructIdentifierKindFromMri("8:" + payload.recipientId),
                    id: payload.messageId,
                    createdOn: new Date(payload.originalArrivalTime),
                    version: payload.version,
                    deletedOn: new Date(payload.deletetime),
                    type: payload.messageType
                };
                return eventPayload;
            }
            if (event === "typingIndicatorReceived") {
                var payload = genericPayload;
                var eventPayload = {
                    threadId: payload.groupId,
                    sender: constructIdentifierKindFromMri(payload.senderId),
                    senderDisplayName: "",
                    recipient: constructIdentifierKindFromMri("8:" + payload.recipientId),
                    version: payload.version,
                    receivedOn: new Date(payload.originalArrivalTime)
                };
                return eventPayload;
            }
            if (event === "readReceiptReceived") {
                var payload = genericPayload;
                var readReceiptMessageBody = JSON.parse(payload.messageBody);
                var consumptionHorizon = readReceiptMessageBody.consumptionhorizon.split(";");
                var eventPayload = {
                    threadId: payload.groupId,
                    sender: constructIdentifierKindFromMri(payload.senderId),
                    senderDisplayName: "",
                    recipient: constructIdentifierKindFromMri("8:" + payload.recipientId),
                    chatMessageId: payload.messageId,
                    readOn: new Date(+consumptionHorizon[1])
                };
                return eventPayload;
            }
            if (event === "chatThreadCreated") {
                var payload = genericPayload;
                var createdByPayload = JSON.parse(unescape(payload.createdBy));
                var membersPayload = JSON.parse(unescape(payload.members));
                var propertiesPayload = JSON.parse(unescape(payload.properties));
                var createdBy = {
                    id: constructIdentifierKindFromMri(createdByPayload.participantId),
                    displayName: createdByPayload.displayName
                };
                var chatParticipants = membersPayload.map(function(m) {
                    return {
                        id: constructIdentifierKindFromMri(m.participantId),
                        displayName: m.displayName
                    };
                });
                var eventPayload = {
                    threadId: payload.threadId,
                    createdOn: new Date(payload.createTime),
                    createdBy: createdBy,
                    version: payload.version,
                    participants: chatParticipants,
                    properties: propertiesPayload
                };
                return eventPayload;
            }
            if (event === "chatThreadPropertiesUpdated") {
                var payload = genericPayload;
                var updatedByPayload = JSON.parse(unescape(payload.editedBy));
                var propertiesPayload = JSON.parse(unescape(payload.properties));
                var updatedBy = {
                    id: constructIdentifierKindFromMri(updatedByPayload.participantId),
                    displayName: updatedByPayload.displayName
                };
                var eventPayload = {
                    threadId: payload.threadId,
                    updatedOn: new Date(payload.editTime),
                    updatedBy: updatedBy,
                    version: payload.version,
                    properties: propertiesPayload
                };
                return eventPayload;
            }
            if (event === "chatThreadDeleted") {
                var payload = genericPayload;
                var deletedByPayload = JSON.parse(unescape(payload.deletedBy));
                var deletedBy = {
                    id: constructIdentifierKindFromMri(deletedByPayload.participantId),
                    displayName: deletedByPayload.displayName
                };
                var eventPayload = {
                    threadId: payload.threadId,
                    deletedOn: new Date(payload.deleteTime),
                    deletedBy: deletedBy,
                    version: payload.version
                };
                return eventPayload;
            }
            if (event === "participantsAdded") {
                var payload = genericPayload;
                var addedByPayload = JSON.parse(unescape(payload.addedBy));
                var participantsAddedPayload = JSON.parse(unescape(payload.participantsAdded));
                var addedBy = {
                    id: constructIdentifierKindFromMri(addedByPayload.participantId),
                    displayName: addedByPayload.displayName
                };
                var chatParticipants = participantsAddedPayload.map(function(m) {
                    return {
                        id: constructIdentifierKindFromMri(m.participantId),
                        displayName: m.displayName,
                        shareHistoryTime: new Date(m.shareHistoryTime)
                    };
                });
                var eventPayload = {
                    threadId: payload.threadId,
                    addedOn: new Date(payload.time),
                    addedBy: addedBy,
                    version: payload.version,
                    participantsAdded: chatParticipants
                };
                return eventPayload;
            }
            if (event === "participantsRemoved") {
                var payload = genericPayload;
                var removedByPayload = JSON.parse(unescape(payload.removedBy));
                var participantsRemovedPayload = JSON.parse(unescape(payload.participantsRemoved));
                var removedBy = {
                    id: constructIdentifierKindFromMri(removedByPayload.participantId),
                    displayName: removedByPayload.displayName
                };
                var chatParticipants = participantsRemovedPayload.map(function(m) {
                    return {
                        id: constructIdentifierKindFromMri(m.participantId),
                        displayName: m.displayName,
                        shareHistoryTime: new Date(m.shareHistoryTime)
                    };
                });
                var eventPayload = {
                    threadId: payload.threadId,
                    removedOn: new Date(payload.time),
                    removedBy: removedBy,
                    version: payload.version,
                    participantsRemoved: chatParticipants
                };
                return eventPayload;
            }
            return null;
        };
        exports.toLogProvider = function(logger) {
            return {
                log: function() {
                    var message = [];
                    for(var _i = 0; _i < arguments.length; _i++)message[_i] = arguments[_i];
                    return logger.info(message);
                },
                warn: function() {
                    var message = [];
                    for(var _i = 0; _i < arguments.length; _i++)message[_i] = arguments[_i];
                    return logger.warning(message);
                },
                error: function() {
                    var message = [];
                    for(var _i = 0; _i < arguments.length; _i++)message[_i] = arguments[_i];
                    return logger.error(message);
                },
                debug: function() {
                    var message = [];
                    for(var _i = 0; _i < arguments.length; _i++)message[_i] = arguments[_i];
                    return logger.verbose(message);
                },
                info: function() {
                    var message = [];
                    for(var _i = 0; _i < arguments.length; _i++)message[_i] = arguments[_i];
                    return logger.verbose(message);
                }
            };
        };
        exports.toTelemetrySender = function(logger) {
            return {
                logEvent: function(clientEvent) {
                    return logger.info(clientEvent);
                }
            };
        };
        var constructIdentifierKindFromMri = function(mri) {
            if (mri.startsWith(publicTeamsUserPrefix)) return {
                kind: "microsoftTeamsUser",
                rawId: mri,
                microsoftTeamsUserId: mri.substring(publicTeamsUserPrefix.length),
                isAnonymous: false,
                cloud: 'public'
            };
            else if (mri.startsWith(dodTeamsUserPrefix)) return {
                kind: "microsoftTeamsUser",
                rawId: mri,
                microsoftTeamsUserId: mri.substring(dodTeamsUserPrefix.length),
                isAnonymous: false,
                cloud: 'dod'
            };
            else if (mri.startsWith(gcchTeamsUserPrefix)) return {
                kind: "microsoftTeamsUser",
                rawId: mri,
                microsoftTeamsUserId: mri.substring(gcchTeamsUserPrefix.length),
                isAnonymous: false,
                cloud: 'gcch'
            };
            else if (mri.startsWith(teamsVisitorUserPrefix)) return {
                kind: "microsoftTeamsUser",
                rawId: mri,
                microsoftTeamsUserId: mri.substring(teamsVisitorUserPrefix.length),
                isAnonymous: true
            };
            else if (mri.startsWith(phoneNumberPrefix)) return {
                kind: "phoneNumber",
                rawId: mri,
                phoneNumber: mri.substring(phoneNumberPrefix.length)
            };
            else if (mri.startsWith(acsUserPrefix) || mri.startsWith(spoolUserPrefix)) return {
                kind: "communicationUser",
                communicationUserId: mri
            };
            else return {
                kind: "unknown",
                id: mri
            };
        };
    });
    unwrapExports(TrouterUtils);
    var TrouterUtils_1 = TrouterUtils.toMessageHandler;
    var TrouterUtils_2 = TrouterUtils.toLogProvider;
    var TrouterUtils_3 = TrouterUtils.toTelemetrySender;
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
	 * A collection of HttpHeaders that can be sent with a HTTP request.
	 */ function getHeaderKey(headerName) {
        return headerName.toLowerCase();
    }
    function isHttpHeadersLike(object) {
        if (!object || typeof object !== "object") return false;
        if (typeof object.rawHeaders === "function" && typeof object.clone === "function" && typeof object.get === "function" && typeof object.set === "function" && typeof object.contains === "function" && typeof object.remove === "function" && typeof object.headersArray === "function" && typeof object.headerValues === "function" && typeof object.headerNames === "function" && typeof object.toJson === "function") return true;
        return false;
    }
    /**
	 * A collection of HTTP header key/value pairs.
	 */ var HttpHeaders = /** @class */ function() {
        function HttpHeaders(rawHeaders) {
            this._headersMap = {};
            if (rawHeaders) for(var headerName in rawHeaders)this.set(headerName, rawHeaders[headerName]);
        }
        /**
	     * Set a header in this collection with the provided name and value. The name is
	     * case-insensitive.
	     * @param headerName The name of the header to set. This value is case-insensitive.
	     * @param headerValue The value of the header to set.
	     */ HttpHeaders.prototype.set = function(headerName, headerValue) {
            this._headersMap[getHeaderKey(headerName)] = {
                name: headerName,
                value: headerValue.toString()
            };
        };
        /**
	     * Get the header value for the provided header name, or undefined if no header exists in this
	     * collection with the provided name.
	     * @param headerName The name of the header.
	     */ HttpHeaders.prototype.get = function(headerName) {
            var header = this._headersMap[getHeaderKey(headerName)];
            return !header ? undefined : header.value;
        };
        /**
	     * Get whether or not this header collection contains a header entry for the provided header name.
	     */ HttpHeaders.prototype.contains = function(headerName) {
            return !!this._headersMap[getHeaderKey(headerName)];
        };
        /**
	     * Remove the header with the provided headerName. Return whether or not the header existed and
	     * was removed.
	     * @param headerName The name of the header to remove.
	     */ HttpHeaders.prototype.remove = function(headerName) {
            var result = this.contains(headerName);
            delete this._headersMap[getHeaderKey(headerName)];
            return result;
        };
        /**
	     * Get the headers that are contained this collection as an object.
	     */ HttpHeaders.prototype.rawHeaders = function() {
            var result = {};
            for(var headerKey in this._headersMap){
                var header = this._headersMap[headerKey];
                result[header.name.toLowerCase()] = header.value;
            }
            return result;
        };
        /**
	     * Get the headers that are contained in this collection as an array.
	     */ HttpHeaders.prototype.headersArray = function() {
            var headers = [];
            for(var headerKey in this._headersMap)headers.push(this._headersMap[headerKey]);
            return headers;
        };
        /**
	     * Get the header names that are contained in this collection.
	     */ HttpHeaders.prototype.headerNames = function() {
            var headerNames = [];
            var headers = this.headersArray();
            for(var i = 0; i < headers.length; ++i)headerNames.push(headers[i].name);
            return headerNames;
        };
        /**
	     * Get the header values that are contained in this collection.
	     */ HttpHeaders.prototype.headerValues = function() {
            var headerValues = [];
            var headers = this.headersArray();
            for(var i = 0; i < headers.length; ++i)headerValues.push(headers[i].value);
            return headerValues;
        };
        /**
	     * Get the JSON object representation of this HTTP header collection.
	     */ HttpHeaders.prototype.toJson = function() {
            return this.rawHeaders();
        };
        /**
	     * Get the string representation of this HTTP header collection.
	     */ HttpHeaders.prototype.toString = function() {
            return JSON.stringify(this.toJson());
        };
        /**
	     * Create a deep clone/copy of this HttpHeaders collection.
	     */ HttpHeaders.prototype.clone = function() {
            return new HttpHeaders(this.rawHeaders());
        };
        return HttpHeaders;
    }();
    /*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */ /* global Reflect, Promise */ var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function() {
        __assign = Object.assign || function __assign1(t) {
            for(var s, i = 1, n = arguments.length; i < n; i++){
                s = arguments[i];
                for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function") {
            for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
        }
        return t;
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
                resolve(value);
            });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
                try {
                    step(generator.next(value));
                } catch (e) {
                    reject(e);
                }
            }
            function rejected(value) {
                try {
                    step(generator["throw"](value));
                } catch (e) {
                    reject(e);
                }
            }
            function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = {
            label: 0,
            sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
            },
            trys: [],
            ops: []
        }, f, y, t, g;
        return g = {
            next: verb(0),
            "throw": verb(1),
            "return": verb(2)
        }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
        }), g;
        function verb(n) {
            return function(v) {
                return step([
                    n,
                    v
                ]);
            };
        }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while(_)try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [
                    op[0] & 2,
                    t.value
                ];
                switch(op[0]){
                    case 0:
                    case 1:
                        t = op;
                        break;
                    case 4:
                        _.label++;
                        return {
                            value: op[1],
                            done: false
                        };
                    case 5:
                        _.label++;
                        y = op[1];
                        op = [
                            0
                        ];
                        continue;
                    case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                            _ = 0;
                            continue;
                        }
                        if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                            _.label = op[1];
                            break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                            _.label = t[1];
                            t = op;
                            break;
                        }
                        if (t && _.label < t[2]) {
                            _.label = t[2];
                            _.ops.push(op);
                            break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                }
                op = body.call(thisArg, _);
            } catch (e) {
                op = [
                    6,
                    e
                ];
                y = 0;
            } finally{
                f = t = 0;
            }
            if (op[0] & 5) throw op[1];
            return {
                value: op[0] ? op[1] : void 0,
                done: true
            };
        }
    }
    function __spreadArrays() {
        for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
        for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
        return r;
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
	 * Encodes a string in base64 format.
	 * @param value the string to encode
	 */ function encodeString(value) {
        return btoa(value);
    }
    /**
	 * Encodes a byte array in base64 format.
	 * @param value the Uint8Aray to encode
	 */ function encodeByteArray(value) {
        var str = "";
        for(var i = 0; i < value.length; i++)str += String.fromCharCode(value[i]);
        return btoa(str);
    }
    /**
	 * Decodes a base64 string into a byte array.
	 * @param value the base64 string to decode
	 */ function decodeString(value) {
        var byteString = atob(value);
        var arr = new Uint8Array(byteString.length);
        for(var i = 0; i < byteString.length; i++)arr[i] = byteString.charCodeAt(i);
        return arr;
    }
    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    var getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
    var rnds8 = new Uint8Array(16);
    function rng() {
        if (!getRandomValues) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        return getRandomValues(rnds8);
    }
    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    function validate(uuid) {
        return typeof uuid === 'string' && REGEX.test(uuid);
    }
    /**
	 * Convert array of 16 byte values to UUID string format of the form:
	 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
	 */ var byteToHex = [];
    for(var i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).substr(1));
    function stringify(arr) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // Note: Be careful editing this code!  It's been tuned for performance
        // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
        var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
        // of the following:
        // - One or more input array values don't map to a hex octet (leading to
        // "undefined" in the uuid)
        // - Invalid input values for the RFC `version` or `variant` fields
        if (!validate(uuid)) throw TypeError('Stringified UUID is invalid');
        return uuid;
    }
    function v4(options, buf, offset) {
        options = options || {};
        var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
        rnds[6] = rnds[6] & 0x0f | 0x40;
        rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
        if (buf) {
            offset = offset || 0;
            for(var i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
            return buf;
        }
        return stringify(rnds);
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    var Constants = {
        /**
	     * The core-http version
	     * @const
	     * @type {string}
	     */ coreHttpVersion: "1.2.0",
        /**
	     * Specifies HTTP.
	     *
	     * @const
	     * @type {string}
	     */ HTTP: "http:",
        /**
	     * Specifies HTTPS.
	     *
	     * @const
	     * @type {string}
	     */ HTTPS: "https:",
        /**
	     * Specifies HTTP Proxy.
	     *
	     * @const
	     * @type {string}
	     */ HTTP_PROXY: "HTTP_PROXY",
        /**
	     * Specifies HTTPS Proxy.
	     *
	     * @const
	     * @type {string}
	     */ HTTPS_PROXY: "HTTPS_PROXY",
        /**
	     * Specifies NO Proxy.
	     *
	     * @const
	     * @type {string}
	     */ NO_PROXY: "NO_PROXY",
        /**
	     * Specifies ALL Proxy.
	     *
	     * @const
	     * @type {string}
	     */ ALL_PROXY: "ALL_PROXY",
        HttpConstants: {
            /**
	         * Http Verbs
	         *
	         * @const
	         * @enum {string}
	         */ HttpVerbs: {
                PUT: "PUT",
                GET: "GET",
                DELETE: "DELETE",
                POST: "POST",
                MERGE: "MERGE",
                HEAD: "HEAD",
                PATCH: "PATCH"
            },
            StatusCodes: {
                TooManyRequests: 429
            }
        },
        /**
	     * Defines constants for use with HTTP headers.
	     */ HeaderConstants: {
            /**
	         * The Authorization header.
	         *
	         * @const
	         * @type {string}
	         */ AUTHORIZATION: "authorization",
            AUTHORIZATION_SCHEME: "Bearer",
            /**
	         * The Retry-After response-header field can be used with a 503 (Service
	         * Unavailable) or 349 (Too Many Requests) responses to indicate how long
	         * the service is expected to be unavailable to the requesting client.
	         *
	         * @const
	         * @type {string}
	         */ RETRY_AFTER: "Retry-After",
            /**
	         * The UserAgent header.
	         *
	         * @const
	         * @type {string}
	         */ USER_AGENT: "User-Agent"
        }
    };
    // Copyright (c) Microsoft Corporation.
    var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
    /**
	 * A constant that indicates whether the environment is node.js or browser based.
	 */ var isNode = false;
    /**
	 * Encodes an URI.
	 *
	 * @param {string} uri The URI to be encoded.
	 * @return {string} The encoded URI.
	 */ function encodeUri(uri) {
        return encodeURIComponent(uri).replace(/!/g, "%21").replace(/"/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
    }
    /**
	 * Returns a stripped version of the Http Response which only contains body,
	 * headers and the status.
	 *
	 * @param {HttpOperationResponse} response The Http Response
	 *
	 * @return {object} The stripped version of Http Response.
	 */ function stripResponse(response) {
        var strippedResponse = {};
        strippedResponse.body = response.bodyAsText;
        strippedResponse.headers = response.headers;
        strippedResponse.status = response.status;
        return strippedResponse;
    }
    /**
	 * Returns a stripped version of the Http Request that does not contain the
	 * Authorization header.
	 *
	 * @param {WebResourceLike} request The Http Request object
	 *
	 * @return {WebResourceLike} The stripped version of Http Request.
	 */ function stripRequest(request) {
        var strippedRequest = request.clone();
        if (strippedRequest.headers) strippedRequest.headers.remove("authorization");
        return strippedRequest;
    }
    /**
	 * Validates the given uuid as a string
	 *
	 * @param {string} uuid The uuid as a string that needs to be validated
	 *
	 * @return {boolean} True if the uuid is valid; false otherwise.
	 */ function isValidUuid(uuid) {
        return validUuidRegex.test(uuid);
    }
    /**
	 * Generated UUID
	 *
	 * @return {string} RFC4122 v4 UUID.
	 */ function generateUuid() {
        return v4();
    }
    /**
	 * Executes an array of promises sequentially. Inspiration of this method is here:
	 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
	 *
	 * @param {Array} promiseFactories An array of promise factories(A function that return a promise)
	 *
	 * @param {any} [kickstart] Input to the first promise that is used to kickstart the promise chain.
	 * If not provided then the promise chain starts with undefined.
	 *
	 * @return A chain of resolved or rejected promises
	 */ function executePromisesSequentially(promiseFactories, kickstart) {
        var result = Promise.resolve(kickstart);
        promiseFactories.forEach(function(promiseFactory) {
            result = result.then(promiseFactory);
        });
        return result;
    }
    /**
	 * A wrapper for setTimeout that resolves a promise after t milliseconds.
	 * @param {number} t The number of milliseconds to be delayed.
	 * @param {T} value The value to be resolved with after a timeout of t milliseconds.
	 * @returns {Promise<T>} Resolved promise
	 */ function delay(t, value) {
        return new Promise(function(resolve) {
            return setTimeout(function() {
                return resolve(value);
            }, t);
        });
    }
    /**
	 * Converts a Promise to a callback.
	 * @param {Promise<any>} promise The Promise to be converted to a callback
	 * @returns {Function} A function that takes the callback (cb: Function): void
	 * @deprecated generated code should instead depend on responseToBody
	 */ function promiseToCallback(promise) {
        if (typeof promise.then !== "function") throw new Error("The provided input is not a Promise.");
        return function(cb) {
            promise.then(function(data) {
                // eslint-disable-next-line promise/no-callback-in-promise
                return cb(undefined, data);
            }).catch(function(err) {
                // eslint-disable-next-line promise/no-callback-in-promise
                cb(err);
            });
        };
    }
    /**
	 * Converts a Promise to a service callback.
	 * @param {Promise<HttpOperationResponse>} promise - The Promise of HttpOperationResponse to be converted to a service callback
	 * @returns {Function} A function that takes the service callback (cb: ServiceCallback<T>): void
	 */ function promiseToServiceCallback(promise) {
        if (typeof promise.then !== "function") throw new Error("The provided input is not a Promise.");
        return function(cb) {
            promise.then(function(data) {
                return process.nextTick(cb, undefined, data.parsedBody, data.request, data);
            }).catch(function(err) {
                process.nextTick(cb, err);
            });
        };
    }
    function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
        var _a, _b, _c;
        if (!Array.isArray(obj)) obj = [
            obj
        ];
        if (!xmlNamespaceKey || !xmlNamespace) return _a = {}, _a[elementName] = obj, _a;
        return _b = {}, _b[elementName] = obj, _b.$ = (_c = {}, _c[xmlNamespaceKey] = xmlNamespace, _c), _b;
    }
    /**
	 * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor
	 * @param {object} targetCtor The target object on which the properties need to be applied.
	 * @param {Array<object>} sourceCtors An array of source objects from which the properties need to be taken.
	 */ function applyMixins(targetCtor, sourceCtors) {
        sourceCtors.forEach(function(sourceCtors) {
            Object.getOwnPropertyNames(sourceCtors.prototype).forEach(function(name) {
                targetCtor.prototype[name] = sourceCtors.prototype[name];
            });
        });
    }
    var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    /**
	 * Indicates whether the given string is in ISO 8601 format.
	 * @param {string} value The value to be validated for ISO 8601 duration format.
	 * @return {boolean} `true` if valid, `false` otherwise.
	 */ function isDuration(value) {
        return validateISODuration.test(value);
    }
    /**
	 * Replace all of the instances of searchValue in value with the provided replaceValue.
	 * @param {string | undefined} value The value to search and replace in.
	 * @param {string} searchValue The value to search for in the value argument.
	 * @param {string} replaceValue The value to replace searchValue with in the value argument.
	 * @returns {string | undefined} The value where each instance of searchValue was replaced with replacedValue.
	 */ function replaceAll(value, searchValue, replaceValue) {
        return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
    }
    /**
	 * Determines whether the given entity is a basic/primitive type
	 * (string, number, boolean, null, undefined).
	 * @param {any} value Any entity
	 * @return {boolean} - true is it is primitive type, false otherwise.
	 */ function isPrimitiveType(value) {
        return typeof value !== "object" && typeof value !== "function" || value === null;
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT License.
    /**
	 * Default key used to access the XML attributes.
	 */ var XML_ATTRKEY = "$";
    /**
	 * Default key used to access the XML value content.
	 */ var XML_CHARKEY = "_";
    // Copyright (c) Microsoft Corporation.
    var Serializer = /** @class */ function() {
        function Serializer(modelMappers, isXML) {
            if (modelMappers === void 0) modelMappers = {};
            this.modelMappers = modelMappers;
            this.isXML = isXML;
        }
        Serializer.prototype.validateConstraints = function(mapper, value, objectName) {
            var failValidation = function(constraintName, constraintValue) {
                throw new Error("\"" + objectName + "\" with value \"" + value + "\" should satisfy the constraint \"" + constraintName + "\": " + constraintValue + ".");
            };
            if (mapper.constraints && value != undefined) {
                var _a = mapper.constraints, ExclusiveMaximum = _a.ExclusiveMaximum, ExclusiveMinimum = _a.ExclusiveMinimum, InclusiveMaximum = _a.InclusiveMaximum, InclusiveMinimum = _a.InclusiveMinimum, MaxItems = _a.MaxItems, MaxLength = _a.MaxLength, MinItems = _a.MinItems, MinLength = _a.MinLength, MultipleOf = _a.MultipleOf, Pattern = _a.Pattern, UniqueItems = _a.UniqueItems;
                if (ExclusiveMaximum != undefined && value >= ExclusiveMaximum) failValidation("ExclusiveMaximum", ExclusiveMaximum);
                if (ExclusiveMinimum != undefined && value <= ExclusiveMinimum) failValidation("ExclusiveMinimum", ExclusiveMinimum);
                if (InclusiveMaximum != undefined && value > InclusiveMaximum) failValidation("InclusiveMaximum", InclusiveMaximum);
                if (InclusiveMinimum != undefined && value < InclusiveMinimum) failValidation("InclusiveMinimum", InclusiveMinimum);
                if (MaxItems != undefined && value.length > MaxItems) failValidation("MaxItems", MaxItems);
                if (MaxLength != undefined && value.length > MaxLength) failValidation("MaxLength", MaxLength);
                if (MinItems != undefined && value.length < MinItems) failValidation("MinItems", MinItems);
                if (MinLength != undefined && value.length < MinLength) failValidation("MinLength", MinLength);
                if (MultipleOf != undefined && value % MultipleOf !== 0) failValidation("MultipleOf", MultipleOf);
                if (Pattern) {
                    var pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
                    if (typeof value !== "string" || value.match(pattern) === null) failValidation("Pattern", Pattern);
                }
                if (UniqueItems && value.some(function(item, i, ar) {
                    return ar.indexOf(item) !== i;
                })) failValidation("UniqueItems", UniqueItems);
            }
        };
        /**
	     * Serialize the given object based on its metadata defined in the mapper
	     *
	     * @param {Mapper} mapper The mapper which defines the metadata of the serializable object
	     *
	     * @param {object|string|Array|number|boolean|Date|stream} object A valid Javascript object to be serialized
	     *
	     * @param {string} objectName Name of the serialized object
	     *
	     * @param {options} options additional options to deserialization
	     *
	     * @returns {object|string|Array|number|boolean|Date|stream} A valid serialized Javascript object
	     */ Serializer.prototype.serialize = function(mapper, object, objectName, options) {
            var _a, _b, _c;
            if (options === void 0) options = {};
            var updatedOptions = {
                rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
            };
            var payload = {};
            var mapperType = mapper.type.name;
            if (!objectName) objectName = mapper.serializedName;
            if (mapperType.match(/^Sequence$/i) !== null) payload = [];
            if (mapper.isConstant) object = mapper.defaultValue;
            // This table of allowed values should help explain
            // the mapper.required and mapper.nullable properties.
            // X means "neither undefined or null are allowed".
            //           || required
            //           || true      | false
            //  nullable || ==========================
            //      true || null      | undefined/null
            //     false || X         | undefined
            // undefined || X         | undefined/null
            var required = mapper.required, nullable = mapper.nullable;
            if (required && nullable && object === undefined) throw new Error(objectName + " cannot be undefined.");
            if (required && !nullable && object == undefined) throw new Error(objectName + " cannot be null or undefined.");
            if (!required && nullable === false && object === null) throw new Error(objectName + " cannot be null.");
            if (object == undefined) payload = object;
            else {
                // Validate Constraints if any
                this.validateConstraints(mapper, object, objectName);
                if (mapperType.match(/^any$/i) !== null) payload = object;
                else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) payload = serializeBasicTypes(mapperType, objectName, object);
                else if (mapperType.match(/^Enum$/i) !== null) {
                    var enumMapper = mapper;
                    payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
                } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) payload = serializeDateTypes(mapperType, object, objectName);
                else if (mapperType.match(/^ByteArray$/i) !== null) payload = serializeByteArrayType(objectName, object);
                else if (mapperType.match(/^Base64Url$/i) !== null) payload = serializeBase64UrlType(objectName, object);
                else if (mapperType.match(/^Sequence$/i) !== null) payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
                else if (mapperType.match(/^Dictionary$/i) !== null) payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
                else if (mapperType.match(/^Composite$/i) !== null) payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            }
            return payload;
        };
        /**
	     * Deserialize the given object based on its metadata defined in the mapper
	     *
	     * @param {object} mapper The mapper which defines the metadata of the serializable object
	     *
	     * @param {object|string|Array|number|boolean|Date|stream} responseBody A valid Javascript entity to be deserialized
	     *
	     * @param {string} objectName Name of the deserialized object
	     *
	     * @param options Controls behavior of XML parser and builder.
	     *
	     * @returns {object|string|Array|number|boolean|Date|stream} A valid deserialized Javascript object
	     */ Serializer.prototype.deserialize = function(mapper, responseBody, objectName, options) {
            var _a, _b, _c;
            if (options === void 0) options = {};
            var updatedOptions = {
                rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
            };
            if (responseBody == undefined) {
                if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
                // between the list being empty versus being missing,
                // so let's do the more user-friendly thing and return an empty list.
                responseBody = [];
                // specifically check for undefined as default value can be a falsey value `0, "", false, null`
                if (mapper.defaultValue !== undefined) responseBody = mapper.defaultValue;
                return responseBody;
            }
            var payload;
            var mapperType = mapper.type.name;
            if (!objectName) objectName = mapper.serializedName;
            if (mapperType.match(/^Composite$/i) !== null) payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
            else {
                if (this.isXML) {
                    var xmlCharKey = updatedOptions.xmlCharKey;
                    /**
	                 * If the mapper specifies this as a non-composite type value but the responseBody contains
	                 * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
	                 * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
	                 */ if (responseBody[XML_ATTRKEY] != undefined && responseBody[xmlCharKey] != undefined) responseBody = responseBody[xmlCharKey];
                }
                if (mapperType.match(/^Number$/i) !== null) {
                    payload = parseFloat(responseBody);
                    if (isNaN(payload)) payload = responseBody;
                } else if (mapperType.match(/^Boolean$/i) !== null) {
                    if (responseBody === "true") payload = true;
                    else if (responseBody === "false") payload = false;
                    else payload = responseBody;
                } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) payload = responseBody;
                else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) payload = new Date(responseBody);
                else if (mapperType.match(/^UnixTime$/i) !== null) payload = unixTimeToDate(responseBody);
                else if (mapperType.match(/^ByteArray$/i) !== null) payload = decodeString(responseBody);
                else if (mapperType.match(/^Base64Url$/i) !== null) payload = base64UrlToByteArray(responseBody);
                else if (mapperType.match(/^Sequence$/i) !== null) payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
                else if (mapperType.match(/^Dictionary$/i) !== null) payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
            }
            if (mapper.isConstant) payload = mapper.defaultValue;
            return payload;
        };
        return Serializer;
    }();
    function trimEnd(str, ch) {
        var len = str.length;
        while(len - 1 >= 0 && str[len - 1] === ch)--len;
        return str.substr(0, len);
    }
    function bufferToBase64Url(buffer) {
        if (!buffer) return undefined;
        if (!(buffer instanceof Uint8Array)) throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
        // Uint8Array to Base64.
        var str = encodeByteArray(buffer);
        // Base64 to Base64Url.
        return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
    }
    function base64UrlToByteArray(str) {
        if (!str) return undefined;
        if (str && typeof str.valueOf() !== "string") throw new Error("Please provide an input of type string for converting to Uint8Array");
        // Base64Url to Base64.
        str = str.replace(/-/g, "+").replace(/_/g, "/");
        // Base64 to Uint8Array.
        return decodeString(str);
    }
    function splitSerializeName(prop) {
        var classes = [];
        var partialclass = "";
        if (prop) {
            var subwords = prop.split(".");
            for(var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++){
                var item = subwords_1[_i];
                if (item.charAt(item.length - 1) === "\\") partialclass += item.substr(0, item.length - 1) + ".";
                else {
                    partialclass += item;
                    classes.push(partialclass);
                    partialclass = "";
                }
            }
        }
        return classes;
    }
    function dateToUnixTime(d) {
        if (!d) return undefined;
        if (typeof d.valueOf() === "string") d = new Date(d);
        return Math.floor(d.getTime() / 1000);
    }
    function unixTimeToDate(n) {
        if (!n) return undefined;
        return new Date(n * 1000);
    }
    function serializeBasicTypes(typeName, objectName, value) {
        if (value !== null && value !== undefined) {
            if (typeName.match(/^Number$/i) !== null) {
                if (typeof value !== "number") throw new Error(objectName + " with value " + value + " must be of type number.");
            } else if (typeName.match(/^String$/i) !== null) {
                if (typeof value.valueOf() !== "string") throw new Error(objectName + " with value \"" + value + "\" must be of type string.");
            } else if (typeName.match(/^Uuid$/i) !== null) {
                if (!(typeof value.valueOf() === "string" && isValidUuid(value))) throw new Error(objectName + " with value \"" + value + "\" must be of type string and a valid uuid.");
            } else if (typeName.match(/^Boolean$/i) !== null) {
                if (typeof value !== "boolean") throw new Error(objectName + " with value " + value + " must be of type boolean.");
            } else if (typeName.match(/^Stream$/i) !== null) {
                var objectType = typeof value;
                if (objectType !== "string" && objectType !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) throw new Error(objectName + " must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.");
            }
        }
        return value;
    }
    function serializeEnumType(objectName, allowedValues, value) {
        if (!allowedValues) throw new Error("Please provide a set of allowedValues to validate " + objectName + " as an Enum Type.");
        var isPresent = allowedValues.some(function(item) {
            if (typeof item.valueOf() === "string") return item.toLowerCase() === value.toLowerCase();
            return item === value;
        });
        if (!isPresent) throw new Error(value + " is not a valid value for " + objectName + ". The valid values are: " + JSON.stringify(allowedValues) + ".");
        return value;
    }
    function serializeByteArrayType(objectName, value) {
        var returnValue = "";
        if (value != undefined) {
            if (!(value instanceof Uint8Array)) throw new Error(objectName + " must be of type Uint8Array.");
            returnValue = encodeByteArray(value);
        }
        return returnValue;
    }
    function serializeBase64UrlType(objectName, value) {
        var returnValue = "";
        if (value != undefined) {
            if (!(value instanceof Uint8Array)) throw new Error(objectName + " must be of type Uint8Array.");
            returnValue = bufferToBase64Url(value) || "";
        }
        return returnValue;
    }
    function serializeDateTypes(typeName, value, objectName) {
        if (value != undefined) {
            if (typeName.match(/^Date$/i) !== null) {
                if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
                value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
            } else if (typeName.match(/^DateTime$/i) !== null) {
                if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
                value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
            } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
                if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123 format.");
                value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
            } else if (typeName.match(/^UnixTime$/i) !== null) {
                if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123/ISO8601 format " + "for it to be serialized in UnixTime/Epoch format.");
                value = dateToUnixTime(value);
            } else if (typeName.match(/^TimeSpan$/i) !== null) {
                if (!isDuration(value)) throw new Error(objectName + " must be a string in ISO 8601 format. Instead was \"" + value + "\".");
            }
        }
        return value;
    }
    function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
        var _a, _b;
        if (!Array.isArray(object)) throw new Error(objectName + " must be of type Array.");
        var elementType = mapper.type.element;
        if (!elementType || typeof elementType !== "object") throw new Error("element\" metadata for an Array must be defined in the " + ("mapper and it must of type \"object\" in " + objectName + "."));
        var tempArray = [];
        for(var i = 0; i < object.length; i++){
            var serializedValue = serializer.serialize(elementType, object[i], objectName, options);
            if (isXml && elementType.xmlNamespace) {
                var xmlnsKey = elementType.xmlNamespacePrefix ? "xmlns:" + elementType.xmlNamespacePrefix : "xmlns";
                if (elementType.type.name === "Composite") {
                    tempArray[i] = __assign({}, serializedValue);
                    tempArray[i][XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = elementType.xmlNamespace, _a);
                } else {
                    tempArray[i] = {};
                    tempArray[i][options.xmlCharKey] = serializedValue;
                    tempArray[i][XML_ATTRKEY] = (_b = {}, _b[xmlnsKey] = elementType.xmlNamespace, _b);
                }
            } else tempArray[i] = serializedValue;
        }
        return tempArray;
    }
    function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
        var _a;
        if (typeof object !== "object") throw new Error(objectName + " must be of type object.");
        var valueType = mapper.type.value;
        if (!valueType || typeof valueType !== "object") throw new Error("\"value\" metadata for a Dictionary must be defined in the " + ("mapper and it must of type \"object\" in " + objectName + "."));
        var tempDictionary = {};
        for(var _i = 0, _b = Object.keys(object); _i < _b.length; _i++){
            var key = _b[_i];
            var serializedValue = serializer.serialize(valueType, object[key], objectName, options);
            // If the element needs an XML namespace we need to add it within the $ property
            tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
        }
        // Add the namespace to the root element if needed
        if (isXml && mapper.xmlNamespace) {
            var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns";
            return __assign(__assign({}, tempDictionary), {
                $: (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a)
            });
        }
        return tempDictionary;
    }
    /**
	 * Resolves the additionalProperties property from a referenced mapper
	 * @param serializer the serializer containing the entire set of mappers
	 * @param mapper the composite mapper to resolve
	 * @param objectName name of the object being serialized
	 */ function resolveAdditionalProperties(serializer, mapper, objectName) {
        var additionalProperties = mapper.type.additionalProperties;
        if (!additionalProperties && mapper.type.className) {
            var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
            return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
        }
        return additionalProperties;
    }
    /**
	 * Finds the mapper referenced by className
	 * @param serializer the serializer containing the entire set of mappers
	 * @param mapper the composite mapper to resolve
	 * @param objectName name of the object being serialized
	 */ function resolveReferencedMapper(serializer, mapper, objectName) {
        var className = mapper.type.className;
        if (!className) throw new Error("Class name for model \"" + objectName + "\" is not provided in the mapper \"" + JSON.stringify(mapper, undefined, 2) + "\".");
        return serializer.modelMappers[className];
    }
    /**
	 * Resolves a composite mapper's modelProperties.
	 * @param serializer the serializer containing the entire set of mappers
	 * @param mapper the composite mapper to resolve
	 */ function resolveModelProperties(serializer, mapper, objectName) {
        var modelProps = mapper.type.modelProperties;
        if (!modelProps) {
            var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
            if (!modelMapper) throw new Error("mapper() cannot be null or undefined for model \"" + mapper.type.className + "\".");
            modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
            if (!modelProps) throw new Error("modelProperties cannot be null or undefined in the " + ("mapper \"" + JSON.stringify(modelMapper) + "\" of type \"" + mapper.type.className + "\" for object \"" + objectName + "\"."));
        }
        return modelProps;
    }
    function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
        var _a, _b;
        if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
        if (object != undefined) {
            var payload = {};
            var modelProps = resolveModelProperties(serializer, mapper, objectName);
            for(var _i = 0, _c = Object.keys(modelProps); _i < _c.length; _i++){
                var key = _c[_i];
                var propertyMapper = modelProps[key];
                if (propertyMapper.readOnly) continue;
                var propName = void 0;
                var parentObject = payload;
                if (serializer.isXML) {
                    if (propertyMapper.xmlIsWrapped) propName = propertyMapper.xmlName;
                    else propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
                } else {
                    var paths = splitSerializeName(propertyMapper.serializedName);
                    propName = paths.pop();
                    for(var _d = 0, paths_1 = paths; _d < paths_1.length; _d++){
                        var pathName = paths_1[_d];
                        var childObject = parentObject[pathName];
                        if (childObject == undefined && (object[key] != undefined || propertyMapper.defaultValue !== undefined)) parentObject[pathName] = {};
                        parentObject = parentObject[pathName];
                    }
                }
                if (parentObject != undefined) {
                    if (isXml && mapper.xmlNamespace) {
                        var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns";
                        parentObject[XML_ATTRKEY] = __assign(__assign({}, parentObject[XML_ATTRKEY]), (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a));
                    }
                    var propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
                    var toSerialize = object[key];
                    var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
                    if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) toSerialize = mapper.serializedName;
                    var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
                    if (serializedValue !== undefined && propName != undefined) {
                        var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
                        if (isXml && propertyMapper.xmlIsAttribute) {
                            // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
                            // This keeps things simple while preventing name collision
                            // with names in user documents.
                            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};
                            parentObject[XML_ATTRKEY][propName] = serializedValue;
                        } else if (isXml && propertyMapper.xmlIsWrapped) parentObject[propName] = (_b = {}, _b[propertyMapper.xmlElementName] = value, _b);
                        else parentObject[propName] = value;
                    }
                }
            }
            var additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
            if (additionalPropertiesMapper) {
                var propNames = Object.keys(modelProps);
                var _loop_1 = function(clientPropName) {
                    var isAdditionalProperty = propNames.every(function(pn) {
                        return pn !== clientPropName;
                    });
                    if (isAdditionalProperty) payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
                };
                for(var clientPropName in object)_loop_1(clientPropName);
            }
            return payload;
        }
        return object;
    }
    function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
        var _a;
        if (!isXml || !propertyMapper.xmlNamespace) return serializedValue;
        var xmlnsKey = propertyMapper.xmlNamespacePrefix ? "xmlns:" + propertyMapper.xmlNamespacePrefix : "xmlns";
        var xmlNamespace = (_a = {}, _a[xmlnsKey] = propertyMapper.xmlNamespace, _a);
        if ([
            "Composite"
        ].includes(propertyMapper.type.name)) {
            if (serializedValue[XML_ATTRKEY]) return serializedValue;
            else {
                var result_1 = __assign({}, serializedValue);
                result_1[XML_ATTRKEY] = xmlNamespace;
                return result_1;
            }
        }
        var result = {};
        result[options.xmlCharKey] = serializedValue;
        result[XML_ATTRKEY] = xmlNamespace;
        return result;
    }
    function isSpecialXmlProperty(propertyName, options) {
        return [
            XML_ATTRKEY,
            options.xmlCharKey
        ].includes(propertyName);
    }
    function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
        var _a;
        if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
        var modelProps = resolveModelProperties(serializer, mapper, objectName);
        var instance = {};
        var handledPropertyNames = [];
        for(var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++){
            var key = _b[_i];
            var propertyMapper = modelProps[key];
            var paths = splitSerializeName(modelProps[key].serializedName);
            handledPropertyNames.push(paths[0]);
            var serializedName = propertyMapper.serializedName, xmlName = propertyMapper.xmlName, xmlElementName = propertyMapper.xmlElementName;
            var propertyObjectName = objectName;
            if (serializedName !== "" && serializedName !== undefined) propertyObjectName = objectName + "." + serializedName;
            var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
            if (headerCollectionPrefix) {
                var dictionary = {};
                for(var _c = 0, _d = Object.keys(responseBody); _c < _d.length; _c++){
                    var headerKey = _d[_c];
                    if (headerKey.startsWith(headerCollectionPrefix)) dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
                    handledPropertyNames.push(headerKey);
                }
                instance[key] = dictionary;
            } else if (serializer.isXML) {
                if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) instance[key] = serializer.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);
                else {
                    var propertyName = xmlElementName || xmlName || serializedName;
                    if (propertyMapper.xmlIsWrapped) {
                        /* a list of <xmlElementName> wrapped by <xmlName>
	                      For the xml example below
	                        <Cors>
	                          <CorsRule>...</CorsRule>
	                          <CorsRule>...</CorsRule>
	                        </Cors>
	                      the responseBody has
	                        {
	                          Cors: {
	                            CorsRule: [{...}, {...}]
	                          }
	                        }
	                      xmlName is "Cors" and xmlElementName is"CorsRule".
	                    */ var wrapped = responseBody[xmlName];
                        var elementList = (_a = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];
                        instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
                    } else {
                        var property = responseBody[propertyName];
                        instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
                    }
                }
            } else {
                // deserialize the property if it is present in the provided responseBody instance
                var propertyInstance = void 0;
                var res = responseBody;
                // traversing the object step by step.
                for(var _e = 0, paths_2 = paths; _e < paths_2.length; _e++){
                    var item = paths_2[_e];
                    if (!res) break;
                    res = res[item];
                }
                propertyInstance = res;
                var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
                // checking that the model property name (key)(ex: "fishtype") and the
                // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
                // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
                // is a better approach. The generator is not consistent with escaping '\.' in the
                // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
                // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
                // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
                // the transformation of model property name (ex: "fishtype") is done consistently.
                // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
                if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) propertyInstance = mapper.serializedName;
                var serializedValue = void 0;
                // paging
                if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
                    propertyInstance = responseBody[key];
                    instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
                    serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                    instance[key] = serializedValue;
                }
            }
        }
        var additionalPropertiesMapper = mapper.type.additionalProperties;
        if (additionalPropertiesMapper) {
            var isAdditionalProperty = function(responsePropName) {
                for(var clientPropName in modelProps){
                    var paths = splitSerializeName(modelProps[clientPropName].serializedName);
                    if (paths[0] === responsePropName) return false;
                }
                return true;
            };
            for(var responsePropName in responseBody)if (isAdditionalProperty(responsePropName)) instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
        } else if (responseBody) for(var _f = 0, _g = Object.keys(responseBody); _f < _g.length; _f++){
            var key = _g[_f];
            if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) instance[key] = responseBody[key];
        }
        return instance;
    }
    function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
        var value = mapper.type.value;
        if (!value || typeof value !== "object") throw new Error("\"value\" metadata for a Dictionary must be defined in the " + ("mapper and it must of type \"object\" in " + objectName));
        if (responseBody) {
            var tempDictionary = {};
            for(var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++){
                var key = _a[_i];
                tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
            }
            return tempDictionary;
        }
        return responseBody;
    }
    function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
        var element = mapper.type.element;
        if (!element || typeof element !== "object") throw new Error("element\" metadata for an Array must be defined in the " + ("mapper and it must of type \"object\" in " + objectName));
        if (responseBody) {
            if (!Array.isArray(responseBody)) // xml2js will interpret a single element array as just the element, so force it to be an array
            responseBody = [
                responseBody
            ];
            var tempArray = [];
            for(var i = 0; i < responseBody.length; i++)tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + "[" + i + "]", options);
            return tempArray;
        }
        return responseBody;
    }
    function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
        var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
        if (polymorphicDiscriminator) {
            var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
            if (discriminatorName != undefined) {
                var discriminatorValue = object[discriminatorName];
                if (discriminatorValue != undefined) {
                    var typeName = mapper.type.uberParent || mapper.type.className;
                    var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + "." + discriminatorValue;
                    var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];
                    if (polymorphicMapper) mapper = polymorphicMapper;
                }
            }
        }
        return mapper;
    }
    function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
        return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
    }
    function getPolymorphicDiscriminatorSafely(serializer, typeName) {
        return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
    }
    // TODO: why is this here?
    function serializeObject(toSerialize) {
        if (toSerialize == undefined) return undefined;
        if (toSerialize instanceof Uint8Array) {
            toSerialize = encodeByteArray(toSerialize);
            return toSerialize;
        } else if (toSerialize instanceof Date) return toSerialize.toISOString();
        else if (Array.isArray(toSerialize)) {
            var array = [];
            for(var i = 0; i < toSerialize.length; i++)array.push(serializeObject(toSerialize[i]));
            return array;
        } else if (typeof toSerialize === "object") {
            var dictionary = {};
            for(var property in toSerialize)dictionary[property] = serializeObject(toSerialize[property]);
            return dictionary;
        }
        return toSerialize;
    }
    /**
	 * Utility function to create a K:V from a list of strings
	 */ function strEnum(o) {
        var result = {};
        for(var _i = 0, o_1 = o; _i < o_1.length; _i++){
            var key = o_1[_i];
            result[key] = key;
        }
        return result;
    }
    var MapperType = strEnum([
        "Base64Url",
        "Boolean",
        "ByteArray",
        "Composite",
        "Date",
        "DateTime",
        "DateTimeRfc1123",
        "Dictionary",
        "Enum",
        "Number",
        "Object",
        "Sequence",
        "String",
        "Stream",
        "TimeSpan",
        "UnixTime"
    ]);
    // Copyright (c) Microsoft Corporation.
    function isWebResourceLike(object) {
        if (typeof object !== "object") return false;
        if (typeof object.url === "string" && typeof object.method === "string" && typeof object.headers === "object" && isHttpHeadersLike(object.headers) && typeof object.validateRequestProperties === "function" && typeof object.prepare === "function" && typeof object.clone === "function") return true;
        return false;
    }
    /**
	 * Creates a new WebResource object.
	 *
	 * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary
	 * properties to initiate a request.
	 *
	 * @constructor
	 */ var WebResource = /** @class */ function() {
        function WebResource(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse) {
            this.streamResponseBody = streamResponseBody;
            this.url = url || "";
            this.method = method || "GET";
            this.headers = isHttpHeadersLike(headers) ? headers : new HttpHeaders(headers);
            this.body = body;
            this.query = query;
            this.formData = undefined;
            this.withCredentials = withCredentials || false;
            this.abortSignal = abortSignal;
            this.timeout = timeout || 0;
            this.onUploadProgress = onUploadProgress;
            this.onDownloadProgress = onDownloadProgress;
            this.proxySettings = proxySettings;
            this.keepAlive = keepAlive;
            this.decompressResponse = decompressResponse;
            this.requestId = this.headers.get("x-ms-client-request-id") || generateUuid();
        }
        /**
	     * Validates that the required properties such as method, url, headers["Content-Type"],
	     * headers["accept-language"] are defined. It will throw an error if one of the above
	     * mentioned properties are not defined.
	     */ WebResource.prototype.validateRequestProperties = function() {
            if (!this.method) throw new Error("WebResource.method is required.");
            if (!this.url) throw new Error("WebResource.url is required.");
        };
        /**
	     * Prepares the request.
	     * @param {RequestPrepareOptions} options Options to provide for preparing the request.
	     * @returns {WebResource} Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
	     */ WebResource.prototype.prepare = function(options) {
            if (!options) throw new Error("options object is required");
            if (options.method === undefined || options.method === null || typeof options.method.valueOf() !== "string") throw new Error("options.method must be a string.");
            if (options.url && options.pathTemplate) throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
            if ((options.pathTemplate === undefined || options.pathTemplate === null || typeof options.pathTemplate.valueOf() !== "string") && (options.url === undefined || options.url === null || typeof options.url.valueOf() !== "string")) throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
            // set the url if it is provided.
            if (options.url) {
                if (typeof options.url !== "string") throw new Error('options.url must be of type "string".');
                this.url = options.url;
            }
            // set the method
            if (options.method) {
                var validMethods = [
                    "GET",
                    "PUT",
                    "HEAD",
                    "DELETE",
                    "OPTIONS",
                    "POST",
                    "PATCH",
                    "TRACE"
                ];
                if (validMethods.indexOf(options.method.toUpperCase()) === -1) throw new Error('The provided method "' + options.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
            }
            this.method = options.method.toUpperCase();
            // construct the url if path template is provided
            if (options.pathTemplate) {
                var pathTemplate_1 = options.pathTemplate, pathParameters_1 = options.pathParameters;
                if (typeof pathTemplate_1 !== "string") throw new Error('options.pathTemplate must be of type "string".');
                if (!options.baseUrl) options.baseUrl = "https://management.azure.com";
                var baseUrl = options.baseUrl;
                var url_1 = baseUrl + (baseUrl.endsWith("/") ? "" : "/") + (pathTemplate_1.startsWith("/") ? pathTemplate_1.slice(1) : pathTemplate_1);
                var segments = url_1.match(/({[\w-]*\s*[\w-]*})/gi);
                if (segments && segments.length) {
                    if (!pathParameters_1) throw new Error("pathTemplate: " + pathTemplate_1 + " has been provided. Hence, options.pathParameters must also be provided.");
                    segments.forEach(function(item) {
                        var pathParamName = item.slice(1, -1);
                        var pathParam = pathParameters_1[pathParamName];
                        if (pathParam === null || pathParam === undefined || !(typeof pathParam === "string" || typeof pathParam === "object")) {
                            var stringifiedPathParameters = JSON.stringify(pathParameters_1, undefined, 2);
                            throw new Error("pathTemplate: " + pathTemplate_1 + " contains the path parameter " + pathParamName + (" however, it is not present in parameters: " + stringifiedPathParameters + ".") + ("The value of the path parameter can either be a \"string\" of the form { " + pathParamName + ": \"some sample value\" } or ") + ("it can be an \"object\" of the form { \"" + pathParamName + "\": { value: \"some sample value\", skipUrlEncoding: true } }."));
                        }
                        if (typeof pathParam.valueOf() === "string") url_1 = url_1.replace(item, encodeURIComponent(pathParam));
                        if (typeof pathParam.valueOf() === "object") {
                            if (!pathParam.value) throw new Error("options.pathParameters[" + pathParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
                            if (pathParam.skipUrlEncoding) url_1 = url_1.replace(item, pathParam.value);
                            else url_1 = url_1.replace(item, encodeURIComponent(pathParam.value));
                        }
                    });
                }
                this.url = url_1;
            }
            // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.
            if (options.queryParameters) {
                var queryParameters = options.queryParameters;
                if (typeof queryParameters !== "object") throw new Error('options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.');
                // append question mark if it is not present in the url
                if (this.url && this.url.indexOf("?") === -1) this.url += "?";
                // construct queryString
                var queryParams = [];
                // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().
                this.query = {};
                for(var queryParamName in queryParameters){
                    var queryParam = queryParameters[queryParamName];
                    if (queryParam) {
                        if (typeof queryParam === "string") {
                            queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
                            this.query[queryParamName] = encodeURIComponent(queryParam);
                        } else if (typeof queryParam === "object") {
                            if (!queryParam.value) throw new Error("options.queryParameters[" + queryParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
                            if (queryParam.skipUrlEncoding) {
                                queryParams.push(queryParamName + "=" + queryParam.value);
                                this.query[queryParamName] = queryParam.value;
                            } else {
                                queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
                                this.query[queryParamName] = encodeURIComponent(queryParam.value);
                            }
                        }
                    }
                } // end-of-for
                // append the queryString
                this.url += queryParams.join("&");
            }
            // add headers to the request if they are provided
            if (options.headers) {
                var headers = options.headers;
                for(var _i = 0, _a = Object.keys(options.headers); _i < _a.length; _i++){
                    var headerName = _a[_i];
                    this.headers.set(headerName, headers[headerName]);
                }
            }
            // ensure accept-language is set correctly
            if (!this.headers.get("accept-language")) this.headers.set("accept-language", "en-US");
            // ensure the request-id is set correctly
            if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) this.headers.set("x-ms-client-request-id", this.requestId);
            // default
            if (!this.headers.get("Content-Type")) this.headers.set("Content-Type", "application/json; charset=utf-8");
            // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicilty
            this.body = options.body;
            if (options.body !== undefined && options.body !== null) {
                // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.
                if (options.bodyIsStream) {
                    if (!this.headers.get("Transfer-Encoding")) this.headers.set("Transfer-Encoding", "chunked");
                    if (this.headers.get("Content-Type") !== "application/octet-stream") this.headers.set("Content-Type", "application/octet-stream");
                } else {
                    if (options.serializationMapper) this.body = new Serializer(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
                    if (!options.disableJsonStringifyOnBody) this.body = JSON.stringify(options.body);
                }
            }
            if (options.spanOptions) this.spanOptions = options.spanOptions;
            this.abortSignal = options.abortSignal;
            this.onDownloadProgress = options.onDownloadProgress;
            this.onUploadProgress = options.onUploadProgress;
            return this;
        };
        /**
	     * Clone this WebResource HTTP request object.
	     * @returns {WebResource} The clone of this WebResource HTTP request object.
	     */ WebResource.prototype.clone = function() {
            var result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse);
            if (this.formData) result.formData = this.formData;
            if (this.operationSpec) result.operationSpec = this.operationSpec;
            if (this.shouldDeserialize) result.shouldDeserialize = this.shouldDeserialize;
            if (this.operationResponseGetter) result.operationResponseGetter = this.operationResponseGetter;
            return result;
        };
        return WebResource;
    }();
    /*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */ /* global Reflect, Promise */ var extendStatics$1 = function(d, b) {
        extendStatics$1 = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics$1(d, b);
    };
    function __extends$1(d, b) {
        extendStatics$1(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function() {
                if (o && i >= o.length) o = void 0;
                return {
                    value: o && o[i++],
                    done: !o
                };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);
        } catch (error) {
            e = {
                error: error
            };
        } finally{
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            } finally{
                if (e) throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for(var ar = [], i = 0; i < arguments.length; i++)ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    var listenersMap = new WeakMap();
    var abortedMap = new WeakMap();
    /**
	 * An aborter instance implements AbortSignal interface, can abort HTTP requests.
	 *
	 * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.
	 * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation
	 * cannot or will not ever be cancelled.
	 *
	 * @example
	 * // Abort without timeout
	 * await doAsyncWork(AbortSignal.none);
	 *
	 * @export
	 * @class AbortSignal
	 * @implements {AbortSignalLike}
	 */ var AbortSignal = /** @class */ function() {
        function AbortSignal() {
            /**
	         * onabort event listener.
	         *
	         * @memberof AbortSignal
	         */ this.onabort = null;
            listenersMap.set(this, []);
            abortedMap.set(this, false);
        }
        Object.defineProperty(AbortSignal.prototype, "aborted", {
            /**
	         * Status of whether aborted or not.
	         *
	         * @readonly
	         * @type {boolean}
	         * @memberof AbortSignal
	         */ get: function() {
                if (!abortedMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
                return abortedMap.get(this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbortSignal, "none", {
            /**
	         * Creates a new AbortSignal instance that will never be aborted.
	         *
	         * @readonly
	         * @static
	         * @type {AbortSignal}
	         * @memberof AbortSignal
	         */ get: function() {
                return new AbortSignal();
            },
            enumerable: true,
            configurable: true
        });
        /**
	     * Added new "abort" event listener, only support "abort" event.
	     *
	     * @param {"abort"} _type Only support "abort" event
	     * @param {(this: AbortSignalLike, ev: any) => any} listener
	     * @memberof AbortSignal
	     */ AbortSignal.prototype.addEventListener = function(// tslint:disable-next-line:variable-name
        _type, listener) {
            if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
            var listeners = listenersMap.get(this);
            listeners.push(listener);
        };
        /**
	     * Remove "abort" event listener, only support "abort" event.
	     *
	     * @param {"abort"} _type Only support "abort" event
	     * @param {(this: AbortSignalLike, ev: any) => any} listener
	     * @memberof AbortSignal
	     */ AbortSignal.prototype.removeEventListener = function(// tslint:disable-next-line:variable-name
        _type, listener) {
            if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
            var listeners = listenersMap.get(this);
            var index = listeners.indexOf(listener);
            if (index > -1) listeners.splice(index, 1);
        };
        /**
	     * Dispatches a synthetic event to the AbortSignal.
	     */ AbortSignal.prototype.dispatchEvent = function(_event) {
            throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
        };
        return AbortSignal;
    }();
    /**
	 * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.
	 * Will try to trigger abort event for all linked AbortSignal nodes.
	 *
	 * - If there is a timeout, the timer will be cancelled.
	 * - If aborted is true, nothing will happen.
	 *
	 * @returns
	 * @internal
	 */ function abortSignal(signal) {
        if (signal.aborted) return;
        if (signal.onabort) signal.onabort.call(signal);
        var listeners = listenersMap.get(signal);
        if (listeners) listeners.forEach(function(listener) {
            listener.call(signal, {
                type: "abort"
            });
        });
        abortedMap.set(signal, true);
    }
    /**
	 * This error is thrown when an asynchronous operation has been aborted.
	 * Check for this error by testing the `name` that the name property of the
	 * error matches `"AbortError"`.
	 *
	 * @example
	 * const controller = new AbortController();
	 * controller.abort();
	 * try {
	 *   doAsyncWork(controller.signal)
	 * } catch (e) {
	 *   if (e.name === 'AbortError') {
	 *     // handle abort error here.
	 *   }
	 * }
	 */ var AbortError = /** @class */ function(_super) {
        __extends$1(AbortError, _super);
        function AbortError(message) {
            var _this = _super.call(this, message) || this;
            _this.name = "AbortError";
            return _this;
        }
        return AbortError;
    }(Error);
    /**
	 * An AbortController provides an AbortSignal and the associated controls to signal
	 * that an asynchronous operation should be aborted.
	 *
	 * @example
	 * // Abort an operation when another event fires
	 * const controller = new AbortController();
	 * const signal = controller.signal;
	 * doAsyncWork(signal);
	 * button.addEventListener('click', () => controller.abort());
	 *
	 * @example
	 * // Share aborter cross multiple operations in 30s
	 * // Upload the same data to 2 different data centers at the same time,
	 * // abort another when any of them is finished
	 * const controller = AbortController.withTimeout(30 * 1000);
	 * doAsyncWork(controller.signal).then(controller.abort);
	 * doAsyncWork(controller.signal).then(controller.abort);
	 *
	 * @example
	 * // Cascaded aborting
	 * // All operations can't take more than 30 seconds
	 * const aborter = Aborter.timeout(30 * 1000);
	 *
	 * // Following 2 operations can't take more than 25 seconds
	 * await doAsyncWork(aborter.withTimeout(25 * 1000));
	 * await doAsyncWork(aborter.withTimeout(25 * 1000));
	 *
	 * @export
	 * @class AbortController
	 * @implements {AbortSignalLike}
	 */ var AbortController = /** @class */ function() {
        function AbortController(parentSignals) {
            var _this = this;
            this._signal = new AbortSignal();
            if (!parentSignals) return;
            // coerce parentSignals into an array
            if (!Array.isArray(parentSignals)) parentSignals = arguments;
            for(var _i = 0, parentSignals_1 = parentSignals; _i < parentSignals_1.length; _i++){
                var parentSignal = parentSignals_1[_i];
                // if the parent signal has already had abort() called,
                // then call abort on this signal as well.
                if (parentSignal.aborted) this.abort();
                else // when the parent signal aborts, this signal should as well.
                parentSignal.addEventListener("abort", function() {
                    _this.abort();
                });
            }
        }
        Object.defineProperty(AbortController.prototype, "signal", {
            /**
	         * The AbortSignal associated with this controller that will signal aborted
	         * when the abort method is called on this controller.
	         *
	         * @readonly
	         * @type {AbortSignal}
	         * @memberof AbortController
	         */ get: function() {
                return this._signal;
            },
            enumerable: true,
            configurable: true
        });
        /**
	     * Signal that any operations passed this controller's associated abort signal
	     * to cancel any remaining work and throw an `AbortError`.
	     *
	     * @memberof AbortController
	     */ AbortController.prototype.abort = function() {
            abortSignal(this._signal);
        };
        /**
	     * Creates a new AbortSignal instance that will abort after the provided ms.
	     *
	     * @static
	     * @params {number} ms Elapsed time in milliseconds to trigger an abort.
	     * @returns {AbortSignal}
	     */ AbortController.timeout = function(ms) {
            var signal = new AbortSignal();
            var timer = setTimeout(abortSignal, ms, signal);
            // Prevent the active Timer from keeping the Node.js event loop active.
            if (typeof timer.unref === "function") timer.unref();
            return signal;
        };
        return AbortController;
    }();
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    var custom = {};
    // Copyright (c) Microsoft Corporation.
    /**
	 * A class that handles the query portion of a URLBuilder.
	 */ var URLQuery = /** @class */ function() {
        function URLQuery() {
            this._rawQuery = {};
        }
        /**
	     * Get whether or not there any query parameters in this URLQuery.
	     */ URLQuery.prototype.any = function() {
            return Object.keys(this._rawQuery).length > 0;
        };
        /**
	     * Get the keys of the query string.
	     */ URLQuery.prototype.keys = function() {
            return Object.keys(this._rawQuery);
        };
        /**
	     * Set a query parameter with the provided name and value. If the parameterValue is undefined or
	     * empty, then this will attempt to remove an existing query parameter with the provided
	     * parameterName.
	     */ URLQuery.prototype.set = function(parameterName, parameterValue) {
            if (parameterName) {
                if (parameterValue !== undefined && parameterValue !== null) {
                    var newValue = Array.isArray(parameterValue) ? parameterValue : parameterValue.toString();
                    this._rawQuery[parameterName] = newValue;
                } else delete this._rawQuery[parameterName];
            }
        };
        /**
	     * Get the value of the query parameter with the provided name. If no parameter exists with the
	     * provided parameter name, then undefined will be returned.
	     */ URLQuery.prototype.get = function(parameterName) {
            return parameterName ? this._rawQuery[parameterName] : undefined;
        };
        /**
	     * Get the string representation of this query. The return value will not start with a "?".
	     */ URLQuery.prototype.toString = function() {
            var result = "";
            for(var parameterName in this._rawQuery){
                if (result) result += "&";
                var parameterValue = this._rawQuery[parameterName];
                if (Array.isArray(parameterValue)) {
                    var parameterStrings = [];
                    for(var _i = 0, parameterValue_1 = parameterValue; _i < parameterValue_1.length; _i++){
                        var parameterValueElement = parameterValue_1[_i];
                        parameterStrings.push(parameterName + "=" + parameterValueElement);
                    }
                    result += parameterStrings.join("&");
                } else result += parameterName + "=" + parameterValue;
            }
            return result;
        };
        /**
	     * Parse a URLQuery from the provided text.
	     */ URLQuery.parse = function(text) {
            var result = new URLQuery();
            if (text) {
                if (text.startsWith("?")) text = text.substring(1);
                var currentState = "ParameterName";
                var parameterName = "";
                var parameterValue = "";
                for(var i = 0; i < text.length; ++i){
                    var currentCharacter = text[i];
                    switch(currentState){
                        case "ParameterName":
                            switch(currentCharacter){
                                case "=":
                                    currentState = "ParameterValue";
                                    break;
                                case "&":
                                    parameterName = "";
                                    parameterValue = "";
                                    break;
                                default:
                                    parameterName += currentCharacter;
                                    break;
                            }
                            break;
                        case "ParameterValue":
                            switch(currentCharacter){
                                case "&":
                                    result.set(parameterName, parameterValue);
                                    parameterName = "";
                                    parameterValue = "";
                                    currentState = "ParameterName";
                                    break;
                                default:
                                    parameterValue += currentCharacter;
                                    break;
                            }
                            break;
                        default:
                            throw new Error("Unrecognized URLQuery parse state: " + currentState);
                    }
                }
                if (currentState === "ParameterValue") result.set(parameterName, parameterValue);
            }
            return result;
        };
        return URLQuery;
    }();
    /**
	 * A class that handles creating, modifying, and parsing URLs.
	 */ var URLBuilder = /** @class */ function() {
        function URLBuilder() {}
        /**
	     * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL
	     * (such as a host, port, path, or query), those parts will be added to this URL as well.
	     */ URLBuilder.prototype.setScheme = function(scheme) {
            if (!scheme) this._scheme = undefined;
            else this.set(scheme, "SCHEME");
        };
        /**
	     * Get the scheme that has been set in this URL.
	     */ URLBuilder.prototype.getScheme = function() {
            return this._scheme;
        };
        /**
	     * Set the host for this URL. If the provided host contains other parts of a URL (such as a
	     * port, path, or query), those parts will be added to this URL as well.
	     */ URLBuilder.prototype.setHost = function(host) {
            if (!host) this._host = undefined;
            else this.set(host, "SCHEME_OR_HOST");
        };
        /**
	     * Get the host that has been set in this URL.
	     */ URLBuilder.prototype.getHost = function() {
            return this._host;
        };
        /**
	     * Set the port for this URL. If the provided port contains other parts of a URL (such as a
	     * path or query), those parts will be added to this URL as well.
	     */ URLBuilder.prototype.setPort = function(port) {
            if (port === undefined || port === null || port === "") this._port = undefined;
            else this.set(port.toString(), "PORT");
        };
        /**
	     * Get the port that has been set in this URL.
	     */ URLBuilder.prototype.getPort = function() {
            return this._port;
        };
        /**
	     * Set the path for this URL. If the provided path contains a query, then it will be added to
	     * this URL as well.
	     */ URLBuilder.prototype.setPath = function(path) {
            if (!path) this._path = undefined;
            else {
                var schemeIndex = path.indexOf("://");
                if (schemeIndex !== -1) {
                    var schemeStart = path.lastIndexOf("/", schemeIndex);
                    // Make sure to only grab the URL part of the path before setting the state back to SCHEME
                    // this will handle cases such as "/a/b/c/https://microsoft.com" => "https://microsoft.com"
                    this.set(schemeStart === -1 ? path : path.substr(schemeStart + 1), "SCHEME");
                } else this.set(path, "PATH");
            }
        };
        /**
	     * Append the provided path to this URL's existing path. If the provided path contains a query,
	     * then it will be added to this URL as well.
	     */ URLBuilder.prototype.appendPath = function(path) {
            if (path) {
                var currentPath = this.getPath();
                if (currentPath) {
                    if (!currentPath.endsWith("/")) currentPath += "/";
                    if (path.startsWith("/")) path = path.substring(1);
                    path = currentPath + path;
                }
                this.set(path, "PATH");
            }
        };
        /**
	     * Get the path that has been set in this URL.
	     */ URLBuilder.prototype.getPath = function() {
            return this._path;
        };
        /**
	     * Set the query in this URL.
	     */ URLBuilder.prototype.setQuery = function(query) {
            if (!query) this._query = undefined;
            else this._query = URLQuery.parse(query);
        };
        /**
	     * Set a query parameter with the provided name and value in this URL's query. If the provided
	     * query parameter value is undefined or empty, then the query parameter will be removed if it
	     * existed.
	     */ URLBuilder.prototype.setQueryParameter = function(queryParameterName, queryParameterValue) {
            if (queryParameterName) {
                if (!this._query) this._query = new URLQuery();
                this._query.set(queryParameterName, queryParameterValue);
            }
        };
        /**
	     * Get the value of the query parameter with the provided query parameter name. If no query
	     * parameter exists with the provided name, then undefined will be returned.
	     */ URLBuilder.prototype.getQueryParameterValue = function(queryParameterName) {
            return this._query ? this._query.get(queryParameterName) : undefined;
        };
        /**
	     * Get the query in this URL.
	     */ URLBuilder.prototype.getQuery = function() {
            return this._query ? this._query.toString() : undefined;
        };
        /**
	     * Set the parts of this URL by parsing the provided text using the provided startState.
	     */ URLBuilder.prototype.set = function(text, startState) {
            var tokenizer = new URLTokenizer(text, startState);
            while(tokenizer.next()){
                var token = tokenizer.current();
                var tokenPath = void 0;
                if (token) switch(token.type){
                    case "SCHEME":
                        this._scheme = token.text || undefined;
                        break;
                    case "HOST":
                        this._host = token.text || undefined;
                        break;
                    case "PORT":
                        this._port = token.text || undefined;
                        break;
                    case "PATH":
                        tokenPath = token.text || undefined;
                        if (!this._path || this._path === "/" || tokenPath !== "/") this._path = tokenPath;
                        break;
                    case "QUERY":
                        this._query = URLQuery.parse(token.text);
                        break;
                    default:
                        throw new Error("Unrecognized URLTokenType: " + token.type);
                }
            }
        };
        URLBuilder.prototype.toString = function() {
            var result = "";
            if (this._scheme) result += this._scheme + "://";
            if (this._host) result += this._host;
            if (this._port) result += ":" + this._port;
            if (this._path) {
                if (!this._path.startsWith("/")) result += "/";
                result += this._path;
            }
            if (this._query && this._query.any()) result += "?" + this._query.toString();
            return result;
        };
        /**
	     * If the provided searchValue is found in this URLBuilder, then replace it with the provided
	     * replaceValue.
	     */ URLBuilder.prototype.replaceAll = function(searchValue, replaceValue) {
            if (searchValue) {
                this.setScheme(replaceAll(this.getScheme(), searchValue, replaceValue));
                this.setHost(replaceAll(this.getHost(), searchValue, replaceValue));
                this.setPort(replaceAll(this.getPort(), searchValue, replaceValue));
                this.setPath(replaceAll(this.getPath(), searchValue, replaceValue));
                this.setQuery(replaceAll(this.getQuery(), searchValue, replaceValue));
            }
        };
        URLBuilder.parse = function(text) {
            var result = new URLBuilder();
            result.set(text, "SCHEME_OR_HOST");
            return result;
        };
        return URLBuilder;
    }();
    var URLToken = /** @class */ function() {
        function URLToken(text, type) {
            this.text = text;
            this.type = type;
        }
        URLToken.scheme = function(text) {
            return new URLToken(text, "SCHEME");
        };
        URLToken.host = function(text) {
            return new URLToken(text, "HOST");
        };
        URLToken.port = function(text) {
            return new URLToken(text, "PORT");
        };
        URLToken.path = function(text) {
            return new URLToken(text, "PATH");
        };
        URLToken.query = function(text) {
            return new URLToken(text, "QUERY");
        };
        return URLToken;
    }();
    /**
	 * Get whether or not the provided character (single character string) is an alphanumeric (letter or
	 * digit) character.
	 */ function isAlphaNumericCharacter(character) {
        var characterCode = character.charCodeAt(0);
        return 48 /* '0' */  <= characterCode && characterCode <= 57 || 65 /* 'A' */  <= characterCode && characterCode <= 90 || 97 /* 'a' */  <= characterCode && characterCode <= 122;
    }
    /**
	 * A class that tokenizes URL strings.
	 */ var URLTokenizer = /** @class */ function() {
        function URLTokenizer(_text, state) {
            this._text = _text;
            this._textLength = _text ? _text.length : 0;
            this._currentState = state !== undefined && state !== null ? state : "SCHEME_OR_HOST";
            this._currentIndex = 0;
        }
        /**
	     * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer
	     * hasn't started or has finished tokenizing.
	     */ URLTokenizer.prototype.current = function() {
            return this._currentToken;
        };
        /**
	     * Advance to the next URLToken and return whether or not a URLToken was found.
	     */ URLTokenizer.prototype.next = function() {
            if (!hasCurrentCharacter(this)) this._currentToken = undefined;
            else switch(this._currentState){
                case "SCHEME":
                    nextScheme(this);
                    break;
                case "SCHEME_OR_HOST":
                    nextSchemeOrHost(this);
                    break;
                case "HOST":
                    nextHost(this);
                    break;
                case "PORT":
                    nextPort(this);
                    break;
                case "PATH":
                    nextPath(this);
                    break;
                case "QUERY":
                    nextQuery(this);
                    break;
                default:
                    throw new Error("Unrecognized URLTokenizerState: " + this._currentState);
            }
            return !!this._currentToken;
        };
        return URLTokenizer;
    }();
    /**
	 * Read the remaining characters from this Tokenizer's character stream.
	 */ function readRemaining(tokenizer) {
        var result = "";
        if (tokenizer._currentIndex < tokenizer._textLength) {
            result = tokenizer._text.substring(tokenizer._currentIndex);
            tokenizer._currentIndex = tokenizer._textLength;
        }
        return result;
    }
    /**
	 * Whether or not this URLTokenizer has a current character.
	 */ function hasCurrentCharacter(tokenizer) {
        return tokenizer._currentIndex < tokenizer._textLength;
    }
    /**
	 * Get the character in the text string at the current index.
	 */ function getCurrentCharacter(tokenizer) {
        return tokenizer._text[tokenizer._currentIndex];
    }
    /**
	 * Advance to the character in text that is "step" characters ahead. If no step value is provided,
	 * then step will default to 1.
	 */ function nextCharacter(tokenizer, step) {
        if (hasCurrentCharacter(tokenizer)) {
            if (!step) step = 1;
            tokenizer._currentIndex += step;
        }
    }
    /**
	 * Starting with the current character, peek "charactersToPeek" number of characters ahead in this
	 * Tokenizer's stream of characters.
	 */ function peekCharacters(tokenizer, charactersToPeek) {
        var endIndex = tokenizer._currentIndex + charactersToPeek;
        if (tokenizer._textLength < endIndex) endIndex = tokenizer._textLength;
        return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
    }
    /**
	 * Read characters from this Tokenizer until the end of the stream or until the provided condition
	 * is false when provided the current character.
	 */ function readWhile(tokenizer, condition) {
        var result = "";
        while(hasCurrentCharacter(tokenizer)){
            var currentCharacter = getCurrentCharacter(tokenizer);
            if (!condition(currentCharacter)) break;
            else {
                result += currentCharacter;
                nextCharacter(tokenizer);
            }
        }
        return result;
    }
    /**
	 * Read characters from this Tokenizer until a non-alphanumeric character or the end of the
	 * character stream is reached.
	 */ function readWhileLetterOrDigit(tokenizer) {
        return readWhile(tokenizer, function(character) {
            return isAlphaNumericCharacter(character);
        });
    }
    /**
	 * Read characters from this Tokenizer until one of the provided terminating characters is read or
	 * the end of the character stream is reached.
	 */ function readUntilCharacter(tokenizer) {
        var terminatingCharacters = [];
        for(var _i = 1; _i < arguments.length; _i++)terminatingCharacters[_i - 1] = arguments[_i];
        return readWhile(tokenizer, function(character) {
            return terminatingCharacters.indexOf(character) === -1;
        });
    }
    function nextScheme(tokenizer) {
        var scheme = readWhileLetterOrDigit(tokenizer);
        tokenizer._currentToken = URLToken.scheme(scheme);
        if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
        else tokenizer._currentState = "HOST";
    }
    function nextSchemeOrHost(tokenizer) {
        var schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
        if (!hasCurrentCharacter(tokenizer)) {
            tokenizer._currentToken = URLToken.host(schemeOrHost);
            tokenizer._currentState = "DONE";
        } else if (getCurrentCharacter(tokenizer) === ":") {
            if (peekCharacters(tokenizer, 3) === "://") {
                tokenizer._currentToken = URLToken.scheme(schemeOrHost);
                tokenizer._currentState = "HOST";
            } else {
                tokenizer._currentToken = URLToken.host(schemeOrHost);
                tokenizer._currentState = "PORT";
            }
        } else {
            tokenizer._currentToken = URLToken.host(schemeOrHost);
            if (getCurrentCharacter(tokenizer) === "/") tokenizer._currentState = "PATH";
            else tokenizer._currentState = "QUERY";
        }
    }
    function nextHost(tokenizer) {
        if (peekCharacters(tokenizer, 3) === "://") nextCharacter(tokenizer, 3);
        var host = readUntilCharacter(tokenizer, ":", "/", "?");
        tokenizer._currentToken = URLToken.host(host);
        if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
        else if (getCurrentCharacter(tokenizer) === ":") tokenizer._currentState = "PORT";
        else if (getCurrentCharacter(tokenizer) === "/") tokenizer._currentState = "PATH";
        else tokenizer._currentState = "QUERY";
    }
    function nextPort(tokenizer) {
        if (getCurrentCharacter(tokenizer) === ":") nextCharacter(tokenizer);
        var port = readUntilCharacter(tokenizer, "/", "?");
        tokenizer._currentToken = URLToken.port(port);
        if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
        else if (getCurrentCharacter(tokenizer) === "/") tokenizer._currentState = "PATH";
        else tokenizer._currentState = "QUERY";
    }
    function nextPath(tokenizer) {
        var path = readUntilCharacter(tokenizer, "?");
        tokenizer._currentToken = URLToken.path(path);
        if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
        else tokenizer._currentState = "QUERY";
    }
    function nextQuery(tokenizer) {
        if (getCurrentCharacter(tokenizer) === "?") nextCharacter(tokenizer);
        var query = readRemaining(tokenizer);
        tokenizer._currentToken = URLToken.query(query);
        tokenizer._currentState = "DONE";
    }
    // Copyright (c) Microsoft Corporation.
    var RedactedString = "REDACTED";
    var defaultAllowedHeaderNames = [
        "x-ms-client-request-id",
        "x-ms-return-client-request-id",
        "x-ms-useragent",
        "x-ms-correlation-request-id",
        "x-ms-request-id",
        "client-request-id",
        "return-client-request-id",
        "traceparent",
        "Access-Control-Allow-Credentials",
        "Access-Control-Allow-Headers",
        "Access-Control-Allow-Methods",
        "Access-Control-Allow-Origin",
        "Access-Control-Expose-Headers",
        "Access-Control-Max-Age",
        "Access-Control-Request-Headers",
        "Access-Control-Request-Method",
        "Origin",
        "Accept",
        "Cache-Control",
        "Connection",
        "Content-Length",
        "Content-Type",
        "Date",
        "ETag",
        "Expires",
        "If-Match",
        "If-Modified-Since",
        "If-None-Match",
        "If-Unmodified-Since",
        "Last-Modified",
        "Pragma",
        "Request-Id",
        "Retry-After",
        "Server",
        "Transfer-Encoding",
        "User-Agent"
    ];
    var defaultAllowedQueryParameters = [
        "api-version"
    ];
    var Sanitizer = /** @class */ function() {
        function Sanitizer(_a) {
            var _b = _a === void 0 ? {} : _a, _c = _b.allowedHeaderNames, allowedHeaderNames = _c === void 0 ? [] : _c, _d = _b.allowedQueryParameters, allowedQueryParameters = _d === void 0 ? [] : _d;
            allowedHeaderNames = Array.isArray(allowedHeaderNames) ? defaultAllowedHeaderNames.concat(allowedHeaderNames) : defaultAllowedHeaderNames;
            allowedQueryParameters = Array.isArray(allowedQueryParameters) ? defaultAllowedQueryParameters.concat(allowedQueryParameters) : defaultAllowedQueryParameters;
            this.allowedHeaderNames = new Set(allowedHeaderNames.map(function(n) {
                return n.toLowerCase();
            }));
            this.allowedQueryParameters = new Set(allowedQueryParameters.map(function(p) {
                return p.toLowerCase();
            }));
        }
        Sanitizer.prototype.sanitize = function(obj) {
            return JSON.stringify(obj, this.replacer.bind(this), 2);
        };
        Sanitizer.prototype.replacer = function(key, value) {
            // Ensure Errors include their interesting non-enumerable members
            if (value instanceof Error) return __assign(__assign({}, value), {
                name: value.name,
                message: value.message
            });
            if (key === "_headersMap") return this.sanitizeHeaders(key, value);
            else if (key === "url") return this.sanitizeUrl(value);
            else if (key === "query") return this.sanitizeQuery(value);
            else if (key === "body") // Don't log the request body
            return undefined;
            else if (key === "response") // Don't log response again
            return undefined;
            else if (key === "operationSpec") // When using sendOperationRequest, the request carries a massive
            // field with the autorest spec. No need to log it.
            return undefined;
            return value;
        };
        Sanitizer.prototype.sanitizeHeaders = function(_, value) {
            return this.sanitizeObject(value, this.allowedHeaderNames, function(v, k) {
                return v[k].value;
            });
        };
        Sanitizer.prototype.sanitizeQuery = function(value) {
            return this.sanitizeObject(value, this.allowedQueryParameters, function(v, k) {
                return v[k];
            });
        };
        Sanitizer.prototype.sanitizeObject = function(value, allowedKeys, accessor) {
            if (typeof value !== "object" || value === null) return value;
            var sanitized = {};
            for(var _i = 0, _a = Object.keys(value); _i < _a.length; _i++){
                var k = _a[_i];
                if (allowedKeys.has(k.toLowerCase())) sanitized[k] = accessor(value, k);
                else sanitized[k] = RedactedString;
            }
            return sanitized;
        };
        Sanitizer.prototype.sanitizeUrl = function(value) {
            if (typeof value !== "string" || value === null) return value;
            var urlBuilder = URLBuilder.parse(value);
            var queryString = urlBuilder.getQuery();
            if (!queryString) return value;
            var query = URLQuery.parse(queryString);
            for(var _i = 0, _a = query.keys(); _i < _a.length; _i++){
                var k = _a[_i];
                if (!this.allowedQueryParameters.has(k.toLowerCase())) query.set(k, RedactedString);
            }
            urlBuilder.setQuery(query.toString());
            return urlBuilder.toString();
        };
        return Sanitizer;
    }();
    // Copyright (c) Microsoft Corporation.
    var errorSanitizer = new Sanitizer();
    var RestError = /** @class */ function(_super) {
        __extends(RestError, _super);
        function RestError(message, code, statusCode, request, response) {
            var _this = _super.call(this, message) || this;
            _this.name = "RestError";
            _this.code = code;
            _this.statusCode = statusCode;
            _this.request = request;
            _this.response = response;
            Object.setPrototypeOf(_this, RestError.prototype);
            return _this;
        }
        /**
	     * Logging method for util.inspect in Node
	     */ RestError.prototype[custom] = function() {
            return "RestError: " + this.message + " \n " + errorSanitizer.sanitize(this);
        };
        RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
        RestError.PARSE_ERROR = "PARSE_ERROR";
        return RestError;
    }(Error);
    // Copyright (c) Microsoft Corporation.
    /**
	 * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
	 */ var XhrHttpClient = /** @class */ function() {
        function XhrHttpClient() {}
        XhrHttpClient.prototype.sendRequest = function(request) {
            var xhr = new XMLHttpRequest();
            if (request.proxySettings) throw new Error("HTTP proxy is not supported in browser environment");
            var abortSignal = request.abortSignal;
            if (abortSignal) {
                if (abortSignal.aborted) return Promise.reject(new AbortError("The operation was aborted."));
                var listener_1 = function() {
                    xhr.abort();
                };
                abortSignal.addEventListener("abort", listener_1);
                xhr.addEventListener("readystatechange", function() {
                    if (xhr.readyState === XMLHttpRequest.DONE) abortSignal.removeEventListener("abort", listener_1);
                });
            }
            addProgressListener(xhr.upload, request.onUploadProgress);
            addProgressListener(xhr, request.onDownloadProgress);
            if (request.formData) {
                var formData = request.formData;
                var requestForm_1 = new FormData();
                var appendFormValue = function(key, value) {
                    // eslint-disable-next-line no-prototype-builtins
                    if (value && value.hasOwnProperty("value") && value.hasOwnProperty("options")) requestForm_1.append(key, value.value, value.options);
                    else requestForm_1.append(key, value);
                };
                for(var _i = 0, _a = Object.keys(formData); _i < _a.length; _i++){
                    var formKey = _a[_i];
                    var formValue = formData[formKey];
                    if (Array.isArray(formValue)) for(var j = 0; j < formValue.length; j++)appendFormValue(formKey, formValue[j]);
                    else appendFormValue(formKey, formValue);
                }
                request.body = requestForm_1;
                request.formData = undefined;
                var contentType = request.headers.get("Content-Type");
                if (contentType && contentType.indexOf("multipart/form-data") !== -1) // browser will automatically apply a suitable content-type header
                request.headers.remove("Content-Type");
            }
            xhr.open(request.method, request.url);
            xhr.timeout = request.timeout;
            xhr.withCredentials = request.withCredentials;
            for(var _b = 0, _c = request.headers.headersArray(); _b < _c.length; _b++){
                var header = _c[_b];
                xhr.setRequestHeader(header.name, header.value);
            }
            xhr.responseType = request.streamResponseBody ? "blob" : "text";
            // tslint:disable-next-line:no-null-keyword
            xhr.send(request.body === undefined ? null : request.body);
            if (request.streamResponseBody) return new Promise(function(resolve, reject) {
                xhr.addEventListener("readystatechange", function() {
                    // Resolve as soon as headers are loaded
                    if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
                        var blobBody = new Promise(function(resolve, reject) {
                            xhr.addEventListener("load", function() {
                                resolve(xhr.response);
                            });
                            rejectOnTerminalEvent(request, xhr, reject);
                        });
                        resolve({
                            request: request,
                            status: xhr.status,
                            headers: parseHeaders(xhr),
                            blobBody: blobBody
                        });
                    }
                });
                rejectOnTerminalEvent(request, xhr, reject);
            });
            else return new Promise(function(resolve, reject) {
                xhr.addEventListener("load", function() {
                    return resolve({
                        request: request,
                        status: xhr.status,
                        headers: parseHeaders(xhr),
                        bodyAsText: xhr.responseText
                    });
                });
                rejectOnTerminalEvent(request, xhr, reject);
            });
        };
        return XhrHttpClient;
    }();
    function addProgressListener(xhr, listener) {
        if (listener) xhr.addEventListener("progress", function(rawEvent) {
            return listener({
                loadedBytes: rawEvent.loaded
            });
        });
    }
    // exported locally for testing
    function parseHeaders(xhr) {
        var responseHeaders = new HttpHeaders();
        var headerLines = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);
        for(var _i = 0, headerLines_1 = headerLines; _i < headerLines_1.length; _i++){
            var line = headerLines_1[_i];
            var index = line.indexOf(":");
            var headerName = line.slice(0, index);
            var headerValue = line.slice(index + 2);
            responseHeaders.set(headerName, headerValue);
        }
        return responseHeaders;
    }
    function rejectOnTerminalEvent(request, xhr, reject) {
        xhr.addEventListener("error", function() {
            return reject(new RestError("Failed to send request to " + request.url, RestError.REQUEST_SEND_ERROR, undefined, request));
        });
        var abortError = new AbortError("The operation was aborted.");
        xhr.addEventListener("abort", function() {
            return reject(abortError);
        });
        xhr.addEventListener("timeout", function() {
            return reject(abortError);
        });
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
	 * The different levels of logs that can be used with the HttpPipelineLogger.
	 */ var HttpPipelineLogLevel;
    (function(HttpPipelineLogLevel) {
        /**
	     * A log level that indicates that no logs will be logged.
	     */ HttpPipelineLogLevel[HttpPipelineLogLevel["OFF"] = 0] = "OFF";
        /**
	     * An error log.
	     */ HttpPipelineLogLevel[HttpPipelineLogLevel["ERROR"] = 1] = "ERROR";
        /**
	     * A warning log.
	     */ HttpPipelineLogLevel[HttpPipelineLogLevel["WARNING"] = 2] = "WARNING";
        /**
	     * An information log.
	     */ HttpPipelineLogLevel[HttpPipelineLogLevel["INFO"] = 3] = "INFO";
    })(HttpPipelineLogLevel || (HttpPipelineLogLevel = {}));
    /**
	 * Converts an OperationOptions to a RequestOptionsBase
	 *
	 * @param opts OperationOptions object to convert to RequestOptionsBase
	 */ function operationOptionsToRequestOptionsBase(opts) {
        var requestOptions = opts.requestOptions, tracingOptions = opts.tracingOptions, additionalOptions = __rest(opts, [
            "requestOptions",
            "tracingOptions"
        ]);
        var result = additionalOptions;
        if (requestOptions) result = __assign(__assign({}, result), requestOptions);
        if (tracingOptions) result.spanOptions = tracingOptions.spanOptions;
        return result;
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
	 * Tests an object to determine whether it implements TokenCredential.
	 *
	 * @param credential The assumed TokenCredential to be tested.
	 */ function isTokenCredential(credential) {
        // Check for an object with a 'getToken' function and possibly with
        // a 'signRequest' function.  We do this check to make sure that
        // a ServiceClientCredentials implementor (like TokenClientCredentials
        // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
        // it doesn't actually implement TokenCredential also.
        return credential && typeof credential.getToken === "function" && (credential.signRequest === undefined || credential.getToken.length > 0);
    }
    // Copyright (c) Microsoft Corporation.
    var BaseRequestPolicy = /** @class */ function() {
        function BaseRequestPolicy(_nextPolicy, _options) {
            this._nextPolicy = _nextPolicy;
            this._options = _options;
        }
        /**
	     * Get whether or not a log with the provided log level should be logged.
	     * @param logLevel The log level of the log that will be logged.
	     * @returns Whether or not a log with the provided log level should be logged.
	     */ BaseRequestPolicy.prototype.shouldLog = function(logLevel) {
            return this._options.shouldLog(logLevel);
        };
        /**
	     * Attempt to log the provided message to the provided logger. If no logger was provided or if
	     * the log level does not meat the logger's threshold, then nothing will be logged.
	     * @param logLevel The log level of this log.
	     * @param message The message of this log.
	     */ BaseRequestPolicy.prototype.log = function(logLevel, message) {
            this._options.log(logLevel, message);
        };
        return BaseRequestPolicy;
    }();
    /**
	 * Optional properties that can be used when creating a RequestPolicy.
	 */ var RequestPolicyOptions = /** @class */ function() {
        function RequestPolicyOptions(_logger) {
            this._logger = _logger;
        }
        /**
	     * Get whether or not a log with the provided log level should be logged.
	     * @param logLevel The log level of the log that will be logged.
	     * @returns Whether or not a log with the provided log level should be logged.
	     */ RequestPolicyOptions.prototype.shouldLog = function(logLevel) {
            return !!this._logger && logLevel !== HttpPipelineLogLevel.OFF && logLevel <= this._logger.minimumLogLevel;
        };
        /**
	     * Attempt to log the provided message to the provided logger. If no logger was provided or if
	     * the log level does not meet the logger's threshold, then nothing will be logged.
	     * @param logLevel The log level of this log.
	     * @param message The message of this log.
	     */ RequestPolicyOptions.prototype.log = function(logLevel, message) {
            if (this._logger && this.shouldLog(logLevel)) this._logger.log(logLevel, message);
        };
        return RequestPolicyOptions;
    }();
    // Copyright (c) Microsoft Corporation. All rights reserved.
    var logFunction = console.debug || console.log;
    function log() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        logFunction.apply(void 0, __spread(args));
    }
    // Copyright (c) Microsoft Corporation. All rights reserved.
    var debugEnvVariable = undefined;
    var enabledString;
    var enabledNamespaces = [];
    var skippedNamespaces = [];
    var debuggers = [];
    if (debugEnvVariable) enable(debugEnvVariable);
    function enable(namespaces) {
        var e_1, _a, e_2, _b;
        enabledString = namespaces;
        enabledNamespaces = [];
        skippedNamespaces = [];
        var wildcard = /\*/g;
        var namespaceList = namespaces.split(",").map(function(ns) {
            return ns.trim().replace(wildcard, ".*?");
        });
        try {
            for(var namespaceList_1 = __values(namespaceList), namespaceList_1_1 = namespaceList_1.next(); !namespaceList_1_1.done; namespaceList_1_1 = namespaceList_1.next()){
                var ns = namespaceList_1_1.value;
                if (ns.startsWith("-")) skippedNamespaces.push(new RegExp("^" + ns.substr(1) + "$"));
                else enabledNamespaces.push(new RegExp("^" + ns + "$"));
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (namespaceList_1_1 && !namespaceList_1_1.done && (_a = namespaceList_1.return)) _a.call(namespaceList_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        try {
            for(var debuggers_1 = __values(debuggers), debuggers_1_1 = debuggers_1.next(); !debuggers_1_1.done; debuggers_1_1 = debuggers_1.next()){
                var instance = debuggers_1_1.value;
                instance.enabled = enabled(instance.namespace);
            }
        } catch (e_2_1) {
            e_2 = {
                error: e_2_1
            };
        } finally{
            try {
                if (debuggers_1_1 && !debuggers_1_1.done && (_b = debuggers_1.return)) _b.call(debuggers_1);
            } finally{
                if (e_2) throw e_2.error;
            }
        }
    }
    function enabled(namespace) {
        var e_3, _a, e_4, _b;
        if (namespace.endsWith("*")) return true;
        try {
            for(var skippedNamespaces_1 = __values(skippedNamespaces), skippedNamespaces_1_1 = skippedNamespaces_1.next(); !skippedNamespaces_1_1.done; skippedNamespaces_1_1 = skippedNamespaces_1.next()){
                var skipped = skippedNamespaces_1_1.value;
                if (skipped.test(namespace)) return false;
            }
        } catch (e_3_1) {
            e_3 = {
                error: e_3_1
            };
        } finally{
            try {
                if (skippedNamespaces_1_1 && !skippedNamespaces_1_1.done && (_a = skippedNamespaces_1.return)) _a.call(skippedNamespaces_1);
            } finally{
                if (e_3) throw e_3.error;
            }
        }
        try {
            for(var enabledNamespaces_1 = __values(enabledNamespaces), enabledNamespaces_1_1 = enabledNamespaces_1.next(); !enabledNamespaces_1_1.done; enabledNamespaces_1_1 = enabledNamespaces_1.next()){
                var enabled_1 = enabledNamespaces_1_1.value;
                if (enabled_1.test(namespace)) return true;
            }
        } catch (e_4_1) {
            e_4 = {
                error: e_4_1
            };
        } finally{
            try {
                if (enabledNamespaces_1_1 && !enabledNamespaces_1_1.done && (_b = enabledNamespaces_1.return)) _b.call(enabledNamespaces_1);
            } finally{
                if (e_4) throw e_4.error;
            }
        }
        return false;
    }
    function disable() {
        var result = enabledString || "";
        enable("");
        return result;
    }
    function createDebugger(namespace) {
        function debug() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
            if (!newDebugger.enabled) return;
            if (args.length > 0) args[0] = namespace + " " + args[0];
            newDebugger.log.apply(newDebugger, __spread(args));
        }
        var newDebugger = Object.assign(debug, {
            enabled: enabled(namespace),
            destroy: destroy,
            log: debugObj.log,
            namespace: namespace,
            extend: extend
        });
        debuggers.push(newDebugger);
        return newDebugger;
    }
    function destroy() {
        var index = debuggers.indexOf(this);
        if (index >= 0) {
            debuggers.splice(index, 1);
            return true;
        }
        return false;
    }
    function extend(namespace) {
        var newDebugger = createDebugger(this.namespace + ":" + namespace);
        newDebugger.log = this.log;
        return newDebugger;
    }
    var debugObj = Object.assign(function(namespace) {
        return createDebugger(namespace);
    }, {
        enable: enable,
        enabled: enabled,
        disable: disable,
        log: log
    });
    // Copyright (c) Microsoft Corporation. All rights reserved.
    var registeredLoggers = new Set();
    var logLevelFromEnv = undefined;
    var azureLogLevel;
    /**
	 * The AzureLogger provides a mechanism for overriding where logs are output to.
	 * By default, logs are sent to stderr.
	 * Override the `log` method to redirect logs to another location.
	 */ var AzureLogger = debugObj("azure");
    AzureLogger.log = function() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
        debugObj.log.apply(debugObj, __spread(args));
    };
    var AZURE_LOG_LEVELS = [
        "verbose",
        "info",
        "warning",
        "error"
    ];
    if (logLevelFromEnv) {
        // avoid calling setLogLevel because we don't want a mis-set environment variable to crash
        if (isAzureLogLevel(logLevelFromEnv)) setLogLevel(logLevelFromEnv);
        else console.error("AZURE_LOG_LEVEL set to unknown log level '" + logLevelFromEnv + "'; logging is not enabled. Acceptable values: " + AZURE_LOG_LEVELS.join(", ") + ".");
    }
    /**
	 * Immediately enables logging at the specified log level.
	 * @param level The log level to enable for logging.
	 * Options from most verbose to least verbose are:
	 * - verbose
	 * - info
	 * - warning
	 * - error
	 */ function setLogLevel(level) {
        var e_1, _a;
        if (level && !isAzureLogLevel(level)) throw new Error("Unknown log level '" + level + "'. Acceptable values: " + AZURE_LOG_LEVELS.join(","));
        azureLogLevel = level;
        var enabledNamespaces = [];
        try {
            for(var registeredLoggers_1 = __values(registeredLoggers), registeredLoggers_1_1 = registeredLoggers_1.next(); !registeredLoggers_1_1.done; registeredLoggers_1_1 = registeredLoggers_1.next()){
                var logger = registeredLoggers_1_1.value;
                if (shouldEnable(logger)) enabledNamespaces.push(logger.namespace);
            }
        } catch (e_1_1) {
            e_1 = {
                error: e_1_1
            };
        } finally{
            try {
                if (registeredLoggers_1_1 && !registeredLoggers_1_1.done && (_a = registeredLoggers_1.return)) _a.call(registeredLoggers_1);
            } finally{
                if (e_1) throw e_1.error;
            }
        }
        debugObj.enable(enabledNamespaces.join(","));
    }
    var levelMap = {
        verbose: 400,
        info: 300,
        warning: 200,
        error: 100
    };
    /**
	 * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.
	 * @param namespace The name of the SDK package.
	 * @ignore
	 */ function createClientLogger(namespace) {
        var clientRootLogger = AzureLogger.extend(namespace);
        patchLogMethod(AzureLogger, clientRootLogger);
        return {
            error: createLogger(clientRootLogger, "error"),
            warning: createLogger(clientRootLogger, "warning"),
            info: createLogger(clientRootLogger, "info"),
            verbose: createLogger(clientRootLogger, "verbose")
        };
    }
    function patchLogMethod(parent, child) {
        child.log = function() {
            var args = [];
            for(var _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
            parent.log.apply(parent, __spread(args));
        };
    }
    function createLogger(parent, level) {
        var logger = Object.assign(parent.extend(level), {
            level: level
        });
        patchLogMethod(parent, logger);
        if (shouldEnable(logger)) {
            var enabledNamespaces = debugObj.disable();
            debugObj.enable(enabledNamespaces + "," + logger.namespace);
        }
        registeredLoggers.add(logger);
        return logger;
    }
    function shouldEnable(logger) {
        if (azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]) return true;
        else return false;
    }
    function isAzureLogLevel(logLevel) {
        return AZURE_LOG_LEVELS.includes(logLevel);
    }
    // Copyright (c) Microsoft Corporation.
    var logger = createClientLogger("core-http");
    // Copyright (c) Microsoft Corporation.
    function logPolicy(loggingOptions) {
        if (loggingOptions === void 0) loggingOptions = {};
        return {
            create: function(nextPolicy, options) {
                return new LogPolicy(nextPolicy, options, loggingOptions);
            }
        };
    }
    var LogPolicy = /** @class */ function(_super) {
        __extends(LogPolicy, _super);
        function LogPolicy(nextPolicy, options, _a) {
            var _b = _a === void 0 ? {} : _a, _c = _b.logger, logger$1 = _c === void 0 ? logger.info : _c, _d = _b.allowedHeaderNames, allowedHeaderNames = _d === void 0 ? [] : _d, _e = _b.allowedQueryParameters, allowedQueryParameters = _e === void 0 ? [] : _e;
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.logger = logger$1;
            _this.sanitizer = new Sanitizer({
                allowedHeaderNames: allowedHeaderNames,
                allowedQueryParameters: allowedQueryParameters
            });
            return _this;
        }
        Object.defineProperty(LogPolicy.prototype, "allowedHeaderNames", {
            /**
	         * Header names whose values will be logged when logging is enabled. Defaults to
	         * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
	         * specified in this field will be added to that list.  Any other values will
	         * be written to logs as "REDACTED".
	         * @deprecated Pass these into the constructor instead.
	         */ get: function() {
                return this.sanitizer.allowedHeaderNames;
            },
            /**
	         * Header names whose values will be logged when logging is enabled. Defaults to
	         * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
	         * specified in this field will be added to that list.  Any other values will
	         * be written to logs as "REDACTED".
	         * @deprecated Pass these into the constructor instead.
	         */ set: function(allowedHeaderNames) {
                this.sanitizer.allowedHeaderNames = allowedHeaderNames;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LogPolicy.prototype, "allowedQueryParameters", {
            /**
	         * Query string names whose values will be logged when logging is enabled. By default no
	         * query string values are logged.
	         * @deprecated Pass these into the constructor instead.
	         */ get: function() {
                return this.sanitizer.allowedQueryParameters;
            },
            /**
	         * Query string names whose values will be logged when logging is enabled. By default no
	         * query string values are logged.
	         * @deprecated Pass these into the constructor instead.
	         */ set: function(allowedQueryParameters) {
                this.sanitizer.allowedQueryParameters = allowedQueryParameters;
            },
            enumerable: false,
            configurable: true
        });
        LogPolicy.prototype.sendRequest = function(request) {
            var _this = this;
            if (!this.logger.enabled) return this._nextPolicy.sendRequest(request);
            this.logRequest(request);
            return this._nextPolicy.sendRequest(request).then(function(response) {
                return _this.logResponse(response);
            });
        };
        LogPolicy.prototype.logRequest = function(request) {
            this.logger("Request: " + this.sanitizer.sanitize(request));
        };
        LogPolicy.prototype.logResponse = function(response) {
            this.logger("Response status code: " + response.status);
            this.logger("Headers: " + this.sanitizer.sanitize(response.headers));
            return response;
        };
        return LogPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
	 * Get the path to this parameter's value as a dotted string (a.b.c).
	 * @param parameter The parameter to get the path string for.
	 * @returns The path to this parameter's value as a dotted string.
	 */ function getPathStringFromParameter(parameter) {
        return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
    }
    function getPathStringFromParameterPath(parameterPath, mapper) {
        var result;
        if (typeof parameterPath === "string") result = parameterPath;
        else if (Array.isArray(parameterPath)) result = parameterPath.join(".");
        else result = mapper.serializedName;
        return result;
    }
    // Copyright (c) Microsoft Corporation.
    function isStreamOperation(operationSpec) {
        var result = false;
        for(var statusCode in operationSpec.responses){
            var operationResponse = operationSpec.responses[statusCode];
            if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperType.Stream) {
                result = true;
                break;
            }
        }
        return result;
    }
    // Copyright (c) Microsoft Corporation.
    // tslint:disable-next-line:no-null-keyword
    var doc = document.implementation.createDocument(null, null, null);
    var parser = new DOMParser();
    function parseXML(str, opts) {
        var _a, _b, _c;
        if (opts === void 0) opts = {};
        try {
            var updatedOptions = {
                rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "",
                includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
                xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
            };
            var dom = parser.parseFromString(str, "application/xml");
            throwIfError(dom);
            var obj = void 0;
            if (updatedOptions.includeRoot) obj = domToObject(dom, updatedOptions);
            else obj = domToObject(dom.childNodes[0], updatedOptions);
            return Promise.resolve(obj);
        } catch (err) {
            return Promise.reject(err);
        }
    }
    var errorNS = "";
    try {
        errorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI;
    } catch (ignored) {
    // Most browsers will return a document containing <parsererror>, but IE will throw.
    }
    function throwIfError(dom) {
        if (errorNS) {
            var parserErrors = dom.getElementsByTagNameNS(errorNS, "parsererror");
            if (parserErrors.length) throw new Error(parserErrors.item(0).innerHTML);
        }
    }
    function isElement(node) {
        return !!node.attributes;
    }
    /**
	 * Get the Element-typed version of the provided Node if the provided node is an element with
	 * attributes. If it isn't, then undefined is returned.
	 */ function asElementWithAttributes(node) {
        return isElement(node) && node.hasAttributes() ? node : undefined;
    }
    function domToObject(node, options) {
        var result = {};
        var childNodeCount = node.childNodes.length;
        var firstChildNode = node.childNodes[0];
        var onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;
        var elementWithAttributes = asElementWithAttributes(node);
        if (elementWithAttributes) {
            result[XML_ATTRKEY] = {};
            for(var i = 0; i < elementWithAttributes.attributes.length; i++){
                var attr = elementWithAttributes.attributes[i];
                result[XML_ATTRKEY][attr.nodeName] = attr.nodeValue;
            }
            if (onlyChildTextValue) result[options.xmlCharKey] = onlyChildTextValue;
        } else if (childNodeCount === 0) result = "";
        else if (onlyChildTextValue) result = onlyChildTextValue;
        if (!onlyChildTextValue) for(var i = 0; i < childNodeCount; i++){
            var child = node.childNodes[i];
            // Ignore leading/trailing whitespace nodes
            if (child.nodeType !== Node.TEXT_NODE) {
                var childObject = domToObject(child, options);
                if (!result[child.nodeName]) result[child.nodeName] = childObject;
                else if (Array.isArray(result[child.nodeName])) result[child.nodeName].push(childObject);
                else result[child.nodeName] = [
                    result[child.nodeName],
                    childObject
                ];
            }
        }
        return result;
    }
    var serializer = new XMLSerializer();
    function stringifyXML(content, opts) {
        var _a, _b, _c;
        if (opts === void 0) opts = {};
        var updatedOptions = {
            rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "root",
            includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
        };
        var dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];
        return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + serializer.serializeToString(dom);
    }
    function buildAttributes(attrs) {
        var result = [];
        for(var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++){
            var key = _a[_i];
            var attr = doc.createAttribute(key);
            attr.value = attrs[key].toString();
            result.push(attr);
        }
        return result;
    }
    function buildNode(obj, elementName, options) {
        if (obj === undefined || obj === null || typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
            var elem = doc.createElement(elementName);
            elem.textContent = obj === undefined || obj === null ? "" : obj.toString();
            return [
                elem
            ];
        } else if (Array.isArray(obj)) {
            var result = [];
            for(var _i = 0, obj_1 = obj; _i < obj_1.length; _i++){
                var arrayElem = obj_1[_i];
                for(var _a = 0, _b = buildNode(arrayElem, elementName, options); _a < _b.length; _a++){
                    var child = _b[_a];
                    result.push(child);
                }
            }
            return result;
        } else if (typeof obj === "object") {
            var elem = doc.createElement(elementName);
            for(var _c = 0, _d = Object.keys(obj); _c < _d.length; _c++){
                var key = _d[_c];
                if (key === XML_ATTRKEY) for(var _e = 0, _f = buildAttributes(obj[key]); _e < _f.length; _e++){
                    var attr = _f[_e];
                    elem.attributes.setNamedItem(attr);
                }
                else if (key === options.xmlCharKey) elem.textContent = obj[key].toString();
                else for(var _g = 0, _h = buildNode(obj[key], key, options); _g < _h.length; _g++){
                    var child = _h[_g];
                    elem.appendChild(child);
                }
            }
            return [
                elem
            ];
        } else throw new Error("Illegal value passed to buildObject: " + obj);
    }
    // Copyright (c) Microsoft Corporation.
    /**
	 * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they
	 * pass through the HTTP pipeline.
	 */ function deserializationPolicy(deserializationContentTypes, parsingOptions) {
        return {
            create: function(nextPolicy, options) {
                return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);
            }
        };
    }
    var defaultJsonContentTypes = [
        "application/json",
        "text/json"
    ];
    var defaultXmlContentTypes = [
        "application/xml",
        "application/atom+xml"
    ];
    var DefaultDeserializationOptions = {
        expectedContentTypes: {
            json: defaultJsonContentTypes,
            xml: defaultXmlContentTypes
        }
    };
    /**
	 * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the
	 * HTTP pipeline.
	 */ var DeserializationPolicy = /** @class */ function(_super) {
        __extends(DeserializationPolicy, _super);
        function DeserializationPolicy(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions) {
            if (parsingOptions === void 0) parsingOptions = {};
            var _a;
            var _this = _super.call(this, nextPolicy, requestPolicyOptions) || this;
            _this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes;
            _this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes;
            _this.xmlCharKey = (_a = parsingOptions.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;
            return _this;
        }
        DeserializationPolicy.prototype.sendRequest = function(request) {
            return __awaiter(this, void 0, void 0, function() {
                var _this = this;
                return __generator(this, function(_a) {
                    return [
                        2 /*return*/ ,
                        this._nextPolicy.sendRequest(request).then(function(response) {
                            return deserializeResponseBody(_this.jsonContentTypes, _this.xmlContentTypes, response, {
                                xmlCharKey: _this.xmlCharKey
                            });
                        })
                    ];
                });
            });
        };
        return DeserializationPolicy;
    }(BaseRequestPolicy);
    function getOperationResponse(parsedResponse) {
        var result;
        var request = parsedResponse.request;
        var operationSpec = request.operationSpec;
        if (operationSpec) {
            var operationResponseGetter = request.operationResponseGetter;
            if (!operationResponseGetter) result = operationSpec.responses[parsedResponse.status];
            else result = operationResponseGetter(operationSpec, parsedResponse);
        }
        return result;
    }
    function shouldDeserializeResponse(parsedResponse) {
        var shouldDeserialize = parsedResponse.request.shouldDeserialize;
        var result;
        if (shouldDeserialize === undefined) result = true;
        else if (typeof shouldDeserialize === "boolean") result = shouldDeserialize;
        else result = shouldDeserialize(parsedResponse);
        return result;
    }
    function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options) {
        var _a, _b, _c;
        if (options === void 0) options = {};
        var updatedOptions = {
            rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
            includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
        };
        return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then(function(parsedResponse) {
            if (!shouldDeserializeResponse(parsedResponse)) return parsedResponse;
            var operationSpec = parsedResponse.request.operationSpec;
            if (!operationSpec || !operationSpec.responses) return parsedResponse;
            var responseSpec = getOperationResponse(parsedResponse);
            var _a = handleErrorResponse(parsedResponse, operationSpec, responseSpec), error = _a.error, shouldReturnResponse = _a.shouldReturnResponse;
            if (error) throw error;
            else if (shouldReturnResponse) return parsedResponse;
            // An operation response spec does exist for current status code, so
            // use it to deserialize the response.
            if (responseSpec) {
                if (responseSpec.bodyMapper) {
                    var valueToDeserialize = parsedResponse.parsedBody;
                    if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperType.Sequence) valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
                    try {
                        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
                    } catch (error) {
                        var restError = new RestError("Error " + error + " occurred in deserializing the responseBody - " + parsedResponse.bodyAsText, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);
                        throw restError;
                    }
                } else if (operationSpec.httpMethod === "HEAD") // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
                parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
                if (responseSpec.headersMapper) parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders", options);
            }
            return parsedResponse;
        });
    }
    function isOperationSpecEmpty(operationSpec) {
        var expectedStatusCodes = Object.keys(operationSpec.responses);
        return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
    }
    function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
        var isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
        var isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
        if (isExpectedStatusCode) {
            if (responseSpec) {
                if (!responseSpec.isError) return {
                    error: null,
                    shouldReturnResponse: false
                };
            } else return {
                error: null,
                shouldReturnResponse: false
            };
        }
        var errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
        var initialErrorMessage = isStreamOperation(operationSpec) ? "Unexpected status code: " + parsedResponse.status : parsedResponse.bodyAsText;
        var error = new RestError(initialErrorMessage, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);
        // If the item failed but there's no error spec or default spec to deserialize the error,
        // we should fail so we just throw the parsed response
        if (!errorResponseSpec) throw error;
        var defaultBodyMapper = errorResponseSpec.bodyMapper;
        var defaultHeadersMapper = errorResponseSpec.headersMapper;
        try {
            // If error response has a body, try to deserialize it using default body mapper.
            // Then try to extract error code & message from it
            if (parsedResponse.parsedBody) {
                var parsedBody = parsedResponse.parsedBody;
                var parsedError = void 0;
                if (defaultBodyMapper) {
                    var valueToDeserialize = parsedBody;
                    if (operationSpec.isXML && defaultBodyMapper.type.name === MapperType.Sequence) valueToDeserialize = typeof parsedBody === "object" ? parsedBody[defaultBodyMapper.xmlElementName] : [];
                    parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
                }
                var internalError = parsedBody.error || parsedError || parsedBody;
                error.code = internalError.code;
                if (internalError.message) error.message = internalError.message;
                if (defaultBodyMapper) error.response.parsedBody = parsedError;
            }
            // If error response has headers, try to deserialize it using default header mapper
            if (parsedResponse.headers && defaultHeadersMapper) error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders");
        } catch (defaultError) {
            error.message = "Error \"" + defaultError.message + "\" occurred in deserializing the responseBody - \"" + parsedResponse.bodyAsText + "\" for the default response.";
        }
        return {
            error: error,
            shouldReturnResponse: false
        };
    }
    function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
        var errorHandler = function(err) {
            var msg = "Error \"" + err + "\" occurred while parsing the response body - " + operationResponse.bodyAsText + ".";
            var errCode = err.code || RestError.PARSE_ERROR;
            var e = new RestError(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
            return Promise.reject(e);
        };
        if (!operationResponse.request.streamResponseBody && operationResponse.bodyAsText) {
            var text_1 = operationResponse.bodyAsText;
            var contentType = operationResponse.headers.get("Content-Type") || "";
            var contentComponents = !contentType ? [] : contentType.split(";").map(function(component) {
                return component.toLowerCase();
            });
            if (contentComponents.length === 0 || contentComponents.some(function(component) {
                return jsonContentTypes.indexOf(component) !== -1;
            })) return new Promise(function(resolve) {
                operationResponse.parsedBody = JSON.parse(text_1);
                resolve(operationResponse);
            }).catch(errorHandler);
            else if (contentComponents.some(function(component) {
                return xmlContentTypes.indexOf(component) !== -1;
            })) return parseXML(text_1, opts).then(function(body) {
                operationResponse.parsedBody = body;
                return operationResponse;
            }).catch(errorHandler);
        }
        return Promise.resolve(operationResponse);
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    var DEFAULT_CLIENT_RETRY_COUNT = 3;
    // intervals are in ms
    var DEFAULT_CLIENT_RETRY_INTERVAL = 30000;
    var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 90000;
    var DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 3000;
    function isNumber(n) {
        return typeof n === "number";
    }
    /**
	 * @internal
	 * Determines if the operation should be retried.
	 *
	 * @param {number} retryLimit Specifies the max number of retries.
	 * @param {(response?: HttpOperationResponse, error?: RetryError) => boolean} predicate Initial chekck on whether to retry based on given responses or errors
	 * @param {RetryData} retryData  The retry data.
	 * @return {boolean} True if the operation qualifies for a retry; false otherwise.
	 */ function shouldRetry(retryLimit, predicate, retryData, response, error) {
        if (!predicate(response, error)) return false;
        return retryData.retryCount < retryLimit;
    }
    /**
	 * @internal
	 * Updates the retry data for the next attempt.
	 *
	 * @param {RetryPolicyOptions} retryOptions specifies retry interval, and its lower bound and upper bound.
	 * @param {RetryData} [retryData]  The retry data.
	 * @param {RetryError} [err] The operation"s error, if any.
	 */ function updateRetryData(retryOptions, retryData, err) {
        if (retryData === void 0) retryData = {
            retryCount: 0,
            retryInterval: 0
        };
        if (err) {
            if (retryData.error) err.innerError = retryData.error;
            retryData.error = err;
        }
        // Adjust retry count
        retryData.retryCount++;
        // Adjust retry interval
        var incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;
        var boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));
        incrementDelta *= boundedRandDelta;
        retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);
        return retryData;
    }
    // Copyright (c) Microsoft Corporation.
    function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
        return {
            create: function(nextPolicy, options) {
                return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);
            }
        };
    }
    /**
	 * Describes the Retry Mode type. Currently supporting only Exponential.
	 * @enum RetryMode
	 */ var RetryMode;
    (function(RetryMode) {
        RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
    })(RetryMode || (RetryMode = {}));
    var DefaultRetryOptions = {
        maxRetries: DEFAULT_CLIENT_RETRY_COUNT,
        retryDelayInMs: DEFAULT_CLIENT_RETRY_INTERVAL,
        maxRetryDelayInMs: DEFAULT_CLIENT_MAX_RETRY_INTERVAL
    };
    /**
	 * @class
	 * Instantiates a new "ExponentialRetryPolicyFilter" instance.
	 */ var ExponentialRetryPolicy = /** @class */ function(_super) {
        __extends(ExponentialRetryPolicy, _super);
        /**
	     * @constructor
	     * @param {RequestPolicy} nextPolicy The next RequestPolicy in the pipeline chain.
	     * @param {RequestPolicyOptions} options The options for this RequestPolicy.
	     * @param {number} [retryCount]        The client retry count.
	     * @param {number} [retryInterval]     The client retry interval, in milliseconds.
	     * @param {number} [minRetryInterval]  The minimum retry interval, in milliseconds.
	     * @param {number} [maxRetryInterval]  The maximum retry interval, in milliseconds.
	     */ function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
            _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
            _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
            return _this;
        }
        ExponentialRetryPolicy.prototype.sendRequest = function(request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request.clone()).then(function(response) {
                return retry(_this, request, response);
            }).catch(function(error) {
                return retry(_this, request, error.response, undefined, error);
            });
        };
        return ExponentialRetryPolicy;
    }(BaseRequestPolicy);
    function retry(policy, request, response, retryData, requestError) {
        return __awaiter(this, void 0, void 0, function() {
            function shouldPolicyRetry(response) {
                var statusCode = response === null || response === void 0 ? void 0 : response.status;
                if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) return false;
                return true;
            }
            var isAborted, res, err_1, err;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        retryData = updateRetryData({
                            retryInterval: policy.retryInterval,
                            minRetryInterval: 0,
                            maxRetryInterval: policy.maxRetryInterval
                        }, retryData, requestError);
                        isAborted = request.abortSignal && request.abortSignal.aborted;
                        if (!(!isAborted && shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, response))) return [
                            3 /*break*/ ,
                            6
                        ];
                        logger.info("Retrying request in " + retryData.retryInterval);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            delay(retryData.retryInterval)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            4 /*yield*/ ,
                            policy._nextPolicy.sendRequest(request.clone())
                        ];
                    case 3:
                        res = _a.sent();
                        return [
                            2 /*return*/ ,
                            retry(policy, request, res, retryData)
                        ];
                    case 4:
                        err_1 = _a.sent();
                        return [
                            2 /*return*/ ,
                            retry(policy, request, response, retryData, err_1)
                        ];
                    case 5:
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 6:
                        if (isAborted || requestError || !response) {
                            err = retryData.error || new RestError("Failed to send the request.", RestError.REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
                            throw err;
                        } else return [
                            2 /*return*/ ,
                            response
                        ];
                    case 7:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    }
    // Copyright (c) Microsoft Corporation.
    function generateClientRequestIdPolicy(requestIdHeaderName) {
        if (requestIdHeaderName === void 0) requestIdHeaderName = "x-ms-client-request-id";
        return {
            create: function(nextPolicy, options) {
                return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
            }
        };
    }
    var GenerateClientRequestIdPolicy = /** @class */ function(_super) {
        __extends(GenerateClientRequestIdPolicy, _super);
        function GenerateClientRequestIdPolicy(nextPolicy, options, _requestIdHeaderName) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this._requestIdHeaderName = _requestIdHeaderName;
            return _this;
        }
        GenerateClientRequestIdPolicy.prototype.sendRequest = function(request) {
            if (!request.headers.contains(this._requestIdHeaderName)) request.headers.set(this._requestIdHeaderName, request.requestId);
            return this._nextPolicy.sendRequest(request);
        };
        return GenerateClientRequestIdPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function getDefaultUserAgentKey() {
        return "x-ms-useragent";
    }
    function getPlatformSpecificData() {
        var navigator1 = window.navigator;
        var osInfo = {
            key: "OS",
            value: (navigator1.oscpu || navigator1.platform).replace(" ", "")
        };
        return [
            osInfo
        ];
    }
    // Copyright (c) Microsoft Corporation.
    function getRuntimeInfo() {
        var msRestRuntime = {
            key: "core-http",
            value: Constants.coreHttpVersion
        };
        return [
            msRestRuntime
        ];
    }
    function getUserAgentString(telemetryInfo, keySeparator, valueSeparator) {
        if (keySeparator === void 0) keySeparator = " ";
        if (valueSeparator === void 0) valueSeparator = "/";
        return telemetryInfo.map(function(info) {
            var value = info.value ? "" + valueSeparator + info.value : "";
            return "" + info.key + value;
        }).join(keySeparator);
    }
    var getDefaultUserAgentHeaderName = getDefaultUserAgentKey;
    function getDefaultUserAgentValue() {
        var runtimeInfo = getRuntimeInfo();
        var platformSpecificData = getPlatformSpecificData();
        var userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
        return userAgent;
    }
    function userAgentPolicy(userAgentData) {
        var key = !userAgentData || userAgentData.key === undefined || userAgentData.key === null ? getDefaultUserAgentKey() : userAgentData.key;
        var value = !userAgentData || userAgentData.value === undefined || userAgentData.value === null ? getDefaultUserAgentValue() : userAgentData.value;
        return {
            create: function(nextPolicy, options) {
                return new UserAgentPolicy(nextPolicy, options, key, value);
            }
        };
    }
    var UserAgentPolicy = /** @class */ function(_super) {
        __extends(UserAgentPolicy, _super);
        function UserAgentPolicy(_nextPolicy, _options, headerKey, headerValue) {
            var _this = _super.call(this, _nextPolicy, _options) || this;
            _this._nextPolicy = _nextPolicy;
            _this._options = _options;
            _this.headerKey = headerKey;
            _this.headerValue = headerValue;
            return _this;
        }
        UserAgentPolicy.prototype.sendRequest = function(request) {
            this.addUserAgentHeader(request);
            return this._nextPolicy.sendRequest(request);
        };
        UserAgentPolicy.prototype.addUserAgentHeader = function(request) {
            if (!request.headers) request.headers = new HttpHeaders();
            if (!request.headers.get(this.headerKey) && this.headerValue) request.headers.set(this.headerKey, this.headerValue);
        };
        return UserAgentPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    /**
	 * Methods that are allowed to follow redirects 301 and 302
	 */ var allowedRedirect = [
        "GET",
        "HEAD"
    ];
    var DefaultRedirectOptions = {
        handleRedirects: true,
        maxRetries: 20
    };
    function redirectPolicy(maximumRetries) {
        if (maximumRetries === void 0) maximumRetries = 20;
        return {
            create: function(nextPolicy, options) {
                return new RedirectPolicy(nextPolicy, options, maximumRetries);
            }
        };
    }
    var RedirectPolicy = /** @class */ function(_super) {
        __extends(RedirectPolicy, _super);
        function RedirectPolicy(nextPolicy, options, maxRetries) {
            if (maxRetries === void 0) maxRetries = 20;
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.maxRetries = maxRetries;
            return _this;
        }
        RedirectPolicy.prototype.sendRequest = function(request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request).then(function(response) {
                return handleRedirect(_this, response, 0);
            });
        };
        return RedirectPolicy;
    }(BaseRequestPolicy);
    function handleRedirect(policy, response, currentRetries) {
        var request = response.request, status = response.status;
        var locationHeader = response.headers.get("location");
        if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && (!policy.maxRetries || currentRetries < policy.maxRetries)) {
            var builder = URLBuilder.parse(request.url);
            builder.setPath(locationHeader);
            request.url = builder.toString();
            // POST request with Status code 303 should be converted into a
            // redirected GET request if the redirect url is present in the location header
            if (status === 303) {
                request.method = "GET";
                delete request.body;
            }
            return policy._nextPolicy.sendRequest(request).then(function(res) {
                return handleRedirect(policy, res, currentRetries + 1);
            });
        }
        return Promise.resolve(response);
    }
    // Copyright (c) Microsoft Corporation.
    function rpRegistrationPolicy(retryTimeout) {
        if (retryTimeout === void 0) retryTimeout = 30;
        return {
            create: function(nextPolicy, options) {
                return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
            }
        };
    }
    var RPRegistrationPolicy = /** @class */ function(_super) {
        __extends(RPRegistrationPolicy, _super);
        function RPRegistrationPolicy(nextPolicy, options, _retryTimeout) {
            if (_retryTimeout === void 0) _retryTimeout = 30;
            var _this = _super.call(this, nextPolicy, options) || this;
            _this._retryTimeout = _retryTimeout;
            return _this;
        }
        RPRegistrationPolicy.prototype.sendRequest = function(request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request.clone()).then(function(response) {
                return registerIfNeeded(_this, request, response);
            });
        };
        return RPRegistrationPolicy;
    }(BaseRequestPolicy);
    function registerIfNeeded(policy, request, response) {
        if (response.status === 409) {
            var rpName = checkRPNotRegisteredError(response.bodyAsText);
            if (rpName) {
                var urlPrefix = extractSubscriptionUrl(request.url);
                return registerRP(policy, urlPrefix, rpName, request)// Autoregistration of ${provider} failed for some reason. We will not return this error
                // instead will return the initial response with 409 status code back to the user.
                // do nothing here as we are returning the original response at the end of this method.
                .catch(function() {
                    return false;
                }).then(function(registrationStatus) {
                    if (registrationStatus) {
                        // Retry the original request. We have to change the x-ms-client-request-id
                        // otherwise Azure endpoint will return the initial 409 (cached) response.
                        request.headers.set("x-ms-client-request-id", generateUuid());
                        return policy._nextPolicy.sendRequest(request.clone());
                    }
                    return response;
                });
            }
        }
        return Promise.resolve(response);
    }
    /**
	 * Reuses the headers of the original request and url (if specified).
	 * @param {WebResourceLike} originalRequest The original request
	 * @param {boolean} reuseUrlToo Should the url from the original request be reused as well. Default false.
	 * @returns {object} A new request object with desired headers.
	 */ function getRequestEssentials(originalRequest, reuseUrlToo) {
        if (reuseUrlToo === void 0) reuseUrlToo = false;
        var reqOptions = originalRequest.clone();
        if (reuseUrlToo) reqOptions.url = originalRequest.url;
        // We have to change the x-ms-client-request-id otherwise Azure endpoint
        // will return the initial 409 (cached) response.
        reqOptions.headers.set("x-ms-client-request-id", generateUuid());
        // Set content-type to application/json
        reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
        return reqOptions;
    }
    /**
	 * Validates the error code and message associated with 409 response status code. If it matches to that of
	 * RP not registered then it returns the name of the RP else returns undefined.
	 * @param {string} body The response body received after making the original request.
	 * @returns {string} The name of the RP if condition is satisfied else undefined.
	 */ function checkRPNotRegisteredError(body) {
        var result, responseBody;
        if (body) {
            try {
                responseBody = JSON.parse(body);
            } catch (err) {
            // do nothing;
            }
            if (responseBody && responseBody.error && responseBody.error.message && responseBody.error.code && responseBody.error.code === "MissingSubscriptionRegistration") {
                var matchRes = responseBody.error.message.match(/.*'(.*)'/i);
                if (matchRes) result = matchRes.pop();
            }
        }
        return result;
    }
    /**
	 * Extracts the first part of the URL, just after subscription:
	 * https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
	 * @param {string} url The original request url
	 * @returns {string} The url prefix as explained above.
	 */ function extractSubscriptionUrl(url) {
        var result;
        var matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
        if (matchRes && matchRes[0]) result = matchRes[0];
        else throw new Error("Unable to extract subscriptionId from the given url - " + url + ".");
        return result;
    }
    /**
	 * Registers the given provider.
	 * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.
	 * @param {string} urlPrefix https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
	 * @param {string} provider The provider name to be registered.
	 * @param {WebResourceLike} originalRequest The original request sent by the user that returned a 409 response
	 * with a message that the provider is not registered.
	 * @param {registrationCallback} callback The callback that handles the RP registration
	 */ function registerRP(policy, urlPrefix, provider, originalRequest) {
        var postUrl = urlPrefix + "providers/" + provider + "/register?api-version=2016-02-01";
        var getUrl = urlPrefix + "providers/" + provider + "?api-version=2016-02-01";
        var reqOptions = getRequestEssentials(originalRequest);
        reqOptions.method = "POST";
        reqOptions.url = postUrl;
        return policy._nextPolicy.sendRequest(reqOptions).then(function(response) {
            if (response.status !== 200) throw new Error("Autoregistration of " + provider + " failed. Please try registering manually.");
            return getRegistrationStatus(policy, getUrl, originalRequest);
        });
    }
    /**
	 * Polls the registration status of the provider that was registered. Polling happens at an interval of 30 seconds.
	 * Polling will happen till the registrationState property of the response body is "Registered".
	 * @param {RPRegistrationPolicy} policy The RPRegistrationPolicy this function is being called against.
	 * @param {string} url The request url for polling
	 * @param {WebResourceLike} originalRequest The original request sent by the user that returned a 409 response
	 * with a message that the provider is not registered.
	 * @returns {Promise<boolean>} True if RP Registration is successful.
	 */ function getRegistrationStatus(policy, url, originalRequest) {
        var reqOptions = getRequestEssentials(originalRequest);
        reqOptions.url = url;
        reqOptions.method = "GET";
        return policy._nextPolicy.sendRequest(reqOptions).then(function(res) {
            var obj = res.parsedBody;
            if (res.parsedBody && obj.registrationState && obj.registrationState === "Registered") return true;
            else return delay(policy._retryTimeout * 1000).then(function() {
                return getRegistrationStatus(policy, url, originalRequest);
            });
        });
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
	 * Defines the default token refresh buffer duration.
	 */ var TokenRefreshBufferMs = 120000; // 2 Minutes
    /**
	 * Provides an {@link AccessTokenCache} implementation which clears
	 * the cached {@link AccessToken}'s after the expiresOnTimestamp has
	 * passed.
	 */ var ExpiringAccessTokenCache = /** @class */ function() {
        /**
	     * Constructs an instance of {@link ExpiringAccessTokenCache} with
	     * an optional expiration buffer time.
	     */ function ExpiringAccessTokenCache(tokenRefreshBufferMs) {
            if (tokenRefreshBufferMs === void 0) tokenRefreshBufferMs = TokenRefreshBufferMs;
            this.cachedToken = undefined;
            this.tokenRefreshBufferMs = tokenRefreshBufferMs;
        }
        ExpiringAccessTokenCache.prototype.setCachedToken = function(accessToken) {
            this.cachedToken = accessToken;
        };
        ExpiringAccessTokenCache.prototype.getCachedToken = function() {
            if (this.cachedToken && Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) this.cachedToken = undefined;
            return this.cachedToken;
        };
        return ExpiringAccessTokenCache;
    }();
    // Copyright (c) Microsoft Corporation.
    /**
	 * Helps the core-http token authentication policies with requesting a new token if we're not currently waiting for a new token.
	 */ var AccessTokenRefresher = /** @class */ function() {
        function AccessTokenRefresher(credential, scopes, requiredMillisecondsBeforeNewRefresh) {
            if (requiredMillisecondsBeforeNewRefresh === void 0) requiredMillisecondsBeforeNewRefresh = 30000;
            this.credential = credential;
            this.scopes = scopes;
            this.requiredMillisecondsBeforeNewRefresh = requiredMillisecondsBeforeNewRefresh;
            this.lastCalled = 0;
        }
        /**
	     * Returns true if the required milliseconds(defaulted to 30000) have been passed signifying
	     * that we are ready for a new refresh.
	     *
	     * @returns {boolean}
	     */ AccessTokenRefresher.prototype.isReady = function() {
            // We're only ready for a new refresh if the required milliseconds have passed.
            return !this.lastCalled || Date.now() - this.lastCalled > this.requiredMillisecondsBeforeNewRefresh;
        };
        /**
	     * Stores the time in which it is called,
	     * then requests a new token,
	     * then sets this.promise to undefined,
	     * then returns the token.
	     * @param options getToken options
	     */ AccessTokenRefresher.prototype.getToken = function(options) {
            return __awaiter(this, void 0, void 0, function() {
                var token;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            this.lastCalled = Date.now();
                            return [
                                4 /*yield*/ ,
                                this.credential.getToken(this.scopes, options)
                            ];
                        case 1:
                            token = _a.sent();
                            this.promise = undefined;
                            return [
                                2 /*return*/ ,
                                token || undefined
                            ];
                    }
                });
            });
        };
        /**
	     * Requests a new token if we're not currently waiting for a new token.
	     * Returns null if the required time between each call hasn't been reached.
	     * @param options getToken options
	     */ AccessTokenRefresher.prototype.refresh = function(options) {
            if (!this.promise) this.promise = this.getToken(options);
            return this.promise;
        };
        return AccessTokenRefresher;
    }();
    // Copyright (c) Microsoft Corporation.
    /**
	 * Creates a new BearerTokenAuthenticationPolicy factory.
	 *
	 * @param credential The TokenCredential implementation that can supply the bearer token.
	 * @param scopes The scopes for which the bearer token applies.
	 */ function bearerTokenAuthenticationPolicy(credential, scopes) {
        var tokenCache = new ExpiringAccessTokenCache();
        var tokenRefresher = new AccessTokenRefresher(credential, scopes, timeBetweenRefreshAttemptsInMs);
        return {
            create: function(nextPolicy, options) {
                return new BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher);
            }
        };
    }
    /**
	 * The automated token refresh will only start to happen at the
	 * expiration date minus the value of timeBetweenRefreshAttemptsInMs,
	 * which is by default 30 seconds.
	 */ var timeBetweenRefreshAttemptsInMs = 30000;
    /**
	 *
	 * Provides a RequestPolicy that can request a token from a TokenCredential
	 * implementation and then apply it to the Authorization header of a request
	 * as a Bearer token.
	 *
	 */ var BearerTokenAuthenticationPolicy = /** @class */ function(_super) {
        __extends(BearerTokenAuthenticationPolicy, _super);
        /**
	     * Creates a new BearerTokenAuthenticationPolicy object.
	     *
	     * @param nextPolicy The next RequestPolicy in the request pipeline.
	     * @param options Options for this RequestPolicy.
	     * @param credential The TokenCredential implementation that can supply the bearer token.
	     * @param scopes The scopes for which the bearer token applies.
	     * @param tokenCache The cache for the most recent AccessToken returned from the TokenCredential.
	     */ function BearerTokenAuthenticationPolicy(nextPolicy, options, tokenCache, tokenRefresher) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.tokenCache = tokenCache;
            _this.tokenRefresher = tokenRefresher;
            return _this;
        }
        /**
	     * Applies the Bearer token to the request through the Authorization header.
	     * @param webResource
	     */ BearerTokenAuthenticationPolicy.prototype.sendRequest = function(webResource) {
            return __awaiter(this, void 0, void 0, function() {
                var token;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            if (!webResource.headers) webResource.headers = new HttpHeaders();
                            return [
                                4 /*yield*/ ,
                                this.getToken({
                                    abortSignal: webResource.abortSignal,
                                    tracingOptions: {
                                        spanOptions: webResource.spanOptions
                                    }
                                })
                            ];
                        case 1:
                            token = _a.sent();
                            webResource.headers.set(Constants.HeaderConstants.AUTHORIZATION, "Bearer " + token);
                            return [
                                2 /*return*/ ,
                                this._nextPolicy.sendRequest(webResource)
                            ];
                    }
                });
            });
        };
        /**
	     * Attempts a token update if any other time related conditionals have been reached based on the tokenRefresher class.
	     */ BearerTokenAuthenticationPolicy.prototype.updateTokenIfNeeded = function(options) {
            return __awaiter(this, void 0, void 0, function() {
                var accessToken;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            if (!this.tokenRefresher.isReady()) return [
                                3 /*break*/ ,
                                2
                            ];
                            return [
                                4 /*yield*/ ,
                                this.tokenRefresher.refresh(options)
                            ];
                        case 1:
                            accessToken = _a.sent();
                            this.tokenCache.setCachedToken(accessToken);
                            _a.label = 2;
                        case 2:
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        };
        BearerTokenAuthenticationPolicy.prototype.getToken = function(options) {
            return __awaiter(this, void 0, void 0, function() {
                var accessToken;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            accessToken = this.tokenCache.getCachedToken();
                            if (!(accessToken === undefined)) return [
                                3 /*break*/ ,
                                2
                            ];
                            return [
                                4 /*yield*/ ,
                                this.tokenRefresher.refresh(options)
                            ];
                        case 1:
                            // Waiting for the next refresh only if the cache is unable to retrieve the access token,
                            // which means that it has expired, or it has never been set.
                            accessToken = _a.sent();
                            this.tokenCache.setCachedToken(accessToken);
                            return [
                                3 /*break*/ ,
                                3
                            ];
                        case 2:
                            // If we still have a cached access token,
                            // And any other time related conditionals have been reached based on the tokenRefresher class,
                            // then attempt to refresh without waiting.
                            this.updateTokenIfNeeded(options);
                            _a.label = 3;
                        case 3:
                            return [
                                2 /*return*/ ,
                                accessToken ? accessToken.token : undefined
                            ];
                    }
                });
            });
        };
        return BearerTokenAuthenticationPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        return {
            create: function(nextPolicy, options) {
                return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
            }
        };
    }
    /**
	 * @class
	 * Instantiates a new "ExponentialRetryPolicyFilter" instance.
	 *
	 * @constructor
	 * @param {number} retryCount        The client retry count.
	 * @param {number} retryInterval     The client retry interval, in milliseconds.
	 * @param {number} minRetryInterval  The minimum retry interval, in milliseconds.
	 * @param {number} maxRetryInterval  The maximum retry interval, in milliseconds.
	 */ var SystemErrorRetryPolicy = /** @class */ function(_super) {
        __extends(SystemErrorRetryPolicy, _super);
        function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.retryCount = isNumber(retryCount) ? retryCount : DEFAULT_CLIENT_RETRY_COUNT;
            _this.retryInterval = isNumber(retryInterval) ? retryInterval : DEFAULT_CLIENT_RETRY_INTERVAL;
            _this.minRetryInterval = isNumber(minRetryInterval) ? minRetryInterval : DEFAULT_CLIENT_MIN_RETRY_INTERVAL;
            _this.maxRetryInterval = isNumber(maxRetryInterval) ? maxRetryInterval : DEFAULT_CLIENT_MAX_RETRY_INTERVAL;
            return _this;
        }
        SystemErrorRetryPolicy.prototype.sendRequest = function(request) {
            var _this = this;
            return this._nextPolicy.sendRequest(request.clone()).catch(function(error) {
                return retry$1(_this, request, error.response, error);
            });
        };
        return SystemErrorRetryPolicy;
    }(BaseRequestPolicy);
    function retry$1(policy, request, operationResponse, err, retryData) {
        return __awaiter(this, void 0, void 0, function() {
            function shouldPolicyRetry(_response, error) {
                if (error && error.code && (error.code === "ETIMEDOUT" || error.code === "ESOCKETTIMEDOUT" || error.code === "ECONNREFUSED" || error.code === "ECONNRESET" || error.code === "ENOENT")) return true;
                return false;
            }
            var err_1;
            return __generator(this, function(_a) {
                switch(_a.label){
                    case 0:
                        retryData = updateRetryData(policy, retryData, err);
                        if (!shouldRetry(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) return [
                            3 /*break*/ ,
                            5
                        ];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            3,
                            ,
                            4
                        ]);
                        return [
                            4 /*yield*/ ,
                            delay(retryData.retryInterval)
                        ];
                    case 2:
                        _a.sent();
                        return [
                            2 /*return*/ ,
                            policy._nextPolicy.sendRequest(request.clone())
                        ];
                    case 3:
                        err_1 = _a.sent();
                        return [
                            2 /*return*/ ,
                            retry$1(policy, request, operationResponse, err_1, retryData)
                        ];
                    case 4:
                        return [
                            3 /*break*/ ,
                            6
                        ];
                    case 5:
                        if (err) // If the operation failed in the end, return all errors instead of just the last one
                        return [
                            2 /*return*/ ,
                            Promise.reject(retryData.error)
                        ];
                        return [
                            2 /*return*/ ,
                            operationResponse
                        ];
                    case 6:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    /**
	 * The format that will be used to join an array of values together for a query parameter value.
	 */ var QueryCollectionFormat;
    (function(QueryCollectionFormat) {
        QueryCollectionFormat["Csv"] = ",";
        QueryCollectionFormat["Ssv"] = " ";
        QueryCollectionFormat["Tsv"] = "\t";
        QueryCollectionFormat["Pipes"] = "|";
        QueryCollectionFormat["Multi"] = "Multi";
    })(QueryCollectionFormat || (QueryCollectionFormat = {}));
    // Copyright (c) Microsoft Corporation.
    var proxyNotSupportedInBrowser = new Error("ProxyPolicy is not supported in browser environment");
    function getDefaultProxySettings(_proxyUrl) {
        return undefined;
    }
    function proxyPolicy(_proxySettings) {
        return {
            create: function(_nextPolicy, _options) {
                throw proxyNotSupportedInBrowser;
            }
        };
    }
    var ProxyPolicy = /** @class */ function(_super) {
        __extends(ProxyPolicy, _super);
        function ProxyPolicy(nextPolicy, options) {
            var _this = _super.call(this, nextPolicy, options) || this;
            throw proxyNotSupportedInBrowser;
        }
        ProxyPolicy.prototype.sendRequest = function(_request) {
            throw proxyNotSupportedInBrowser;
        };
        return ProxyPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    var StatusCodes = Constants.HttpConstants.StatusCodes;
    function throttlingRetryPolicy() {
        return {
            create: function(nextPolicy, options) {
                return new ThrottlingRetryPolicy(nextPolicy, options);
            }
        };
    }
    /**
	 * To learn more, please refer to
	 * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,
	 * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and
	 * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
	 */ var ThrottlingRetryPolicy = /** @class */ function(_super) {
        __extends(ThrottlingRetryPolicy, _super);
        function ThrottlingRetryPolicy(nextPolicy, options, _handleResponse) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this._handleResponse = _handleResponse || _this._defaultResponseHandler;
            return _this;
        }
        ThrottlingRetryPolicy.prototype.sendRequest = function(httpRequest) {
            return __awaiter(this, void 0, void 0, function() {
                var _this = this;
                return __generator(this, function(_a) {
                    return [
                        2 /*return*/ ,
                        this._nextPolicy.sendRequest(httpRequest.clone()).then(function(response) {
                            if (response.status !== StatusCodes.TooManyRequests) return response;
                            else return _this._handleResponse(httpRequest, response);
                        })
                    ];
                });
            });
        };
        ThrottlingRetryPolicy.prototype._defaultResponseHandler = function(httpRequest, httpResponse) {
            return __awaiter(this, void 0, void 0, function() {
                var retryAfterHeader, delayInMs;
                var _this = this;
                return __generator(this, function(_a) {
                    retryAfterHeader = httpResponse.headers.get(Constants.HeaderConstants.RETRY_AFTER);
                    if (retryAfterHeader) {
                        delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);
                        if (delayInMs) return [
                            2 /*return*/ ,
                            delay(delayInMs).then(function(_) {
                                return _this._nextPolicy.sendRequest(httpRequest);
                            })
                        ];
                    }
                    return [
                        2 /*return*/ ,
                        httpResponse
                    ];
                });
            });
        };
        ThrottlingRetryPolicy.parseRetryAfterHeader = function(headerValue) {
            var retryAfterInSeconds = Number(headerValue);
            if (Number.isNaN(retryAfterInSeconds)) return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
            else return retryAfterInSeconds * 1000;
        };
        ThrottlingRetryPolicy.parseDateRetryAfterHeader = function(headerValue) {
            try {
                var now = Date.now();
                var date = Date.parse(headerValue);
                var diff = date - now;
                return Number.isNaN(diff) ? undefined : diff;
            } catch (error) {
                return undefined;
            }
        };
        return ThrottlingRetryPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    function signingPolicy(authenticationProvider) {
        return {
            create: function(nextPolicy, options) {
                return new SigningPolicy(nextPolicy, options, authenticationProvider);
            }
        };
    }
    var SigningPolicy = /** @class */ function(_super) {
        __extends(SigningPolicy, _super);
        function SigningPolicy(nextPolicy, options, authenticationProvider) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.authenticationProvider = authenticationProvider;
            return _this;
        }
        SigningPolicy.prototype.signRequest = function(request) {
            return this.authenticationProvider.signRequest(request);
        };
        SigningPolicy.prototype.sendRequest = function(request) {
            var _this = this;
            return this.signRequest(request).then(function(nextRequest) {
                return _this._nextPolicy.sendRequest(nextRequest);
            });
        };
        return SigningPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    var DefaultKeepAliveOptions = {
        enable: true
    };
    function keepAlivePolicy(keepAliveOptions) {
        return {
            create: function(nextPolicy, options) {
                return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);
            }
        };
    }
    /**
	 * KeepAlivePolicy is a policy used to control keep alive settings for every request.
	 */ var KeepAlivePolicy = /** @class */ function(_super) {
        __extends(KeepAlivePolicy, _super);
        /**
	     * Creates an instance of KeepAlivePolicy.
	     *
	     * @param {RequestPolicy} nextPolicy
	     * @param {RequestPolicyOptions} options
	     * @param {KeepAliveOptions} [keepAliveOptions]
	     */ function KeepAlivePolicy(nextPolicy, options, keepAliveOptions) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.keepAliveOptions = keepAliveOptions;
            return _this;
        }
        /**
	     * Sends out request.
	     *
	     * @param {WebResourceLike} request
	     * @returns {Promise<HttpOperationResponse>}
	     * @memberof KeepAlivePolicy
	     */ KeepAlivePolicy.prototype.sendRequest = function(request) {
            return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    request.keepAlive = this.keepAliveOptions.enable;
                    return [
                        2 /*return*/ ,
                        this._nextPolicy.sendRequest(request)
                    ];
                });
            });
        };
        return KeepAlivePolicy;
    }(BaseRequestPolicy);
    var Logger = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(Logger);
    var Time = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(Time);
    var getter = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.defaultGetter = void 0;
        /**
	 * Default getter which just does a simple property access. Returns
	 * undefined if the key is not set.
	 *
	 * @param carrier
	 * @param key
	 */ function defaultGetter(carrier, key) {
            return carrier[key];
        }
        exports.defaultGetter = defaultGetter;
    });
    unwrapExports(getter);
    var getter_1 = getter.defaultGetter;
    var HttpTextPropagator = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(HttpTextPropagator);
    var NoopHttpTextPropagator_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NOOP_HTTP_TEXT_PROPAGATOR = exports.NoopHttpTextPropagator = void 0;
        /**
	 * No-op implementations of {@link HttpTextPropagator}.
	 */ var NoopHttpTextPropagator = /** @class */ function() {
            function NoopHttpTextPropagator() {}
            /** Noop inject function does nothing */ NoopHttpTextPropagator.prototype.inject = function(context, carrier, setter) {};
            /** Noop extract function does nothing and returns the input context */ NoopHttpTextPropagator.prototype.extract = function(context, carrier, getter) {
                return context;
            };
            return NoopHttpTextPropagator;
        }();
        exports.NoopHttpTextPropagator = NoopHttpTextPropagator;
        exports.NOOP_HTTP_TEXT_PROPAGATOR = new NoopHttpTextPropagator();
    });
    unwrapExports(NoopHttpTextPropagator_1);
    var NoopHttpTextPropagator_2 = NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR;
    var NoopHttpTextPropagator_3 = NoopHttpTextPropagator_1.NoopHttpTextPropagator;
    var setter = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.defaultSetter = void 0;
        /**
	 * Default setter which sets value via direct property access
	 *
	 * @param carrier
	 * @param key
	 */ function defaultSetter(carrier, key, value) {
            carrier[key] = value;
        }
        exports.defaultSetter = defaultSetter;
    });
    unwrapExports(setter);
    var setter_1 = setter.defaultSetter;
    var CorrelationContext = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(CorrelationContext);
    var EntryValue = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.EntryTtl = void 0;
        /**
	 * EntryTtl is an integer that represents number of hops an entry can propagate.
	 *
	 * For now, ONLY special values (0 and -1) are supported.
	 */ var EntryTtl;
        (function(EntryTtl) {
            /**
	     * NO_PROPAGATION is considered to have local context and is used within the
	     * process it created.
	     */ EntryTtl[EntryTtl["NO_PROPAGATION"] = 0] = "NO_PROPAGATION";
            /** UNLIMITED_PROPAGATION can propagate unlimited hops. */ EntryTtl[EntryTtl["UNLIMITED_PROPAGATION"] = -1] = "UNLIMITED_PROPAGATION";
        })(EntryTtl = exports.EntryTtl || (exports.EntryTtl = {}));
    });
    unwrapExports(EntryValue);
    var EntryValue_1 = EntryValue.EntryTtl;
    var BatchObserverResult = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(BatchObserverResult);
    var BoundInstrument = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(BoundInstrument);
    var Meter = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(Meter);
    var MeterProvider = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(MeterProvider);
    var Metric = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.ValueType = void 0;
        /** The Type of value. It describes how the data is reported. */ var ValueType;
        (function(ValueType) {
            ValueType[ValueType["INT"] = 0] = "INT";
            ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
        })(ValueType = exports.ValueType || (exports.ValueType = {}));
    });
    unwrapExports(Metric);
    var Metric_1 = Metric.ValueType;
    var NoopMeter_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ var __extends = commonjsGlobal && commonjsGlobal.__extends || function() {
            var extendStatics = function(d, b) {
                extendStatics = Object.setPrototypeOf || ({
                    __proto__: []
                }) instanceof Array && function(d, b) {
                    d.__proto__ = b;
                } || function(d, b) {
                    for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
                };
                return extendStatics(d, b);
            };
            return function(d, b) {
                extendStatics(d, b);
                function __() {
                    this.constructor = d;
                }
                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
        }();
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NOOP_BATCH_OBSERVER_METRIC = exports.NOOP_SUM_OBSERVER_METRIC = exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = exports.NOOP_VALUE_OBSERVER_METRIC = exports.NOOP_BOUND_BASE_OBSERVER = exports.NOOP_VALUE_RECORDER_METRIC = exports.NOOP_BOUND_VALUE_RECORDER = exports.NOOP_COUNTER_METRIC = exports.NOOP_BOUND_COUNTER = exports.NOOP_METER = exports.NoopBoundBaseObserver = exports.NoopBoundValueRecorder = exports.NoopBoundCounter = exports.NoopBatchObserverMetric = exports.NoopBaseObserverMetric = exports.NoopValueRecorderMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
        /**
	 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
	 * constant NoopMetrics for all of its methods.
	 */ var NoopMeter = /** @class */ function() {
            function NoopMeter() {}
            /**
	     * Returns constant noop value recorder.
	     * @param name the name of the metric.
	     * @param [options] the metric options.
	     */ NoopMeter.prototype.createValueRecorder = function(name, options) {
                return exports.NOOP_VALUE_RECORDER_METRIC;
            };
            /**
	     * Returns a constant noop counter.
	     * @param name the name of the metric.
	     * @param [options] the metric options.
	     */ NoopMeter.prototype.createCounter = function(name, options) {
                return exports.NOOP_COUNTER_METRIC;
            };
            /**
	     * Returns a constant noop UpDownCounter.
	     * @param name the name of the metric.
	     * @param [options] the metric options.
	     */ NoopMeter.prototype.createUpDownCounter = function(name, options) {
                return exports.NOOP_COUNTER_METRIC;
            };
            /**
	     * Returns constant noop value observer.
	     * @param name the name of the metric.
	     * @param [options] the metric options.
	     * @param [callback] the value observer callback
	     */ NoopMeter.prototype.createValueObserver = function(name, options, callback) {
                return exports.NOOP_VALUE_OBSERVER_METRIC;
            };
            /**
	     * Returns constant noop batch observer.
	     * @param name the name of the metric.
	     * @param callback the batch observer callback
	     */ NoopMeter.prototype.createBatchObserver = function(name, callback) {
                return exports.NOOP_BATCH_OBSERVER_METRIC;
            };
            return NoopMeter;
        }();
        exports.NoopMeter = NoopMeter;
        var NoopMetric = /** @class */ function() {
            function NoopMetric(instrument) {
                this._instrument = instrument;
            }
            /**
	     * Returns a Bound Instrument associated with specified Labels.
	     * It is recommended to keep a reference to the Bound Instrument instead of
	     * always calling this method for every operations.
	     * @param labels key-values pairs that are associated with a specific metric
	     *     that you want to record.
	     */ NoopMetric.prototype.bind = function(labels) {
                return this._instrument;
            };
            /**
	     * Removes the Binding from the metric, if it is present.
	     * @param labels key-values pairs that are associated with a specific metric.
	     */ NoopMetric.prototype.unbind = function(labels) {
                return;
            };
            /**
	     * Clears all timeseries from the Metric.
	     */ NoopMetric.prototype.clear = function() {
                return;
            };
            return NoopMetric;
        }();
        exports.NoopMetric = NoopMetric;
        var NoopCounterMetric = /** @class */ function(_super) {
            __extends(NoopCounterMetric, _super);
            function NoopCounterMetric() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            NoopCounterMetric.prototype.add = function(value, labels) {
                this.bind(labels).add(value);
            };
            return NoopCounterMetric;
        }(NoopMetric);
        exports.NoopCounterMetric = NoopCounterMetric;
        var NoopValueRecorderMetric = /** @class */ function(_super) {
            __extends(NoopValueRecorderMetric, _super);
            function NoopValueRecorderMetric() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            NoopValueRecorderMetric.prototype.record = function(value, labels, correlationContext, spanContext) {
                if (typeof correlationContext === 'undefined') this.bind(labels).record(value);
                else if (typeof spanContext === 'undefined') this.bind(labels).record(value, correlationContext);
                else this.bind(labels).record(value, correlationContext, spanContext);
            };
            return NoopValueRecorderMetric;
        }(NoopMetric);
        exports.NoopValueRecorderMetric = NoopValueRecorderMetric;
        var NoopBaseObserverMetric = /** @class */ function(_super) {
            __extends(NoopBaseObserverMetric, _super);
            function NoopBaseObserverMetric() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            NoopBaseObserverMetric.prototype.observation = function() {
                return {
                    observer: this,
                    value: 0
                };
            };
            return NoopBaseObserverMetric;
        }(NoopMetric);
        exports.NoopBaseObserverMetric = NoopBaseObserverMetric;
        var NoopBatchObserverMetric = /** @class */ function(_super) {
            __extends(NoopBatchObserverMetric, _super);
            function NoopBatchObserverMetric() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return NoopBatchObserverMetric;
        }(NoopMetric);
        exports.NoopBatchObserverMetric = NoopBatchObserverMetric;
        var NoopBoundCounter = /** @class */ function() {
            function NoopBoundCounter() {}
            NoopBoundCounter.prototype.add = function(value) {
                return;
            };
            return NoopBoundCounter;
        }();
        exports.NoopBoundCounter = NoopBoundCounter;
        var NoopBoundValueRecorder = /** @class */ function() {
            function NoopBoundValueRecorder() {}
            NoopBoundValueRecorder.prototype.record = function(value, correlationContext, spanContext) {
                return;
            };
            return NoopBoundValueRecorder;
        }();
        exports.NoopBoundValueRecorder = NoopBoundValueRecorder;
        var NoopBoundBaseObserver = /** @class */ function() {
            function NoopBoundBaseObserver() {}
            NoopBoundBaseObserver.prototype.update = function(value) {};
            return NoopBoundBaseObserver;
        }();
        exports.NoopBoundBaseObserver = NoopBoundBaseObserver;
        exports.NOOP_METER = new NoopMeter();
        exports.NOOP_BOUND_COUNTER = new NoopBoundCounter();
        exports.NOOP_COUNTER_METRIC = new NoopCounterMetric(exports.NOOP_BOUND_COUNTER);
        exports.NOOP_BOUND_VALUE_RECORDER = new NoopBoundValueRecorder();
        exports.NOOP_VALUE_RECORDER_METRIC = new NoopValueRecorderMetric(exports.NOOP_BOUND_VALUE_RECORDER);
        exports.NOOP_BOUND_BASE_OBSERVER = new NoopBoundBaseObserver();
        exports.NOOP_VALUE_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
        exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
        exports.NOOP_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
        exports.NOOP_BATCH_OBSERVER_METRIC = new NoopBatchObserverMetric();
    });
    unwrapExports(NoopMeter_1);
    var NoopMeter_2 = NoopMeter_1.NOOP_BATCH_OBSERVER_METRIC;
    var NoopMeter_3 = NoopMeter_1.NOOP_SUM_OBSERVER_METRIC;
    var NoopMeter_4 = NoopMeter_1.NOOP_UP_DOWN_SUM_OBSERVER_METRIC;
    var NoopMeter_5 = NoopMeter_1.NOOP_VALUE_OBSERVER_METRIC;
    var NoopMeter_6 = NoopMeter_1.NOOP_BOUND_BASE_OBSERVER;
    var NoopMeter_7 = NoopMeter_1.NOOP_VALUE_RECORDER_METRIC;
    var NoopMeter_8 = NoopMeter_1.NOOP_BOUND_VALUE_RECORDER;
    var NoopMeter_9 = NoopMeter_1.NOOP_COUNTER_METRIC;
    var NoopMeter_10 = NoopMeter_1.NOOP_BOUND_COUNTER;
    var NoopMeter_11 = NoopMeter_1.NOOP_METER;
    var NoopMeter_12 = NoopMeter_1.NoopBoundBaseObserver;
    var NoopMeter_13 = NoopMeter_1.NoopBoundValueRecorder;
    var NoopMeter_14 = NoopMeter_1.NoopBoundCounter;
    var NoopMeter_15 = NoopMeter_1.NoopBatchObserverMetric;
    var NoopMeter_16 = NoopMeter_1.NoopBaseObserverMetric;
    var NoopMeter_17 = NoopMeter_1.NoopValueRecorderMetric;
    var NoopMeter_18 = NoopMeter_1.NoopCounterMetric;
    var NoopMeter_19 = NoopMeter_1.NoopMetric;
    var NoopMeter_20 = NoopMeter_1.NoopMeter;
    var NoopMeterProvider_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;
        /**
	 * An implementation of the {@link MeterProvider} which returns an impotent Meter
	 * for all calls to `getMeter`
	 */ var NoopMeterProvider = /** @class */ function() {
            function NoopMeterProvider() {}
            NoopMeterProvider.prototype.getMeter = function(_name, _version) {
                return NoopMeter_1.NOOP_METER;
            };
            return NoopMeterProvider;
        }();
        exports.NoopMeterProvider = NoopMeterProvider;
        exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
    });
    unwrapExports(NoopMeterProvider_1);
    var NoopMeterProvider_2 = NoopMeterProvider_1.NOOP_METER_PROVIDER;
    var NoopMeterProvider_3 = NoopMeterProvider_1.NoopMeterProvider;
    var Observation = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(Observation);
    var ObserverResult = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(ObserverResult);
    var attributes = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(attributes);
    var Event = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(Event);
    var Plugin = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(Plugin);
    var link_context = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(link_context);
    var link = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(link);
    var trace_flags = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.TraceFlags = void 0;
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ var TraceFlags;
        (function(TraceFlags) {
            /** Represents no flag set. */ TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
            /** Bit to represent whether trace is sampled in trace flags. */ TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
        })(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));
    });
    unwrapExports(trace_flags);
    var trace_flags_1 = trace_flags.TraceFlags;
    var NoopSpan_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NOOP_SPAN = exports.NoopSpan = exports.INVALID_SPAN_ID = exports.INVALID_TRACE_ID = void 0;
        exports.INVALID_TRACE_ID = '0';
        exports.INVALID_SPAN_ID = '0';
        var INVALID_SPAN_CONTEXT = {
            traceId: exports.INVALID_TRACE_ID,
            spanId: exports.INVALID_SPAN_ID,
            traceFlags: trace_flags.TraceFlags.NONE
        };
        /**
	 * The NoopSpan is the default {@link Span} that is used when no Span
	 * implementation is available. All operations are no-op including context
	 * propagation.
	 */ var NoopSpan = /** @class */ function() {
            function NoopSpan(_spanContext) {
                if (_spanContext === void 0) _spanContext = INVALID_SPAN_CONTEXT;
                this._spanContext = _spanContext;
            }
            // Returns a SpanContext.
            NoopSpan.prototype.context = function() {
                return this._spanContext;
            };
            // By default does nothing
            NoopSpan.prototype.setAttribute = function(key, value) {
                return this;
            };
            // By default does nothing
            NoopSpan.prototype.setAttributes = function(attributes) {
                return this;
            };
            // By default does nothing
            NoopSpan.prototype.addEvent = function(name, attributes) {
                return this;
            };
            // By default does nothing
            NoopSpan.prototype.setStatus = function(status) {
                return this;
            };
            // By default does nothing
            NoopSpan.prototype.updateName = function(name) {
                return this;
            };
            // By default does nothing
            NoopSpan.prototype.end = function(endTime) {};
            // isRecording always returns false for noopSpan.
            NoopSpan.prototype.isRecording = function() {
                return false;
            };
            return NoopSpan;
        }();
        exports.NoopSpan = NoopSpan;
        exports.NOOP_SPAN = new NoopSpan();
    });
    unwrapExports(NoopSpan_1);
    var NoopSpan_2 = NoopSpan_1.NOOP_SPAN;
    var NoopSpan_3 = NoopSpan_1.NoopSpan;
    var NoopSpan_4 = NoopSpan_1.INVALID_SPAN_ID;
    var NoopSpan_5 = NoopSpan_1.INVALID_TRACE_ID;
    var NoopTracer_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NOOP_TRACER = exports.NoopTracer = void 0;
        /**
	 * No-op implementations of {@link Tracer}.
	 */ var NoopTracer = /** @class */ function() {
            function NoopTracer() {}
            NoopTracer.prototype.getCurrentSpan = function() {
                return NoopSpan_1.NOOP_SPAN;
            };
            // startSpan starts a noop span.
            NoopTracer.prototype.startSpan = function(name, options) {
                return NoopSpan_1.NOOP_SPAN;
            };
            NoopTracer.prototype.withSpan = function(span, fn) {
                return fn();
            };
            NoopTracer.prototype.bind = function(target, span) {
                return target;
            };
            return NoopTracer;
        }();
        exports.NoopTracer = NoopTracer;
        exports.NOOP_TRACER = new NoopTracer();
    });
    unwrapExports(NoopTracer_1);
    var NoopTracer_2 = NoopTracer_1.NOOP_TRACER;
    var NoopTracer_3 = NoopTracer_1.NoopTracer;
    var NoopTracerProvider_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NOOP_TRACER_PROVIDER = exports.NoopTracerProvider = void 0;
        /**
	 * An implementation of the {@link TracerProvider} which returns an impotent
	 * Tracer for all calls to `getTracer`.
	 *
	 * All operations are no-op.
	 */ var NoopTracerProvider = /** @class */ function() {
            function NoopTracerProvider() {}
            NoopTracerProvider.prototype.getTracer = function(_name, _version) {
                return NoopTracer_1.NOOP_TRACER;
            };
            return NoopTracerProvider;
        }();
        exports.NoopTracerProvider = NoopTracerProvider;
        exports.NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    });
    unwrapExports(NoopTracerProvider_1);
    var NoopTracerProvider_2 = NoopTracerProvider_1.NOOP_TRACER_PROVIDER;
    var NoopTracerProvider_3 = NoopTracerProvider_1.NoopTracerProvider;
    var Sampler = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(Sampler);
    var SamplingResult = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.SamplingDecision = void 0;
        /**
	 * A sampling decision that determines how a {@link Span} will be recorded
	 * and collected.
	 */ var SamplingDecision;
        (function(SamplingDecision) {
            /**
	     * `Span.isRecording() === false`, span will not be recorded and all events
	     * and attributes will be dropped.
	     */ SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
            /**
	     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
	     * MUST NOT be set.
	     */ SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
            /**
	     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
	     * MUST be set.
	     */ SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
        })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
    });
    unwrapExports(SamplingResult);
    var SamplingResult_1 = SamplingResult.SamplingDecision;
    var span_context = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(span_context);
    var span_kind = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.SpanKind = void 0;
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ var SpanKind;
        (function(SpanKind) {
            /** Default value. Indicates that the span is used internally. */ SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
            /**
	     * Indicates that the span covers server-side handling of an RPC or other
	     * remote request.
	     */ SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
            /**
	     * Indicates that the span covers the client-side wrapper around an RPC or
	     * other remote request.
	     */ SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
            /**
	     * Indicates that the span describes producer sending a message to a
	     * broker. Unlike client and server, there is no direct critical path latency
	     * relationship between producer and consumer spans.
	     */ SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
            /**
	     * Indicates that the span describes consumer receiving a message from a
	     * broker. Unlike client and server, there is no direct critical path latency
	     * relationship between producer and consumer spans.
	     */ SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
        })(SpanKind = exports.SpanKind || (exports.SpanKind = {}));
    });
    unwrapExports(span_kind);
    var span_kind_1 = span_kind.SpanKind;
    var span = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(span);
    var SpanOptions = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(SpanOptions);
    var status = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.CanonicalCode = void 0;
        /**
	 * An enumeration of canonical status codes.
	 */ var CanonicalCode;
        (function(CanonicalCode) {
            /**
	     * Not an error; returned on success
	     */ CanonicalCode[CanonicalCode["OK"] = 0] = "OK";
            /**
	     * The operation was cancelled (typically by the caller).
	     */ CanonicalCode[CanonicalCode["CANCELLED"] = 1] = "CANCELLED";
            /**
	     * Unknown error.  An example of where this error may be returned is
	     * if a status value received from another address space belongs to
	     * an error-space that is not known in this address space.  Also
	     * errors raised by APIs that do not return enough error information
	     * may be converted to this error.
	     */ CanonicalCode[CanonicalCode["UNKNOWN"] = 2] = "UNKNOWN";
            /**
	     * Client specified an invalid argument.  Note that this differs
	     * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
	     * that are problematic regardless of the state of the system
	     * (e.g., a malformed file name).
	     */ CanonicalCode[CanonicalCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
            /**
	     * Deadline expired before operation could complete.  For operations
	     * that change the state of the system, this error may be returned
	     * even if the operation has completed successfully.  For example, a
	     * successful response from a server could have been delayed long
	     * enough for the deadline to expire.
	     */ CanonicalCode[CanonicalCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
            /**
	     * Some requested entity (e.g., file or directory) was not found.
	     */ CanonicalCode[CanonicalCode["NOT_FOUND"] = 5] = "NOT_FOUND";
            /**
	     * Some entity that we attempted to create (e.g., file or directory)
	     * already exists.
	     */ CanonicalCode[CanonicalCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
            /**
	     * The caller does not have permission to execute the specified
	     * operation.  PERMISSION_DENIED must not be used for rejections
	     * caused by exhausting some resource (use RESOURCE_EXHAUSTED
	     * instead for those errors).  PERMISSION_DENIED must not be
	     * used if the caller can not be identified (use UNAUTHENTICATED
	     * instead for those errors).
	     */ CanonicalCode[CanonicalCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
            /**
	     * Some resource has been exhausted, perhaps a per-user quota, or
	     * perhaps the entire file system is out of space.
	     */ CanonicalCode[CanonicalCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
            /**
	     * Operation was rejected because the system is not in a state
	     * required for the operation's execution.  For example, directory
	     * to be deleted may be non-empty, an rmdir operation is applied to
	     * a non-directory, etc.
	     *
	     * A litmus test that may help a service implementor in deciding
	     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
	     *
	     *  - Use UNAVAILABLE if the client can retry just the failing call.
	     *  - Use ABORTED if the client should retry at a higher-level
	     *    (e.g., restarting a read-modify-write sequence).
	     *  - Use FAILED_PRECONDITION if the client should not retry until
	     *    the system state has been explicitly fixed.  E.g., if an "rmdir"
	     *    fails because the directory is non-empty, FAILED_PRECONDITION
	     *    should be returned since the client should not retry unless
	     *    they have first fixed up the directory by deleting files from it.
	     *  - Use FAILED_PRECONDITION if the client performs conditional
	     *    REST Get/Update/Delete on a resource and the resource on the
	     *    server does not match the condition. E.g., conflicting
	     *    read-modify-write on the same resource.
	     */ CanonicalCode[CanonicalCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
            /**
	     * The operation was aborted, typically due to a concurrency issue
	     * like sequencer check failures, transaction aborts, etc.
	     *
	     * See litmus test above for deciding between FAILED_PRECONDITION,
	     * ABORTED, and UNAVAILABLE.
	     */ CanonicalCode[CanonicalCode["ABORTED"] = 10] = "ABORTED";
            /**
	     * Operation was attempted past the valid range.  E.g., seeking or
	     * reading past end of file.
	     *
	     * Unlike INVALID_ARGUMENT, this error indicates a problem that may
	     * be fixed if the system state changes. For example, a 32-bit file
	     * system will generate INVALID_ARGUMENT if asked to read at an
	     * offset that is not in the range [0,2^32-1], but it will generate
	     * OUT_OF_RANGE if asked to read from an offset past the current
	     * file size.
	     *
	     * There is a fair bit of overlap between FAILED_PRECONDITION and
	     * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
	     * error) when it applies so that callers who are iterating through
	     * a space can easily look for an OUT_OF_RANGE error to detect when
	     * they are done.
	     */ CanonicalCode[CanonicalCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
            /**
	     * Operation is not implemented or not supported/enabled in this service.
	     */ CanonicalCode[CanonicalCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
            /**
	     * Internal errors.  Means some invariants expected by underlying
	     * system has been broken.  If you see one of these errors,
	     * something is very broken.
	     */ CanonicalCode[CanonicalCode["INTERNAL"] = 13] = "INTERNAL";
            /**
	     * The service is currently unavailable.  This is a most likely a
	     * transient condition and may be corrected by retrying with
	     * a backoff.
	     *
	     * See litmus test above for deciding between FAILED_PRECONDITION,
	     * ABORTED, and UNAVAILABLE.
	     */ CanonicalCode[CanonicalCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
            /**
	     * Unrecoverable data loss or corruption.
	     */ CanonicalCode[CanonicalCode["DATA_LOSS"] = 15] = "DATA_LOSS";
            /**
	     * The request does not have valid authentication credentials for the
	     * operation.
	     */ CanonicalCode[CanonicalCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
        })(CanonicalCode = exports.CanonicalCode || (exports.CanonicalCode = {}));
    });
    unwrapExports(status);
    var status_1 = status.CanonicalCode;
    var TimedEvent = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(TimedEvent);
    var trace_state = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(trace_state);
    var tracer_provider = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(tracer_provider);
    var tracer = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(tracer);
    var types = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
    });
    unwrapExports(types);
    var context = createCommonjsModule(function(module1, exports) {
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.Context = void 0;
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ var Context = /** @class */ function() {
            /**
	     * Construct a new context which inherits values from an optional parent context.
	     *
	     * @param parentContext a context from which to inherit values
	     */ function Context(parentContext) {
                this._currentContext = parentContext ? new Map(parentContext) : new Map();
            }
            /** Get a key to uniquely identify a context value */ Context.createKey = function(description) {
                return Symbol(description);
            };
            /**
	     * Get a value from the context.
	     *
	     * @param key key which identifies a context value
	     */ Context.prototype.getValue = function(key) {
                return this._currentContext.get(key);
            };
            /**
	     * Create a new context which inherits from this context and has
	     * the given key set to the given value.
	     *
	     * @param key context key for which to set the value
	     * @param value value to set for the given key
	     */ Context.prototype.setValue = function(key, value) {
                var context = new Context(this._currentContext);
                context._currentContext.set(key, value);
                return context;
            };
            /**
	     * Return a new context which inherits from this context but does
	     * not contain a value for the given key.
	     *
	     * @param key context key for which to clear a value
	     */ Context.prototype.deleteValue = function(key) {
                var context = new Context(this._currentContext);
                context._currentContext.delete(key);
                return context;
            };
            /** The root context is used as the default parent context when there is no active context */ Context.ROOT_CONTEXT = new Context();
            /**
	     * This is another identifier to the root context which allows developers to easily search the
	     * codebase for direct uses of context which need to be removed in later PRs.
	     *
	     * It's existence is temporary and it should be removed when all references are fixed.
	     */ Context.TODO = Context.ROOT_CONTEXT;
            return Context;
        }();
        exports.Context = Context;
    });
    unwrapExports(context);
    var context_1 = context.Context;
    var NoopContextManager_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.NoopContextManager = void 0;
        var NoopContextManager = /** @class */ function() {
            function NoopContextManager() {}
            NoopContextManager.prototype.active = function() {
                return context.Context.ROOT_CONTEXT;
            };
            NoopContextManager.prototype.with = function(context1, fn) {
                return fn();
            };
            NoopContextManager.prototype.bind = function(target, context1) {
                return target;
            };
            NoopContextManager.prototype.enable = function() {
                return this;
            };
            NoopContextManager.prototype.disable = function() {
                return this;
            };
            return NoopContextManager;
        }();
        exports.NoopContextManager = NoopContextManager;
    });
    unwrapExports(NoopContextManager_1);
    var NoopContextManager_2 = NoopContextManager_1.NoopContextManager;
    var src = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
        });
        var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports) {
            for(var p in m)if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
        };
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __exportStar(types, exports);
        __exportStar(context, exports);
        __exportStar(NoopContextManager_1, exports);
    });
    unwrapExports(src);
    var globalThis_1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports._globalThis = void 0;
        /** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
        exports._globalThis = typeof globalThis === 'object' ? globalThis : window;
    });
    unwrapExports(globalThis_1);
    var globalThis_2 = globalThis_1._globalThis;
    var browser = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
        });
        var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports) {
            for(var p in m)if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
        };
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        __exportStar(globalThis_1, exports);
    });
    unwrapExports(browser);
    var globalUtils = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_TRACE_API_KEY = exports.GLOBAL_PROPAGATION_API_KEY = exports.GLOBAL_METRICS_API_KEY = exports.GLOBAL_CONTEXT_MANAGER_API_KEY = void 0;
        exports.GLOBAL_CONTEXT_MANAGER_API_KEY = Symbol.for('io.opentelemetry.js.api.context');
        exports.GLOBAL_METRICS_API_KEY = Symbol.for('io.opentelemetry.js.api.metrics');
        exports.GLOBAL_PROPAGATION_API_KEY = Symbol.for('io.opentelemetry.js.api.propagation');
        exports.GLOBAL_TRACE_API_KEY = Symbol.for('io.opentelemetry.js.api.trace');
        exports._global = browser._globalThis;
        /**
	 * Make a function which accepts a version integer and returns the instance of an API if the version
	 * is compatible, or a fallback version (usually NOOP) if it is not.
	 *
	 * @param requiredVersion Backwards compatibility version which is required to return the instance
	 * @param instance Instance which should be returned if the required version is compatible
	 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
	 */ function makeGetter(requiredVersion, instance, fallback) {
            return function(version) {
                return version === requiredVersion ? instance : fallback;
            };
        }
        exports.makeGetter = makeGetter;
        /**
	 * A number which should be incremented each time a backwards incompatible
	 * change is made to the API. This number is used when an API package
	 * attempts to access the global API to ensure it is getting a compatible
	 * version. If the global API is not compatible with the API package
	 * attempting to get it, a NOOP API implementation will be returned.
	 */ exports.API_BACKWARDS_COMPATIBILITY_VERSION = 0;
    });
    unwrapExports(globalUtils);
    var globalUtils_1 = globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION;
    var globalUtils_2 = globalUtils.makeGetter;
    var globalUtils_3 = globalUtils._global;
    var globalUtils_4 = globalUtils.GLOBAL_TRACE_API_KEY;
    var globalUtils_5 = globalUtils.GLOBAL_PROPAGATION_API_KEY;
    var globalUtils_6 = globalUtils.GLOBAL_METRICS_API_KEY;
    var globalUtils_7 = globalUtils.GLOBAL_CONTEXT_MANAGER_API_KEY;
    var context$1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.ContextAPI = void 0;
        var NOOP_CONTEXT_MANAGER = new src.NoopContextManager();
        /**
	 * Singleton object which represents the entry point to the OpenTelemetry Context API
	 */ var ContextAPI = /** @class */ function() {
            /** Empty private constructor prevents end users from constructing a new instance of the API */ function ContextAPI() {}
            /** Get the singleton instance of the Context API */ ContextAPI.getInstance = function() {
                if (!this._instance) this._instance = new ContextAPI();
                return this._instance;
            };
            /**
	     * Set the current context manager. Returns the initialized context manager
	     */ ContextAPI.prototype.setGlobalContextManager = function(contextManager) {
                if (globalUtils._global[globalUtils.GLOBAL_CONTEXT_MANAGER_API_KEY]) // global context manager has already been set
                return this._getContextManager();
                globalUtils._global[globalUtils.GLOBAL_CONTEXT_MANAGER_API_KEY] = globalUtils.makeGetter(globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION, contextManager, NOOP_CONTEXT_MANAGER);
                return contextManager;
            };
            /**
	     * Get the currently active context
	     */ ContextAPI.prototype.active = function() {
                return this._getContextManager().active();
            };
            /**
	     * Execute a function with an active context
	     *
	     * @param context context to be active during function execution
	     * @param fn function to execute in a context
	     */ ContextAPI.prototype.with = function(context, fn) {
                return this._getContextManager().with(context, fn);
            };
            /**
	     * Bind a context to a target function or event emitter
	     *
	     * @param target function or event emitter to bind
	     * @param context context to bind to the event emitter or function. Defaults to the currently active context
	     */ ContextAPI.prototype.bind = function(target, context) {
                if (context === void 0) context = this.active();
                return this._getContextManager().bind(target, context);
            };
            ContextAPI.prototype._getContextManager = function() {
                var _a, _b;
                return (_b = (_a = globalUtils._global[globalUtils.GLOBAL_CONTEXT_MANAGER_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(globalUtils._global, globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_CONTEXT_MANAGER;
            };
            /** Disable and remove the global context manager */ ContextAPI.prototype.disable = function() {
                this._getContextManager().disable();
                delete globalUtils._global[globalUtils.GLOBAL_CONTEXT_MANAGER_API_KEY];
            };
            return ContextAPI;
        }();
        exports.ContextAPI = ContextAPI;
    });
    unwrapExports(context$1);
    var context_1$1 = context$1.ContextAPI;
    var trace = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.TraceAPI = void 0;
        /**
	 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
	 */ var TraceAPI = /** @class */ function() {
            /** Empty private constructor prevents end users from constructing a new instance of the API */ function TraceAPI() {}
            /** Get the singleton instance of the Trace API */ TraceAPI.getInstance = function() {
                if (!this._instance) this._instance = new TraceAPI();
                return this._instance;
            };
            /**
	     * Set the current global tracer. Returns the initialized global tracer provider
	     */ TraceAPI.prototype.setGlobalTracerProvider = function(provider) {
                if (globalUtils._global[globalUtils.GLOBAL_TRACE_API_KEY]) // global tracer provider has already been set
                return this.getTracerProvider();
                globalUtils._global[globalUtils.GLOBAL_TRACE_API_KEY] = globalUtils.makeGetter(globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopTracerProvider_1.NOOP_TRACER_PROVIDER);
                return this.getTracerProvider();
            };
            /**
	     * Returns the global tracer provider.
	     */ TraceAPI.prototype.getTracerProvider = function() {
                var _a, _b;
                return (_b = (_a = globalUtils._global[globalUtils.GLOBAL_TRACE_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(globalUtils._global, globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopTracerProvider_1.NOOP_TRACER_PROVIDER;
            };
            /**
	     * Returns a tracer from the global tracer provider.
	     */ TraceAPI.prototype.getTracer = function(name, version) {
                return this.getTracerProvider().getTracer(name, version);
            };
            /** Remove the global tracer provider */ TraceAPI.prototype.disable = function() {
                delete globalUtils._global[globalUtils.GLOBAL_TRACE_API_KEY];
            };
            return TraceAPI;
        }();
        exports.TraceAPI = TraceAPI;
    });
    unwrapExports(trace);
    var trace_1 = trace.TraceAPI;
    var metrics = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.MetricsAPI = void 0;
        /**
	 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
	 */ var MetricsAPI = /** @class */ function() {
            /** Empty private constructor prevents end users from constructing a new instance of the API */ function MetricsAPI() {}
            /** Get the singleton instance of the Metrics API */ MetricsAPI.getInstance = function() {
                if (!this._instance) this._instance = new MetricsAPI();
                return this._instance;
            };
            /**
	     * Set the current global meter. Returns the initialized global meter provider.
	     */ MetricsAPI.prototype.setGlobalMeterProvider = function(provider) {
                if (globalUtils._global[globalUtils.GLOBAL_METRICS_API_KEY]) // global meter provider has already been set
                return this.getMeterProvider();
                globalUtils._global[globalUtils.GLOBAL_METRICS_API_KEY] = globalUtils.makeGetter(globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopMeterProvider_1.NOOP_METER_PROVIDER);
                return provider;
            };
            /**
	     * Returns the global meter provider.
	     */ MetricsAPI.prototype.getMeterProvider = function() {
                var _a, _b;
                return (_b = (_a = globalUtils._global[globalUtils.GLOBAL_METRICS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(globalUtils._global, globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopMeterProvider_1.NOOP_METER_PROVIDER;
            };
            /**
	     * Returns a meter from the global meter provider.
	     */ MetricsAPI.prototype.getMeter = function(name, version) {
                return this.getMeterProvider().getMeter(name, version);
            };
            /** Remove the global meter provider */ MetricsAPI.prototype.disable = function() {
                delete globalUtils._global[globalUtils.GLOBAL_METRICS_API_KEY];
            };
            return MetricsAPI;
        }();
        exports.MetricsAPI = MetricsAPI;
    });
    unwrapExports(metrics);
    var metrics_1 = metrics.MetricsAPI;
    var propagation = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.PropagationAPI = void 0;
        var contextApi = context$1.ContextAPI.getInstance();
        /**
	 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
	 */ var PropagationAPI = /** @class */ function() {
            /** Empty private constructor prevents end users from constructing a new instance of the API */ function PropagationAPI() {}
            /** Get the singleton instance of the Propagator API */ PropagationAPI.getInstance = function() {
                if (!this._instance) this._instance = new PropagationAPI();
                return this._instance;
            };
            /**
	     * Set the current propagator. Returns the initialized propagator
	     */ PropagationAPI.prototype.setGlobalPropagator = function(propagator) {
                if (globalUtils._global[globalUtils.GLOBAL_PROPAGATION_API_KEY]) // global propagator has already been set
                return this._getGlobalPropagator();
                globalUtils._global[globalUtils.GLOBAL_PROPAGATION_API_KEY] = globalUtils.makeGetter(globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION, propagator, NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR);
                return propagator;
            };
            /**
	     * Inject context into a carrier to be propagated inter-process
	     *
	     * @param carrier carrier to inject context into
	     * @param setter Function used to set values on the carrier
	     * @param context Context carrying tracing data to inject. Defaults to the currently active context.
	     */ PropagationAPI.prototype.inject = function(carrier, setter$1, context) {
                if (setter$1 === void 0) setter$1 = setter.defaultSetter;
                if (context === void 0) context = contextApi.active();
                return this._getGlobalPropagator().inject(context, carrier, setter$1);
            };
            /**
	     * Extract context from a carrier
	     *
	     * @param carrier Carrier to extract context from
	     * @param getter Function used to extract keys from a carrier
	     * @param context Context which the newly created context will inherit from. Defaults to the currently active context.
	     */ PropagationAPI.prototype.extract = function(carrier, getter$1, context) {
                if (getter$1 === void 0) getter$1 = getter.defaultGetter;
                if (context === void 0) context = contextApi.active();
                return this._getGlobalPropagator().extract(context, carrier, getter$1);
            };
            /** Remove the global propagator */ PropagationAPI.prototype.disable = function() {
                delete globalUtils._global[globalUtils.GLOBAL_PROPAGATION_API_KEY];
            };
            PropagationAPI.prototype._getGlobalPropagator = function() {
                var _a, _b;
                return (_b = (_a = globalUtils._global[globalUtils.GLOBAL_PROPAGATION_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(globalUtils._global, globalUtils.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR;
            };
            return PropagationAPI;
        }();
        exports.PropagationAPI = PropagationAPI;
    });
    unwrapExports(propagation);
    var propagation_1 = propagation.PropagationAPI;
    var src$1 = createCommonjsModule(function(module1, exports) {
        /*
	 * Copyright The OpenTelemetry Authors
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *      https://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */ var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            Object.defineProperty(o, k2, {
                enumerable: true,
                get: function() {
                    return m[k];
                }
            });
        } : function(o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
        });
        var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports) {
            for(var p in m)if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
        };
        Object.defineProperty(exports, "__esModule", {
            value: true
        });
        exports.propagation = exports.metrics = exports.trace = exports.context = void 0;
        __exportStar(Logger, exports);
        __exportStar(Time, exports);
        __exportStar(getter, exports);
        __exportStar(HttpTextPropagator, exports);
        __exportStar(NoopHttpTextPropagator_1, exports);
        __exportStar(setter, exports);
        __exportStar(CorrelationContext, exports);
        __exportStar(EntryValue, exports);
        __exportStar(BatchObserverResult, exports);
        __exportStar(BoundInstrument, exports);
        __exportStar(Meter, exports);
        __exportStar(MeterProvider, exports);
        __exportStar(Metric, exports);
        __exportStar(NoopMeter_1, exports);
        __exportStar(NoopMeterProvider_1, exports);
        __exportStar(Observation, exports);
        __exportStar(ObserverResult, exports);
        __exportStar(attributes, exports);
        __exportStar(Event, exports);
        __exportStar(Plugin, exports);
        __exportStar(link_context, exports);
        __exportStar(link, exports);
        __exportStar(NoopSpan_1, exports);
        __exportStar(NoopTracer_1, exports);
        __exportStar(NoopTracerProvider_1, exports);
        __exportStar(Sampler, exports);
        __exportStar(SamplingResult, exports);
        __exportStar(span_context, exports);
        __exportStar(span_kind, exports);
        __exportStar(span, exports);
        __exportStar(SpanOptions, exports);
        __exportStar(status, exports);
        __exportStar(TimedEvent, exports);
        __exportStar(trace_flags, exports);
        __exportStar(trace_state, exports);
        __exportStar(tracer_provider, exports);
        __exportStar(tracer, exports);
        Object.defineProperty(exports, "Context", {
            enumerable: true,
            get: function() {
                return src.Context;
            }
        });
        /** Entrypoint for context API */ exports.context = context$1.ContextAPI.getInstance();
        /** Entrypoint for trace API */ exports.trace = trace.TraceAPI.getInstance();
        /** Entrypoint for metrics API */ exports.metrics = metrics.MetricsAPI.getInstance();
        /** Entrypoint for propagation API */ exports.propagation = propagation.PropagationAPI.getInstance();
        exports.default = {
            trace: exports.trace,
            metrics: exports.metrics,
            context: exports.context,
            propagation: exports.propagation
        };
    });
    unwrapExports(src$1);
    var src_1 = src$1.CanonicalCode;
    var src_2 = src$1.SpanKind;
    var src_3 = src$1.TraceFlags;
    var src_4 = src$1.propagation;
    var src_5 = src$1.metrics;
    var src_6 = src$1.trace;
    var src_7 = src$1.context;
    var src_8 = src$1.Context;
    // Copyright (c) Microsoft Corporation.
    /**
	 * A no-op implementation of Span that can safely be used without side-effects.
	 */ var NoOpSpan = /** @class */ function() {
        function NoOpSpan() {}
        /**
	     * Returns the SpanContext associated with this Span.
	     */ NoOpSpan.prototype.context = function() {
            return {
                spanId: "",
                traceId: "",
                traceFlags: src_3.NONE
            };
        };
        /**
	     * Marks the end of Span execution.
	     * @param _endTime The time to use as the Span's end time. Defaults to
	     * the current time.
	     */ NoOpSpan.prototype.end = function(_endTime) {
        /* Noop */ };
        /**
	     * Sets an attribute on the Span
	     * @param _key the attribute key
	     * @param _value the attribute value
	     */ NoOpSpan.prototype.setAttribute = function(_key, _value) {
            return this;
        };
        /**
	     * Sets attributes on the Span
	     * @param _attributes the attributes to add
	     */ NoOpSpan.prototype.setAttributes = function(_attributes) {
            return this;
        };
        /**
	     * Adds an event to the Span
	     * @param _name The name of the event
	     * @param _attributes The associated attributes to add for this event
	     */ NoOpSpan.prototype.addEvent = function(_name, _attributes) {
            return this;
        };
        /**
	     * Sets a status on the span. Overrides the default of CanonicalCode.OK.
	     * @param _status The status to set.
	     */ NoOpSpan.prototype.setStatus = function(_status) {
            return this;
        };
        /**
	     * Updates the name of the Span
	     * @param _name the new Span name
	     */ NoOpSpan.prototype.updateName = function(_name) {
            return this;
        };
        /**
	     * Returns whether this span will be recorded
	     */ NoOpSpan.prototype.isRecording = function() {
            return false;
        };
        return NoOpSpan;
    }();
    // Copyright (c) Microsoft Corporation.
    /**
	 * A no-op implementation of Tracer that can be used when tracing
	 * is disabled.
	 */ var NoOpTracer = /** @class */ function() {
        function NoOpTracer() {}
        /**
	     * Starts a new Span.
	     * @param _name The name of the span.
	     * @param _options The SpanOptions used during Span creation.
	     */ NoOpTracer.prototype.startSpan = function(_name, _options) {
            return new NoOpSpan();
        };
        /**
	     * Returns the current Span from the current context, if available.
	     */ NoOpTracer.prototype.getCurrentSpan = function() {
            return new NoOpSpan();
        };
        /**
	     * Executes the given function within the context provided by a Span.
	     * @param _span The span that provides the context.
	     * @param fn The function to be executed.
	     */ NoOpTracer.prototype.withSpan = function(_span, fn) {
            return fn();
        };
        /**
	     * Bind a Span as the target's scope
	     * @param target An object to bind the scope.
	     * @param _span A specific Span to use. Otherwise, use the current one.
	     */ NoOpTracer.prototype.bind = function(target, _span) {
            return target;
        };
        return NoOpTracer;
    }();
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    function getGlobalObject() {
        return self;
    }
    // Copyright (c) Microsoft Corporation.
    // V1 = OpenTelemetry 0.1
    // V2 = OpenTelemetry 0.2
    // V3 = OpenTelemetry 0.6.1
    var GLOBAL_TRACER_VERSION = 3;
    // preview5 shipped with @azure/core-tracing.tracerCache
    // and didn't have smart detection for collisions
    var GLOBAL_TRACER_SYMBOL = Symbol.for("@azure/core-tracing.tracerCache2");
    var cache;
    function loadTracerCache() {
        var globalObj = getGlobalObject();
        var existingCache = globalObj[GLOBAL_TRACER_SYMBOL];
        var setGlobalCache = true;
        if (existingCache) {
            if (existingCache.version === GLOBAL_TRACER_VERSION) cache = existingCache;
            else {
                setGlobalCache = false;
                if (existingCache.tracer) throw new Error("Two incompatible versions of @azure/core-tracing have been loaded.\n          This library is " + GLOBAL_TRACER_VERSION + ", existing is " + existingCache.version + ".");
            }
        }
        if (!cache) cache = {
            tracer: undefined,
            version: GLOBAL_TRACER_VERSION
        };
        if (setGlobalCache) globalObj[GLOBAL_TRACER_SYMBOL] = cache;
    }
    function getCache() {
        if (!cache) loadTracerCache();
        return cache;
    }
    // Copyright (c) Microsoft Corporation.
    var defaultTracer;
    function getDefaultTracer() {
        if (!defaultTracer) defaultTracer = new NoOpTracer();
        return defaultTracer;
    }
    /**
	 * Retrieves the active tracer, or returns a
	 * no-op implementation if one is not set.
	 */ function getTracer() {
        var cache = getCache();
        if (!cache.tracer) return getDefaultTracer();
        return cache.tracer;
    }
    // Copyright (c) Microsoft Corporation.
    // Licensed under the MIT license.
    var VERSION = "00";
    /**
	 * Generates a `traceparent` value given a span context.
	 * @param spanContext Contains context for a specific span.
	 * @returns The `spanContext` represented as a `traceparent` value.
	 */ function getTraceParentHeader(spanContext) {
        var missingFields = [];
        if (!spanContext.traceId) missingFields.push("traceId");
        if (!spanContext.spanId) missingFields.push("spanId");
        if (missingFields.length) return;
        var flags = spanContext.traceFlags || 0 /* NONE */ ;
        var hexFlags = flags.toString(16);
        var traceFlags = hexFlags.length === 1 ? "0" + hexFlags : hexFlags;
        // https://www.w3.org/TR/trace-context/#traceparent-header-field-values
        return VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-" + traceFlags;
    }
    // Copyright (c) Microsoft Corporation.
    function tracingPolicy(tracingOptions) {
        if (tracingOptions === void 0) tracingOptions = {};
        return {
            create: function(nextPolicy, options) {
                return new TracingPolicy(nextPolicy, options, tracingOptions);
            }
        };
    }
    var TracingPolicy = /** @class */ function(_super) {
        __extends(TracingPolicy, _super);
        function TracingPolicy(nextPolicy, options, tracingOptions) {
            var _this = _super.call(this, nextPolicy, options) || this;
            _this.userAgent = tracingOptions.userAgent;
            return _this;
        }
        TracingPolicy.prototype.sendRequest = function(request) {
            return __awaiter(this, void 0, void 0, function() {
                var tracer, spanOptions, path, span, spanContext, traceParentHeader, traceState, response, serviceRequestId, err_1;
                return __generator(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            if (!request.spanOptions || !request.spanOptions.parent) return [
                                2 /*return*/ ,
                                this._nextPolicy.sendRequest(request)
                            ];
                            tracer = getTracer();
                            spanOptions = __assign(__assign({}, request.spanOptions), {
                                kind: src_2.CLIENT
                            });
                            path = URLBuilder.parse(request.url).getPath() || "/";
                            span = tracer.startSpan(path, spanOptions);
                            span.setAttributes({
                                "http.method": request.method,
                                "http.url": request.url,
                                requestId: request.requestId
                            });
                            if (this.userAgent) span.setAttribute("http.user_agent", this.userAgent);
                            _a.label = 1;
                        case 1:
                            _a.trys.push([
                                1,
                                3,
                                ,
                                4
                            ]);
                            spanContext = span.context();
                            traceParentHeader = getTraceParentHeader(spanContext);
                            if (traceParentHeader) {
                                request.headers.set("traceparent", traceParentHeader);
                                traceState = spanContext.traceState && spanContext.traceState.serialize();
                                // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent
                                if (traceState) request.headers.set("tracestate", traceState);
                            }
                            return [
                                4 /*yield*/ ,
                                this._nextPolicy.sendRequest(request)
                            ];
                        case 2:
                            response = _a.sent();
                            span.setAttribute("http.status_code", response.status);
                            serviceRequestId = response.headers.get("x-ms-request-id");
                            if (serviceRequestId) span.setAttribute("serviceRequestId", serviceRequestId);
                            span.end();
                            return [
                                2 /*return*/ ,
                                response
                            ];
                        case 3:
                            err_1 = _a.sent();
                            span.end();
                            throw err_1;
                        case 4:
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        };
        return TracingPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    var DisbleResponseDecompressionNotSupportedInBrowser = new Error("DisableResponseDecompressionPolicy is not supported in browser environment");
    /**
	 * {@link DisableResponseDecompressionPolicy} is not supported in browser and attempting
	 * to use it will results in error being thrown.
	 */ function disableResponseDecompressionPolicy() {
        return {
            create: function(_nextPolicy, _options) {
                throw DisbleResponseDecompressionNotSupportedInBrowser;
            }
        };
    }
    var DisableResponseDecompressionPolicy = /** @class */ function(_super) {
        __extends(DisableResponseDecompressionPolicy, _super);
        function DisableResponseDecompressionPolicy(nextPolicy, options) {
            var _this = _super.call(this, nextPolicy, options) || this;
            throw DisbleResponseDecompressionNotSupportedInBrowser;
        }
        DisableResponseDecompressionPolicy.prototype.sendRequest = function(_request) {
            return __awaiter(this, void 0, void 0, function() {
                return __generator(this, function(_a) {
                    throw DisbleResponseDecompressionNotSupportedInBrowser;
                });
            });
        };
        return DisableResponseDecompressionPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    function ndJsonPolicy() {
        return {
            create: function(nextPolicy, options) {
                return new NdJsonPolicy(nextPolicy, options);
            }
        };
    }
    /**
	 * NdJsonPolicy that formats a JSON array as newline-delimited JSON
	 */ var NdJsonPolicy = /** @class */ function(_super) {
        __extends(NdJsonPolicy, _super);
        /**
	     * Creates an instance of KeepAlivePolicy.
	     *
	     * @param nextPolicy
	     * @param options
	     */ function NdJsonPolicy(nextPolicy, options) {
            return _super.call(this, nextPolicy, options) || this;
        }
        /**
	     * Sends a request.
	     *
	     * @param request
	     */ NdJsonPolicy.prototype.sendRequest = function(request) {
            return __awaiter(this, void 0, void 0, function() {
                var body;
                return __generator(this, function(_a) {
                    // There currently isn't a good way to bypass the serializer
                    if (typeof request.body === "string" && request.body.startsWith("[")) {
                        body = JSON.parse(request.body);
                        if (Array.isArray(body)) request.body = body.map(function(item) {
                            return JSON.stringify(item) + "\n";
                        }).join("");
                    }
                    return [
                        2 /*return*/ ,
                        this._nextPolicy.sendRequest(request)
                    ];
                });
            });
        };
        return NdJsonPolicy;
    }(BaseRequestPolicy);
    // Copyright (c) Microsoft Corporation.
    /**
	 * @class
	 * Initializes a new instance of the ServiceClient.
	 */ var ServiceClient = /** @class */ function() {
        /**
	     * The ServiceClient constructor
	     * @constructor
	     * @param credentials The credentials used for authentication with the service.
	     * @param options The service client options that govern the behavior of the client.
	     */ function ServiceClient(credentials, /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */ options) {
            var _this = this;
            if (!options) options = {};
            this._withCredentials = options.withCredentials || false;
            this._httpClient = options.httpClient || new XhrHttpClient();
            this._requestPolicyOptions = new RequestPolicyOptions(options.httpPipelineLogger);
            var requestPolicyFactories;
            if (Array.isArray(options.requestPolicyFactories)) {
                logger.info("ServiceClient: using custom request policies");
                requestPolicyFactories = options.requestPolicyFactories;
            } else {
                var authPolicyFactory = undefined;
                if (isTokenCredential(credentials)) {
                    logger.info("ServiceClient: creating bearer token authentication policy from provided credentials");
                    // Create a wrapped RequestPolicyFactory here so that we can provide the
                    // correct scope to the BearerTokenAuthenticationPolicy at the first time
                    // one is requested.  This is needed because generated ServiceClient
                    // implementations do not set baseUri until after ServiceClient's constructor
                    // is finished, leaving baseUri empty at the time when it is needed to
                    // build the correct scope name.
                    var wrappedPolicyFactory = function() {
                        var bearerTokenPolicyFactory = undefined;
                        // eslint-disable-next-line @typescript-eslint/no-this-alias
                        var serviceClient = _this;
                        return {
                            create: function(nextPolicy, options) {
                                if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) bearerTokenPolicyFactory = bearerTokenAuthenticationPolicy(credentials, (serviceClient.baseUri || "") + "/.default");
                                return bearerTokenPolicyFactory.create(nextPolicy, options);
                            }
                        };
                    };
                    authPolicyFactory = wrappedPolicyFactory();
                } else if (credentials && typeof credentials.signRequest === "function") {
                    logger.info("ServiceClient: creating signing policy from provided credentials");
                    authPolicyFactory = signingPolicy(credentials);
                } else if (credentials !== undefined && credentials !== null) throw new Error("The credentials argument must implement the TokenCredential interface");
                logger.info("ServiceClient: using default request policies");
                requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);
                if (options.requestPolicyFactories) {
                    // options.requestPolicyFactories can also be a function that manipulates
                    // the default requestPolicyFactories array
                    var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
                    if (newRequestPolicyFactories) requestPolicyFactories = newRequestPolicyFactories;
                }
            }
            this._requestPolicyFactories = requestPolicyFactories;
        }
        /**
	     * Send the provided httpRequest.
	     */ ServiceClient.prototype.sendRequest = function(options) {
            if (options === null || options === undefined || typeof options !== "object") throw new Error("options cannot be null or undefined and it must be of type object.");
            var httpRequest;
            try {
                if (isWebResourceLike(options)) {
                    options.validateRequestProperties();
                    httpRequest = options;
                } else {
                    httpRequest = new WebResource();
                    httpRequest = httpRequest.prepare(options);
                }
            } catch (error) {
                return Promise.reject(error);
            }
            var httpPipeline = this._httpClient;
            if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) for(var i = this._requestPolicyFactories.length - 1; i >= 0; --i)httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
            return httpPipeline.sendRequest(httpRequest);
        };
        /**
	     * Send an HTTP request that is populated using the provided OperationSpec.
	     * @param {OperationArguments} operationArguments The arguments that the HTTP request's templated values will be populated from.
	     * @param {OperationSpec} operationSpec The OperationSpec to use to populate the httpRequest.
	     * @param {ServiceCallback} callback The callback to call when the response is received.
	     */ ServiceClient.prototype.sendOperationRequest = function(operationArguments, operationSpec, callback) {
            var _a;
            return __awaiter(this, void 0, void 0, function() {
                var serializerOptions, httpRequest, result, baseUri, requestUrl, _i, _b, urlParameter, urlParameterValue, _c, _d, queryParameter, queryParameterValue, index, item, index, contentType, _e, _f, headerParameter, headerValue, headerCollectionPrefix, _g, _h, key, options, customHeaderName, rawResponse, sendRequestError, error_1, error_2, cb;
                return __generator(this, function(_j) {
                    switch(_j.label){
                        case 0:
                            if (typeof operationArguments.options === "function") {
                                callback = operationArguments.options;
                                operationArguments.options = undefined;
                            }
                            serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
                            httpRequest = new WebResource();
                            _j.label = 1;
                        case 1:
                            _j.trys.push([
                                1,
                                6,
                                ,
                                7
                            ]);
                            baseUri = operationSpec.baseUrl || this.baseUri;
                            if (!baseUri) throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
                            httpRequest.method = operationSpec.httpMethod;
                            httpRequest.operationSpec = operationSpec;
                            requestUrl = URLBuilder.parse(baseUri);
                            if (operationSpec.path) requestUrl.appendPath(operationSpec.path);
                            if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) for(_i = 0, _b = operationSpec.urlParameters; _i < _b.length; _i++){
                                urlParameter = _b[_i];
                                urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);
                                urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, getPathStringFromParameter(urlParameter), serializerOptions);
                                if (!urlParameter.skipEncoding) urlParameterValue = encodeURIComponent(urlParameterValue);
                                requestUrl.replaceAll("{" + (urlParameter.mapper.serializedName || getPathStringFromParameter(urlParameter)) + "}", urlParameterValue);
                            }
                            if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) for(_c = 0, _d = operationSpec.queryParameters; _c < _d.length; _c++){
                                queryParameter = _d[_c];
                                queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);
                                if (queryParameterValue !== undefined && queryParameterValue !== null) {
                                    queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter), serializerOptions);
                                    if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {
                                        if (queryParameter.collectionFormat === QueryCollectionFormat.Multi) {
                                            if (queryParameterValue.length === 0) continue;
                                            else for(index in queryParameterValue){
                                                item = queryParameterValue[index];
                                                queryParameterValue[index] = item === undefined || item === null ? "" : item.toString();
                                            }
                                        } else if (queryParameter.collectionFormat === QueryCollectionFormat.Ssv || queryParameter.collectionFormat === QueryCollectionFormat.Tsv) queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                                    }
                                    if (!queryParameter.skipEncoding) {
                                        if (Array.isArray(queryParameterValue)) {
                                            for(index in queryParameterValue)if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);
                                        } else queryParameterValue = encodeURIComponent(queryParameterValue);
                                    }
                                    if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== QueryCollectionFormat.Multi && queryParameter.collectionFormat !== QueryCollectionFormat.Ssv && queryParameter.collectionFormat !== QueryCollectionFormat.Tsv) queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                                    requestUrl.setQueryParameter(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
                                }
                            }
                            httpRequest.url = requestUrl.toString();
                            contentType = operationSpec.contentType || this.requestContentType;
                            if (contentType) httpRequest.headers.set("Content-Type", contentType);
                            if (operationSpec.headerParameters) for(_e = 0, _f = operationSpec.headerParameters; _e < _f.length; _e++){
                                headerParameter = _f[_e];
                                headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);
                                if (headerValue !== undefined && headerValue !== null) {
                                    headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter), serializerOptions);
                                    headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
                                    if (headerCollectionPrefix) for(_g = 0, _h = Object.keys(headerValue); _g < _h.length; _g++){
                                        key = _h[_g];
                                        httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                                    }
                                    else httpRequest.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
                                }
                            }
                            options = operationArguments.options;
                            if (options) {
                                if (options.customHeaders) for(customHeaderName in options.customHeaders)httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
                                if (options.abortSignal) httpRequest.abortSignal = options.abortSignal;
                                if (options.timeout) httpRequest.timeout = options.timeout;
                                if (options.onUploadProgress) httpRequest.onUploadProgress = options.onUploadProgress;
                                if (options.onDownloadProgress) httpRequest.onDownloadProgress = options.onDownloadProgress;
                                if (options.spanOptions) httpRequest.spanOptions = options.spanOptions;
                                if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) httpRequest.shouldDeserialize = options.shouldDeserialize;
                            }
                            httpRequest.withCredentials = this._withCredentials;
                            serializeRequestBody(this, httpRequest, operationArguments, operationSpec);
                            if (httpRequest.streamResponseBody === undefined || httpRequest.streamResponseBody === null) httpRequest.streamResponseBody = isStreamOperation(operationSpec);
                            rawResponse = void 0;
                            sendRequestError = void 0;
                            _j.label = 2;
                        case 2:
                            _j.trys.push([
                                2,
                                4,
                                ,
                                5
                            ]);
                            return [
                                4 /*yield*/ ,
                                this.sendRequest(httpRequest)
                            ];
                        case 3:
                            rawResponse = _j.sent();
                            return [
                                3 /*break*/ ,
                                5
                            ];
                        case 4:
                            error_1 = _j.sent();
                            sendRequestError = error_1;
                            return [
                                3 /*break*/ ,
                                5
                            ];
                        case 5:
                            if (sendRequestError) {
                                if (sendRequestError.response) sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses["default"]);
                                result = Promise.reject(sendRequestError);
                            } else result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));
                            return [
                                3 /*break*/ ,
                                7
                            ];
                        case 6:
                            error_2 = _j.sent();
                            result = Promise.reject(error_2);
                            return [
                                3 /*break*/ ,
                                7
                            ];
                        case 7:
                            cb = callback;
                            if (cb) result// tslint:disable-next-line:no-null-keyword
                            .then(function(res) {
                                return cb(null, res._response.parsedBody, res._response.request, res._response);
                            }).catch(function(err) {
                                return cb(err);
                            });
                            return [
                                2 /*return*/ ,
                                result
                            ];
                    }
                });
            });
        };
        return ServiceClient;
    }();
    function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
        var _a, _b, _c, _d, _e, _f;
        var serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};
        var updatedOptions = {
            rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : "",
            includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,
            xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : XML_CHARKEY
        };
        var xmlCharKey = serializerOptions.xmlCharKey;
        if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
            httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
            var bodyMapper = operationSpec.requestBody.mapper;
            var required = bodyMapper.required, xmlName = bodyMapper.xmlName, xmlElementName = bodyMapper.xmlElementName, serializedName = bodyMapper.serializedName, xmlNamespace = bodyMapper.xmlNamespace, xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix;
            var typeName = bodyMapper.type.name;
            try {
                if (httpRequest.body !== undefined && httpRequest.body !== null || required) {
                    var requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
                    httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
                    var isStream = typeName === MapperType.Stream;
                    if (operationSpec.isXML) {
                        var xmlnsKey = xmlNamespacePrefix ? "xmlns:" + xmlNamespacePrefix : "xmlns";
                        var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);
                        if (typeName === MapperType.Sequence) httpRequest.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
                            rootName: xmlName || serializedName,
                            xmlCharKey: xmlCharKey
                        });
                        else if (!isStream) httpRequest.body = stringifyXML(value, {
                            rootName: xmlName || serializedName,
                            xmlCharKey: xmlCharKey
                        });
                    } else if (typeName === MapperType.String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match("text/plain")) || operationSpec.mediaType === "text")) // the String serializer has validated that request body is a string
                    // so just send the string.
                    return;
                    else if (!isStream) httpRequest.body = JSON.stringify(httpRequest.body);
                }
            } catch (error) {
                throw new Error("Error \"" + error.message + "\" occurred in serializing the payload - " + JSON.stringify(serializedName, undefined, "  ") + ".");
            }
        } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
            httpRequest.formData = {};
            for(var _i = 0, _g = operationSpec.formDataParameters; _i < _g.length; _i++){
                var formDataParameter = _g[_i];
                var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
                if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
                    var formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
                    httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
                }
            }
        }
    }
    /**
	 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
	 */ function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
        var _a;
        // Composite and Sequence schemas already got their root namespace set during serialization
        // We just need to add xmlns to the other schema types
        if (xmlNamespace && ![
            "Composite",
            "Sequence",
            "Dictionary"
        ].includes(typeName)) {
            var result = {};
            result[options.xmlCharKey] = serializedValue;
            result[XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = xmlNamespace, _a);
            return result;
        }
        return serializedValue;
    }
    function getValueOrFunctionResult(value, defaultValueCreator) {
        var result;
        if (typeof value === "string") result = value;
        else {
            result = defaultValueCreator();
            if (typeof value === "function") result = value(result);
        }
        return result;
    }
    function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
        var factories = [];
        if (options.generateClientRequestIdHeader) factories.push(generateClientRequestIdPolicy(options.clientRequestIdHeaderName));
        if (authPolicyFactory) factories.push(authPolicyFactory);
        var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, getDefaultUserAgentHeaderName);
        var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, getDefaultUserAgentValue);
        if (userAgentHeaderName && userAgentHeaderValue) factories.push(userAgentPolicy({
            key: userAgentHeaderName,
            value: userAgentHeaderValue
        }));
        factories.push(redirectPolicy());
        factories.push(rpRegistrationPolicy(options.rpRegistrationRetryTimeout));
        if (!options.noRetryPolicy) {
            factories.push(exponentialRetryPolicy());
            factories.push(systemErrorRetryPolicy());
            factories.push(throttlingRetryPolicy());
        }
        factories.push(deserializationPolicy(options.deserializationContentTypes));
        factories.push(logPolicy({
            logger: logger.info
        }));
        return factories;
    }
    function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {
        var requestPolicyFactories = [];
        if (pipelineOptions.sendStreamingJson) requestPolicyFactories.push(ndJsonPolicy());
        var userAgentValue = undefined;
        if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {
            var userAgentInfo = [];
            userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);
            // Add the default user agent value if it isn't already specified
            // by the userAgentPrefix option.
            var defaultUserAgentInfo = getDefaultUserAgentValue();
            if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) userAgentInfo.push(defaultUserAgentInfo);
            userAgentValue = userAgentInfo.join(" ");
        }
        var keepAliveOptions = __assign(__assign({}, DefaultKeepAliveOptions), pipelineOptions.keepAliveOptions);
        var retryOptions = __assign(__assign({}, DefaultRetryOptions), pipelineOptions.retryOptions);
        var redirectOptions = __assign(__assign({}, DefaultRedirectOptions), pipelineOptions.redirectOptions);
        var deserializationOptions = __assign(__assign({}, DefaultDeserializationOptions), pipelineOptions.deserializationOptions);
        var loggingOptions = __assign({}, pipelineOptions.loggingOptions);
        requestPolicyFactories.push(tracingPolicy({
            userAgent: userAgentValue
        }), keepAlivePolicy(keepAliveOptions), userAgentPolicy({
            value: userAgentValue
        }), generateClientRequestIdPolicy(), deserializationPolicy(deserializationOptions.expectedContentTypes), throttlingRetryPolicy(), systemErrorRetryPolicy(), exponentialRetryPolicy(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));
        if (redirectOptions.handleRedirects) requestPolicyFactories.push(redirectPolicy(redirectOptions.maxRetries));
        if (authPolicyFactory) requestPolicyFactories.push(authPolicyFactory);
        requestPolicyFactories.push(logPolicy(loggingOptions));
        if (isNode && pipelineOptions.decompressResponse === false) requestPolicyFactories.push(disableResponseDecompressionPolicy());
        return {
            httpClient: pipelineOptions.httpClient,
            requestPolicyFactories: requestPolicyFactories
        };
    }
    function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {
        return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);
    }
    function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {
        var _a;
        var value;
        if (typeof parameterPath === "string") parameterPath = [
            parameterPath
        ];
        var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
        if (Array.isArray(parameterPath)) {
            if (parameterPath.length > 0) {
                if (parameterMapper.isConstant) value = parameterMapper.defaultValue;
                else {
                    var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
                    if (!propertySearchResult.propertyFound) propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);
                    var useDefaultValue = false;
                    if (!propertySearchResult.propertyFound) useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
                    value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
                }
                // Serialize just for validation purposes.
                var parameterPathString = getPathStringFromParameterPath(parameterPath, parameterMapper);
                serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);
            }
        } else {
            if (parameterMapper.required) value = {};
            for(var propertyName in parameterPath){
                var propertyMapper = parameterMapper.type.modelProperties[propertyName];
                var propertyPath = parameterPath[propertyName];
                var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);
                // Serialize just for validation purposes.
                var propertyPathString = getPathStringFromParameterPath(propertyPath, propertyMapper);
                serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);
                if (propertyValue !== undefined && propertyValue !== null) {
                    if (!value) value = {};
                    value[propertyName] = propertyValue;
                }
            }
        }
        return value;
    }
    function getPropertyFromParameterPath(parent, parameterPath) {
        var result = {
            propertyFound: false
        };
        var i = 0;
        for(; i < parameterPath.length; ++i){
            var parameterPathPart = parameterPath[i];
            // Make sure to check inherited properties too, so don't use hasOwnProperty().
            if (parent !== undefined && parent !== null && parameterPathPart in parent) parent = parent[parameterPathPart];
            else break;
        }
        if (i === parameterPath.length) {
            result.propertyValue = parent;
            result.propertyFound = true;
        }
        return result;
    }
    function flattenResponse(_response, responseSpec) {
        var parsedHeaders = _response.parsedHeaders;
        var bodyMapper = responseSpec && responseSpec.bodyMapper;
        var addOperationResponse = function(obj) {
            return Object.defineProperty(obj, "_response", {
                value: _response
            });
        };
        if (bodyMapper) {
            var typeName = bodyMapper.type.name;
            if (typeName === "Stream") return addOperationResponse(__assign(__assign({}, parsedHeaders), {
                blobBody: _response.blobBody,
                readableStreamBody: _response.readableStreamBody
            }));
            var modelProperties_1 = typeName === "Composite" && bodyMapper.type.modelProperties || {};
            var isPageableResponse = Object.keys(modelProperties_1).some(function(k) {
                return modelProperties_1[k].serializedName === "";
            });
            if (typeName === "Sequence" || isPageableResponse) {
                var arrayResponse = __spreadArrays(_response.parsedBody || []);
                for(var _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++){
                    var key = _a[_i];
                    if (modelProperties_1[key].serializedName) arrayResponse[key] = _response.parsedBody[key];
                }
                if (parsedHeaders) for(var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++){
                    var key = _c[_b];
                    arrayResponse[key] = parsedHeaders[key];
                }
                addOperationResponse(arrayResponse);
                return arrayResponse;
            }
            if (typeName === "Composite" || typeName === "Dictionary") return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));
        }
        if (bodyMapper || _response.request.method === "HEAD" || isPrimitiveType(_response.parsedBody)) // primitive body types and HEAD booleans
        return addOperationResponse(__assign(__assign({}, parsedHeaders), {
            body: _response.parsedBody
        }));
        return addOperationResponse(__assign(__assign({}, parsedHeaders), _response.parsedBody));
    }
    // Copyright (c) Microsoft Corporation.
    var HeaderConstants = Constants.HeaderConstants;
    var DEFAULT_AUTHORIZATION_SCHEME = "Basic";
    var BasicAuthenticationCredentials = /** @class */ function() {
        /**
	     * Creates a new BasicAuthenticationCredentials object.
	     *
	     * @constructor
	     * @param {string} userName User name.
	     * @param {string} password Password.
	     * @param {string} [authorizationScheme] The authorization scheme.
	     */ function BasicAuthenticationCredentials(userName, password, authorizationScheme) {
            if (authorizationScheme === void 0) authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
            this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
            if (userName === null || userName === undefined || typeof userName.valueOf() !== "string") throw new Error("userName cannot be null or undefined and must be of type string.");
            if (password === null || password === undefined || typeof password.valueOf() !== "string") throw new Error("password cannot be null or undefined and must be of type string.");
            this.userName = userName;
            this.password = password;
            this.authorizationScheme = authorizationScheme;
        }
        /**
	     * Signs a request with the Authentication header.
	     *
	     * @param {WebResourceLike} webResource The WebResourceLike to be signed.
	     * @returns {Promise<WebResourceLike>} The signed request object.
	     */ BasicAuthenticationCredentials.prototype.signRequest = function(webResource) {
            var credentials = this.userName + ":" + this.password;
            var encodedCredentials = this.authorizationScheme + " " + encodeString(credentials);
            if (!webResource.headers) webResource.headers = new HttpHeaders();
            webResource.headers.set(HeaderConstants.AUTHORIZATION, encodedCredentials);
            return Promise.resolve(webResource);
        };
        return BasicAuthenticationCredentials;
    }();
    // Copyright (c) Microsoft Corporation.
    /**
	 * Authenticates to a service using an API key.
	 */ var ApiKeyCredentials = /** @class */ function() {
        /**
	     * @constructor
	     * @param {object} options   Specifies the options to be provided for auth. Either header or query needs to be provided.
	     */ function ApiKeyCredentials(options) {
            if (!options || options && !options.inHeader && !options.inQuery) throw new Error("options cannot be null or undefined. Either \"inHeader\" or \"inQuery\" property of the options object needs to be provided.");
            this.inHeader = options.inHeader;
            this.inQuery = options.inQuery;
        }
        /**
	     * Signs a request with the values provided in the inHeader and inQuery parameter.
	     *
	     * @param {WebResourceLike} webResource The WebResourceLike to be signed.
	     * @returns {Promise<WebResourceLike>} The signed request object.
	     */ ApiKeyCredentials.prototype.signRequest = function(webResource) {
            if (!webResource) return Promise.reject(new Error("webResource cannot be null or undefined and must be of type \"object\"."));
            if (this.inHeader) {
                if (!webResource.headers) webResource.headers = new HttpHeaders();
                for(var headerName in this.inHeader)webResource.headers.set(headerName, this.inHeader[headerName]);
            }
            if (this.inQuery) {
                if (!webResource.url) return Promise.reject(new Error("url cannot be null in the request object."));
                if (webResource.url.indexOf("?") < 0) webResource.url += "?";
                for(var key in this.inQuery){
                    if (!webResource.url.endsWith("?")) webResource.url += "&";
                    webResource.url += key + "=" + this.inQuery[key];
                }
            }
            return Promise.resolve(webResource);
        };
        return ApiKeyCredentials;
    }();
    // Copyright (c) Microsoft Corporation.
    var TopicCredentials = /** @class */ function(_super) {
        __extends(TopicCredentials, _super);
        /**
	     * Creates a new EventGrid TopicCredentials object.
	     *
	     * @constructor
	     * @param {string} topicKey   The EventGrid topic key
	     */ function TopicCredentials(topicKey) {
            var _this = this;
            if (!topicKey || topicKey && typeof topicKey !== "string") throw new Error("topicKey cannot be null or undefined and must be of type string.");
            var options = {
                inHeader: {
                    "aeg-sas-key": topicKey
                }
            };
            _this = _super.call(this, options) || this;
            return _this;
        }
        return TopicCredentials;
    }(ApiKeyCredentials);
    // Copyright (c) Microsoft Corporation.
    var coreHttp = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        WebResource: WebResource,
        DefaultHttpClient: XhrHttpClient,
        HttpHeaders: HttpHeaders,
        get HttpPipelineLogLevel () {
            return HttpPipelineLogLevel;
        },
        RestError: RestError,
        operationOptionsToRequestOptionsBase: operationOptionsToRequestOptionsBase,
        ServiceClient: ServiceClient,
        flattenResponse: flattenResponse,
        createPipelineFromOptions: createPipelineFromOptions,
        get QueryCollectionFormat () {
            return QueryCollectionFormat;
        },
        Constants: Constants,
        bearerTokenAuthenticationPolicy: bearerTokenAuthenticationPolicy,
        logPolicy: logPolicy,
        BaseRequestPolicy: BaseRequestPolicy,
        RequestPolicyOptions: RequestPolicyOptions,
        generateClientRequestIdPolicy: generateClientRequestIdPolicy,
        exponentialRetryPolicy: exponentialRetryPolicy,
        get RetryMode () {
            return RetryMode;
        },
        systemErrorRetryPolicy: systemErrorRetryPolicy,
        throttlingRetryPolicy: throttlingRetryPolicy,
        getDefaultProxySettings: getDefaultProxySettings,
        proxyPolicy: proxyPolicy,
        redirectPolicy: redirectPolicy,
        keepAlivePolicy: keepAlivePolicy,
        disableResponseDecompressionPolicy: disableResponseDecompressionPolicy,
        signingPolicy: signingPolicy,
        userAgentPolicy: userAgentPolicy,
        getDefaultUserAgentValue: getDefaultUserAgentValue,
        deserializationPolicy: deserializationPolicy,
        deserializeResponseBody: deserializeResponseBody,
        tracingPolicy: tracingPolicy,
        MapperType: MapperType,
        Serializer: Serializer,
        serializeObject: serializeObject,
        stripRequest: stripRequest,
        stripResponse: stripResponse,
        delay: delay,
        executePromisesSequentially: executePromisesSequentially,
        generateUuid: generateUuid,
        encodeUri: encodeUri,
        promiseToCallback: promiseToCallback,
        promiseToServiceCallback: promiseToServiceCallback,
        isValidUuid: isValidUuid,
        applyMixins: applyMixins,
        isNode: isNode,
        isDuration: isDuration,
        URLBuilder: URLBuilder,
        URLQuery: URLQuery,
        isTokenCredential: isTokenCredential,
        ExpiringAccessTokenCache: ExpiringAccessTokenCache,
        AccessTokenRefresher: AccessTokenRefresher,
        BasicAuthenticationCredentials: BasicAuthenticationCredentials,
        ApiKeyCredentials: ApiKeyCredentials,
        TopicCredentials: TopicCredentials,
        parseXML: parseXML,
        stringifyXML: stringifyXML,
        XML_ATTRKEY: XML_ATTRKEY,
        XML_CHARKEY: XML_CHARKEY
    });
    var TrouterSettings = createCommonjsModule(function(module1, exports) {
        exports.__esModule = true;
        var defaultSettings = {
            version: "1.0.0",
            registrationId: "",
            sessionId: "",
            pnhAppId: "AcsWeb",
            pnhTemplate: "AcsWeb_Chat_1.0",
            platform: "SPOOL",
            platformUIVersion: "0.0.0",
            environment: "",
            productName: "acs-chat-web",
            trouterServiceUrl: "https://go.trouter.skype.com/v4/a",
            registrarServiceUrl: "https://edge.skype.com/registrar/prod/v3/registrations",
            registrarRefreshTimeoutInMs: 350000,
            timeoutOptions: {
                connectionTimeoutMs: 20000,
                fetchTimeoutMs: 10000,
                pingTimeoutMs: 40000,
                pongTimeoutMs: 5000,
                maxBackoffMs: 50000,
                requestTimeoutMs: 5000
            },
            maxRegistrationTimeInMs: 7200000
        };
        exports.createSettings = function(options) {
            var _a;
            var settings = defaultSettings;
            settings.registrationId = coreHttp.generateUuid();
            settings.sessionId = coreHttp.generateUuid();
            settings.maxRegistrationTimeInMs = (_a = options === null || options === void 0 ? void 0 : options.registrationTimeInMs) !== null && _a !== void 0 ? _a : defaultSettings.maxRegistrationTimeInMs;
            return settings;
        };
        exports.defaultTelemetrySettings = {
            // TBD Can we hook up OpenTelemetry?
            enabled: false
        };
    });
    unwrapExports(TrouterSettings);
    var TrouterSettings_1 = TrouterSettings.createSettings;
    var TrouterSettings_2 = TrouterSettings.defaultTelemetrySettings;
    var SignalingClient = createCommonjsModule(function(module1, exports) {
        // Copyright (c) Microsoft Corporation.
        // Licensed under the MIT license.
        var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
            function adopt(value) {
                return value instanceof P ? value : new P(function(resolve) {
                    resolve(value);
                });
            }
            return new (P || (P = Promise))(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator["throw"](value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
            var _ = {
                label: 0,
                sent: function() {
                    if (t[0] & 1) throw t[1];
                    return t[1];
                },
                trys: [],
                ops: []
            }, f, y, t, g;
            return g = {
                next: verb(0),
                "throw": verb(1),
                "return": verb(2)
            }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                return this;
            }), g;
            function verb(n) {
                return function(v) {
                    return step([
                        n,
                        v
                    ]);
                };
            }
            function step(op) {
                if (f) throw new TypeError("Generator is already executing.");
                while(_)try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                    if (y = 0, t) op = [
                        op[0] & 2,
                        t.value
                    ];
                    switch(op[0]){
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return {
                                value: op[1],
                                done: false
                            };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [
                                0
                            ];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2]) _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                } catch (e) {
                    op = [
                        6,
                        e
                    ];
                    y = 0;
                } finally{
                    f = t = 0;
                }
                if (op[0] & 5) throw op[1];
                return {
                    value: op[0] ? op[1] : void 0,
                    done: true
                };
            }
        };
        exports.__esModule = true;
        var ConnectionState;
        (function(ConnectionState) {
            ConnectionState[ConnectionState["Unknown"] = 0] = "Unknown";
            ConnectionState[ConnectionState["Connected"] = 2] = "Connected";
            ConnectionState[ConnectionState["Disconnected"] = 3] = "Disconnected";
            ConnectionState[ConnectionState["Switching"] = 9] = "Switching";
        })(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));
        var CommunicationSignalingClient = /** @class */ function() {
            function CommunicationSignalingClient(credential, logger, options) {
                var _this = this;
                this.logger = logger;
                this.stateChangedListener = null;
                this.trouter = tstrouter.createTrouterService(TrouterUtils.toLogProvider(logger));
                this.config = {
                    trouterSettings: TrouterSettings.createSettings(options),
                    skypeTokenProvider: function() {
                        return __awaiter(_this, void 0, void 0, function() {
                            var _a, _b;
                            return __generator(this, function(_c) {
                                switch(_c.label){
                                    case 0:
                                        _b = (_a = Promise).resolve;
                                        return [
                                            4 /*yield*/ ,
                                            credential.getToken()
                                        ];
                                    case 1:
                                        return [
                                            2 /*return*/ ,
                                            _b.apply(_a, [
                                                _c.sent().token
                                            ])
                                        ];
                                }
                            });
                        });
                    },
                    telemetryConfig: {
                        eventLogger: TrouterUtils.toTelemetrySender(logger),
                        settings: TrouterSettings.defaultTelemetrySettings
                    }
                };
            }
            CommunicationSignalingClient.prototype.start = function() {
                this.trouter.start(this.config);
            };
            CommunicationSignalingClient.prototype.stop = function() {
                this.trouter.offStateChanged(this.stateChangedListener);
                this.trouter.clearMessageHandlers();
                this.trouter.stop();
            };
            CommunicationSignalingClient.prototype.on = function(event, listener) {
                if (event === "connectionChanged") {
                    this.trouter.offStateChanged(this.stateChangedListener);
                    this.stateChangedListener = function(state, _url) {
                        return listener(state);
                    };
                    this.trouter.onStateChanged(this.stateChangedListener);
                    return;
                }
                this.trouter.registerMessageHandler(TrouterUtils.toMessageHandler(event, listener));
            };
            return CommunicationSignalingClient;
        }();
        exports.CommunicationSignalingClient = CommunicationSignalingClient;
    });
    unwrapExports(SignalingClient);
    var SignalingClient_1 = SignalingClient.ConnectionState;
    var SignalingClient_2 = SignalingClient.CommunicationSignalingClient;
    var src$2 = createCommonjsModule(function(module1, exports) {
        // Copyright (c) Microsoft Corporation.
        // Licensed under the MIT license.
        function __export(m) {
            for(var p in m)if (!exports.hasOwnProperty(p)) exports[p] = m[p];
        }
        exports.__esModule = true;
        __export(SignalingClient);
    });
    var index = unwrapExports(src$2);
    return index;
}); //# sourceMappingURL=azure-communicationservices-signaling.js.map

},{"602c135dbe3c0dd":"euskh"}],"euskh":[function(require,module,exports,__globalThis) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"1W9s4":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable-next-line @typescript-eslint/triple-slash-reference */ /// <reference path="../dom-shim.d.ts" />
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WebResource", ()=>(0, _webResource.WebResource));
parcelHelpers.export(exports, "DefaultHttpClient", ()=>(0, _defaultHttpClient.DefaultHttpClient));
parcelHelpers.export(exports, "HttpHeaders", ()=>(0, _httpHeaders.HttpHeaders));
parcelHelpers.export(exports, "HttpPipelineLogLevel", ()=>(0, _httpPipelineLogLevel.HttpPipelineLogLevel));
parcelHelpers.export(exports, "RestError", ()=>(0, _restError.RestError));
parcelHelpers.export(exports, "operationOptionsToRequestOptionsBase", ()=>(0, _operationOptions.operationOptionsToRequestOptionsBase));
parcelHelpers.export(exports, "ServiceClient", ()=>(0, _serviceClient.ServiceClient));
parcelHelpers.export(exports, "flattenResponse", ()=>(0, _serviceClient.flattenResponse));
parcelHelpers.export(exports, "createPipelineFromOptions", ()=>(0, _serviceClient.createPipelineFromOptions));
parcelHelpers.export(exports, "QueryCollectionFormat", ()=>(0, _queryCollectionFormat.QueryCollectionFormat));
parcelHelpers.export(exports, "Constants", ()=>(0, _constants.Constants));
parcelHelpers.export(exports, "bearerTokenAuthenticationPolicy", ()=>(0, _bearerTokenAuthenticationPolicy.bearerTokenAuthenticationPolicy));
parcelHelpers.export(exports, "logPolicy", ()=>(0, _logPolicy.logPolicy));
parcelHelpers.export(exports, "BaseRequestPolicy", ()=>(0, _requestPolicy.BaseRequestPolicy));
parcelHelpers.export(exports, "RequestPolicyOptions", ()=>(0, _requestPolicy.RequestPolicyOptions));
parcelHelpers.export(exports, "generateClientRequestIdPolicy", ()=>(0, _generateClientRequestIdPolicy.generateClientRequestIdPolicy));
parcelHelpers.export(exports, "exponentialRetryPolicy", ()=>(0, _exponentialRetryPolicy.exponentialRetryPolicy));
parcelHelpers.export(exports, "RetryMode", ()=>(0, _exponentialRetryPolicy.RetryMode));
parcelHelpers.export(exports, "systemErrorRetryPolicy", ()=>(0, _systemErrorRetryPolicy.systemErrorRetryPolicy));
parcelHelpers.export(exports, "throttlingRetryPolicy", ()=>(0, _throttlingRetryPolicy.throttlingRetryPolicy));
parcelHelpers.export(exports, "getDefaultProxySettings", ()=>(0, _proxyPolicy.getDefaultProxySettings));
parcelHelpers.export(exports, "proxyPolicy", ()=>(0, _proxyPolicy.proxyPolicy));
parcelHelpers.export(exports, "redirectPolicy", ()=>(0, _redirectPolicy.redirectPolicy));
parcelHelpers.export(exports, "keepAlivePolicy", ()=>(0, _keepAlivePolicy.keepAlivePolicy));
parcelHelpers.export(exports, "disableResponseDecompressionPolicy", ()=>(0, _disableResponseDecompressionPolicy.disableResponseDecompressionPolicy));
parcelHelpers.export(exports, "signingPolicy", ()=>(0, _signingPolicy.signingPolicy));
parcelHelpers.export(exports, "userAgentPolicy", ()=>(0, _userAgentPolicy.userAgentPolicy));
parcelHelpers.export(exports, "getDefaultUserAgentValue", ()=>(0, _userAgentPolicy.getDefaultUserAgentValue));
parcelHelpers.export(exports, "deserializationPolicy", ()=>(0, _deserializationPolicy.deserializationPolicy));
parcelHelpers.export(exports, "deserializeResponseBody", ()=>(0, _deserializationPolicy.deserializeResponseBody));
parcelHelpers.export(exports, "tracingPolicy", ()=>(0, _tracingPolicy.tracingPolicy));
parcelHelpers.export(exports, "MapperType", ()=>(0, _serializer.MapperType));
parcelHelpers.export(exports, "Serializer", ()=>(0, _serializer.Serializer));
parcelHelpers.export(exports, "serializeObject", ()=>(0, _serializer.serializeObject));
parcelHelpers.export(exports, "stripRequest", ()=>(0, _utils.stripRequest));
parcelHelpers.export(exports, "stripResponse", ()=>(0, _utils.stripResponse));
parcelHelpers.export(exports, "delay", ()=>(0, _utils.delay));
parcelHelpers.export(exports, "executePromisesSequentially", ()=>(0, _utils.executePromisesSequentially));
parcelHelpers.export(exports, "generateUuid", ()=>(0, _utils.generateUuid));
parcelHelpers.export(exports, "encodeUri", ()=>(0, _utils.encodeUri));
parcelHelpers.export(exports, "promiseToCallback", ()=>(0, _utils.promiseToCallback));
parcelHelpers.export(exports, "promiseToServiceCallback", ()=>(0, _utils.promiseToServiceCallback));
parcelHelpers.export(exports, "isValidUuid", ()=>(0, _utils.isValidUuid));
parcelHelpers.export(exports, "applyMixins", ()=>(0, _utils.applyMixins));
parcelHelpers.export(exports, "isNode", ()=>(0, _utils.isNode));
parcelHelpers.export(exports, "isDuration", ()=>(0, _utils.isDuration));
parcelHelpers.export(exports, "URLBuilder", ()=>(0, _url.URLBuilder));
parcelHelpers.export(exports, "URLQuery", ()=>(0, _url.URLQuery));
// legacy exports. Use core-tracing instead (and remove on next major version update of core-http).
parcelHelpers.export(exports, "createSpanFunction", ()=>(0, _createSpanLegacy.createSpanFunction));
// Credentials
parcelHelpers.export(exports, "isTokenCredential", ()=>(0, _coreAuth.isTokenCredential));
parcelHelpers.export(exports, "ExpiringAccessTokenCache", ()=>(0, _accessTokenCache.ExpiringAccessTokenCache));
parcelHelpers.export(exports, "AccessTokenRefresher", ()=>(0, _accessTokenRefresher.AccessTokenRefresher));
parcelHelpers.export(exports, "BasicAuthenticationCredentials", ()=>(0, _basicAuthenticationCredentials.BasicAuthenticationCredentials));
parcelHelpers.export(exports, "ApiKeyCredentials", ()=>(0, _apiKeyCredentials.ApiKeyCredentials));
parcelHelpers.export(exports, "TopicCredentials", ()=>(0, _topicCredentials.TopicCredentials));
parcelHelpers.export(exports, "parseXML", ()=>(0, _xml.parseXML));
parcelHelpers.export(exports, "stringifyXML", ()=>(0, _xml.stringifyXML));
parcelHelpers.export(exports, "XML_ATTRKEY", ()=>(0, _serializerCommon.XML_ATTRKEY));
parcelHelpers.export(exports, "XML_CHARKEY", ()=>(0, _serializerCommon.XML_CHARKEY));
var _webResource = require("./webResource");
var _defaultHttpClient = require("./defaultHttpClient");
var _httpHeaders = require("./httpHeaders");
var _httpPipelineLogLevel = require("./httpPipelineLogLevel");
var _restError = require("./restError");
var _operationOptions = require("./operationOptions");
var _serviceClient = require("./serviceClient");
var _queryCollectionFormat = require("./queryCollectionFormat");
var _constants = require("./util/constants");
var _bearerTokenAuthenticationPolicy = require("./policies/bearerTokenAuthenticationPolicy");
var _logPolicy = require("./policies/logPolicy");
var _requestPolicy = require("./policies/requestPolicy");
var _generateClientRequestIdPolicy = require("./policies/generateClientRequestIdPolicy");
var _exponentialRetryPolicy = require("./policies/exponentialRetryPolicy");
var _systemErrorRetryPolicy = require("./policies/systemErrorRetryPolicy");
var _throttlingRetryPolicy = require("./policies/throttlingRetryPolicy");
var _proxyPolicy = require("./policies/proxyPolicy");
var _redirectPolicy = require("./policies/redirectPolicy");
var _keepAlivePolicy = require("./policies/keepAlivePolicy");
var _disableResponseDecompressionPolicy = require("./policies/disableResponseDecompressionPolicy");
var _signingPolicy = require("./policies/signingPolicy");
var _userAgentPolicy = require("./policies/userAgentPolicy");
var _deserializationPolicy = require("./policies/deserializationPolicy");
var _tracingPolicy = require("./policies/tracingPolicy");
var _serializer = require("./serializer");
var _utils = require("./util/utils");
var _url = require("./url");
var _createSpanLegacy = require("./createSpanLegacy");
var _coreAuth = require("@azure/core-auth");
var _accessTokenCache = require("./credentials/accessTokenCache");
var _accessTokenRefresher = require("./credentials/accessTokenRefresher");
var _basicAuthenticationCredentials = require("./credentials/basicAuthenticationCredentials");
var _apiKeyCredentials = require("./credentials/apiKeyCredentials");
var _topicCredentials = require("./credentials/topicCredentials");
var _xml = require("./util/xml");
var _serializerCommon = require("./util/serializer.common");
var _coreAsynciteratorPolyfill = require("@azure/core-asynciterator-polyfill");

},{"./webResource":"77t2g","./defaultHttpClient":"13Xl5","./httpHeaders":"dFs7b","./httpPipelineLogLevel":"5X4Pz","./restError":"bqwGr","./operationOptions":"6kYTS","./serviceClient":"2jEVW","./queryCollectionFormat":"fFmLI","./util/constants":"bc7jT","./policies/bearerTokenAuthenticationPolicy":"d1DQw","./policies/logPolicy":"aJgvb","./policies/requestPolicy":"hwRyd","./policies/generateClientRequestIdPolicy":"h0Glf","./policies/exponentialRetryPolicy":"2RHu1","./policies/systemErrorRetryPolicy":"9Dfm1","./policies/throttlingRetryPolicy":"cYNpY","./policies/proxyPolicy":"5pJXW","./policies/redirectPolicy":"fPfUj","./policies/keepAlivePolicy":"4ufUI","./policies/disableResponseDecompressionPolicy":"o23vK","./policies/signingPolicy":"gFY9S","./policies/userAgentPolicy":"hPQrK","./policies/deserializationPolicy":"3LuMW","./policies/tracingPolicy":"9BOvG","./serializer":"4pdUf","./util/utils":"3ok7s","./url":"6ht7o","./createSpanLegacy":"dq5Du","@azure/core-auth":"nCqHG","./credentials/accessTokenCache":"kw8rI","./credentials/accessTokenRefresher":"31VoW","./credentials/basicAuthenticationCredentials":"gr5Kw","./credentials/apiKeyCredentials":"6yXDi","./credentials/topicCredentials":"bJw5P","./util/xml":"bNo0R","./util/serializer.common":"1KFRt","@azure/core-asynciterator-polyfill":"gVdPP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"77t2g":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isWebResourceLike", ()=>isWebResourceLike);
parcelHelpers.export(exports, "WebResource", ()=>WebResource);
var _httpHeaders = require("./httpHeaders");
var _serializer = require("./serializer");
var _utils = require("./util/utils");
function isWebResourceLike(object) {
    if (object && typeof object === "object") {
        var castObject = object;
        if (typeof castObject.url === "string" && typeof castObject.method === "string" && typeof castObject.headers === "object" && (0, _httpHeaders.isHttpHeadersLike)(castObject.headers) && typeof castObject.validateRequestProperties === "function" && typeof castObject.prepare === "function" && typeof castObject.clone === "function") return true;
    }
    return false;
}
/**
 * Creates a new WebResource object.
 *
 * This class provides an abstraction over a REST call by being library / implementation agnostic and wrapping the necessary
 * properties to initiate a request.
 */ var WebResource = /** @class */ function() {
    function WebResource(url, method, body, query, headers, streamResponseBody, withCredentials, abortSignal, timeout, onUploadProgress, onDownloadProgress, proxySettings, keepAlive, decompressResponse, streamResponseStatusCodes) {
        this.streamResponseBody = streamResponseBody;
        this.streamResponseStatusCodes = streamResponseStatusCodes;
        this.url = url || "";
        this.method = method || "GET";
        this.headers = (0, _httpHeaders.isHttpHeadersLike)(headers) ? headers : new (0, _httpHeaders.HttpHeaders)(headers);
        this.body = body;
        this.query = query;
        this.formData = undefined;
        this.withCredentials = withCredentials || false;
        this.abortSignal = abortSignal;
        this.timeout = timeout || 0;
        this.onUploadProgress = onUploadProgress;
        this.onDownloadProgress = onDownloadProgress;
        this.proxySettings = proxySettings;
        this.keepAlive = keepAlive;
        this.decompressResponse = decompressResponse;
        this.requestId = this.headers.get("x-ms-client-request-id") || (0, _utils.generateUuid)();
    }
    /**
     * Validates that the required properties such as method, url, headers["Content-Type"],
     * headers["accept-language"] are defined. It will throw an error if one of the above
     * mentioned properties are not defined.
     */ WebResource.prototype.validateRequestProperties = function() {
        if (!this.method) throw new Error("WebResource.method is required.");
        if (!this.url) throw new Error("WebResource.url is required.");
    };
    /**
     * Prepares the request.
     * @param options - Options to provide for preparing the request.
     * @returns Returns the prepared WebResource (HTTP Request) object that needs to be given to the request pipeline.
     */ WebResource.prototype.prepare = function(options) {
        if (!options) throw new Error("options object is required");
        if (options.method === undefined || options.method === null || typeof options.method.valueOf() !== "string") throw new Error("options.method must be a string.");
        if (options.url && options.pathTemplate) throw new Error("options.url and options.pathTemplate are mutually exclusive. Please provide exactly one of them.");
        if ((options.pathTemplate === undefined || options.pathTemplate === null || typeof options.pathTemplate.valueOf() !== "string") && (options.url === undefined || options.url === null || typeof options.url.valueOf() !== "string")) throw new Error("Please provide exactly one of options.pathTemplate or options.url.");
        // set the url if it is provided.
        if (options.url) {
            if (typeof options.url !== "string") throw new Error('options.url must be of type "string".');
            this.url = options.url;
        }
        // set the method
        if (options.method) {
            var validMethods = [
                "GET",
                "PUT",
                "HEAD",
                "DELETE",
                "OPTIONS",
                "POST",
                "PATCH",
                "TRACE"
            ];
            if (validMethods.indexOf(options.method.toUpperCase()) === -1) throw new Error('The provided method "' + options.method + '" is invalid. Supported HTTP methods are: ' + JSON.stringify(validMethods));
        }
        this.method = options.method.toUpperCase();
        // construct the url if path template is provided
        if (options.pathTemplate) {
            var pathTemplate_1 = options.pathTemplate, pathParameters_1 = options.pathParameters;
            if (typeof pathTemplate_1 !== "string") throw new Error('options.pathTemplate must be of type "string".');
            if (!options.baseUrl) options.baseUrl = "https://management.azure.com";
            var baseUrl = options.baseUrl;
            var url_1 = baseUrl + (baseUrl.endsWith("/") ? "" : "/") + (pathTemplate_1.startsWith("/") ? pathTemplate_1.slice(1) : pathTemplate_1);
            var segments = url_1.match(/({[\w-]*\s*[\w-]*})/gi);
            if (segments && segments.length) {
                if (!pathParameters_1) throw new Error("pathTemplate: " + pathTemplate_1 + " has been provided. Hence, options.pathParameters must also be provided.");
                segments.forEach(function(item) {
                    var pathParamName = item.slice(1, -1);
                    var pathParam = pathParameters_1[pathParamName];
                    if (pathParam === null || pathParam === undefined || !(typeof pathParam === "string" || typeof pathParam === "object")) {
                        var stringifiedPathParameters = JSON.stringify(pathParameters_1, undefined, 2);
                        throw new Error("pathTemplate: " + pathTemplate_1 + " contains the path parameter " + pathParamName + (" however, it is not present in parameters: " + stringifiedPathParameters + ".") + ("The value of the path parameter can either be a \"string\" of the form { " + pathParamName + ": \"some sample value\" } or ") + ("it can be an \"object\" of the form { \"" + pathParamName + "\": { value: \"some sample value\", skipUrlEncoding: true } }."));
                    }
                    if (typeof pathParam.valueOf() === "string") url_1 = url_1.replace(item, encodeURIComponent(pathParam));
                    if (typeof pathParam.valueOf() === "object") {
                        if (!pathParam.value) throw new Error("options.pathParameters[" + pathParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
                        if (pathParam.skipUrlEncoding) url_1 = url_1.replace(item, pathParam.value);
                        else url_1 = url_1.replace(item, encodeURIComponent(pathParam.value));
                    }
                });
            }
            this.url = url_1;
        }
        // append query parameters to the url if they are provided. They can be provided with pathTemplate or url option.
        if (options.queryParameters) {
            var queryParameters = options.queryParameters;
            if (typeof queryParameters !== "object") throw new Error('options.queryParameters must be of type object. It should be a JSON object of "query-parameter-name" as the key and the "query-parameter-value" as the value. The "query-parameter-value" may be fo type "string" or an "object" of the form { value: "query-parameter-value", skipUrlEncoding: true }.');
            // append question mark if it is not present in the url
            if (this.url && this.url.indexOf("?") === -1) this.url += "?";
            // construct queryString
            var queryParams = [];
            // We need to populate this.query as a dictionary if the request is being used for Sway's validateRequest().
            this.query = {};
            for(var queryParamName in queryParameters){
                var queryParam = queryParameters[queryParamName];
                if (queryParam) {
                    if (typeof queryParam === "string") {
                        queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam));
                        this.query[queryParamName] = encodeURIComponent(queryParam);
                    } else if (typeof queryParam === "object") {
                        if (!queryParam.value) throw new Error("options.queryParameters[" + queryParamName + "] is of type \"object\" but it does not contain a \"value\" property.");
                        if (queryParam.skipUrlEncoding) {
                            queryParams.push(queryParamName + "=" + queryParam.value);
                            this.query[queryParamName] = queryParam.value;
                        } else {
                            queryParams.push(queryParamName + "=" + encodeURIComponent(queryParam.value));
                            this.query[queryParamName] = encodeURIComponent(queryParam.value);
                        }
                    }
                }
            } // end-of-for
            // append the queryString
            this.url += queryParams.join("&");
        }
        // add headers to the request if they are provided
        if (options.headers) {
            var headers = options.headers;
            for(var _i = 0, _a = Object.keys(options.headers); _i < _a.length; _i++){
                var headerName = _a[_i];
                this.headers.set(headerName, headers[headerName]);
            }
        }
        // ensure accept-language is set correctly
        if (!this.headers.get("accept-language")) this.headers.set("accept-language", "en-US");
        // ensure the request-id is set correctly
        if (!this.headers.get("x-ms-client-request-id") && !options.disableClientRequestId) this.headers.set("x-ms-client-request-id", this.requestId);
        // default
        if (!this.headers.get("Content-Type")) this.headers.set("Content-Type", "application/json; charset=utf-8");
        // set the request body. request.js automatically sets the Content-Length request header, so we need not set it explicitly
        this.body = options.body;
        if (options.body !== undefined && options.body !== null) {
            // body as a stream special case. set the body as-is and check for some special request headers specific to sending a stream.
            if (options.bodyIsStream) {
                if (!this.headers.get("Transfer-Encoding")) this.headers.set("Transfer-Encoding", "chunked");
                if (this.headers.get("Content-Type") !== "application/octet-stream") this.headers.set("Content-Type", "application/octet-stream");
            } else {
                if (options.serializationMapper) this.body = new (0, _serializer.Serializer)(options.mappers).serialize(options.serializationMapper, options.body, "requestBody");
                if (!options.disableJsonStringifyOnBody) this.body = JSON.stringify(options.body);
            }
        }
        if (options.spanOptions) this.spanOptions = options.spanOptions;
        if (options.tracingContext) this.tracingContext = options.tracingContext;
        this.abortSignal = options.abortSignal;
        this.onDownloadProgress = options.onDownloadProgress;
        this.onUploadProgress = options.onUploadProgress;
        return this;
    };
    /**
     * Clone this WebResource HTTP request object.
     * @returns The clone of this WebResource HTTP request object.
     */ WebResource.prototype.clone = function() {
        var result = new WebResource(this.url, this.method, this.body, this.query, this.headers && this.headers.clone(), this.streamResponseBody, this.withCredentials, this.abortSignal, this.timeout, this.onUploadProgress, this.onDownloadProgress, this.proxySettings, this.keepAlive, this.decompressResponse, this.streamResponseStatusCodes);
        if (this.formData) result.formData = this.formData;
        if (this.operationSpec) result.operationSpec = this.operationSpec;
        if (this.shouldDeserialize) result.shouldDeserialize = this.shouldDeserialize;
        if (this.operationResponseGetter) result.operationResponseGetter = this.operationResponseGetter;
        return result;
    };
    return WebResource;
}();

},{"./httpHeaders":"dFs7b","./serializer":"4pdUf","./util/utils":"3ok7s","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dFs7b":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A collection of HttpHeaders that can be sent with a HTTP request.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isHttpHeadersLike", ()=>isHttpHeadersLike);
parcelHelpers.export(exports, "HttpHeaders", ()=>HttpHeaders);
function getHeaderKey(headerName) {
    return headerName.toLowerCase();
}
function isHttpHeadersLike(object) {
    if (object && typeof object === "object") {
        var castObject = object;
        if (typeof castObject.rawHeaders === "function" && typeof castObject.clone === "function" && typeof castObject.get === "function" && typeof castObject.set === "function" && typeof castObject.contains === "function" && typeof castObject.remove === "function" && typeof castObject.headersArray === "function" && typeof castObject.headerValues === "function" && typeof castObject.headerNames === "function" && typeof castObject.toJson === "function") return true;
    }
    return false;
}
/**
 * A collection of HTTP header key/value pairs.
 */ var HttpHeaders = /** @class */ function() {
    function HttpHeaders(rawHeaders) {
        this._headersMap = {};
        if (rawHeaders) for(var headerName in rawHeaders)this.set(headerName, rawHeaders[headerName]);
    }
    /**
     * Set a header in this collection with the provided name and value. The name is
     * case-insensitive.
     * @param headerName - The name of the header to set. This value is case-insensitive.
     * @param headerValue - The value of the header to set.
     */ HttpHeaders.prototype.set = function(headerName, headerValue) {
        this._headersMap[getHeaderKey(headerName)] = {
            name: headerName,
            value: headerValue.toString()
        };
    };
    /**
     * Get the header value for the provided header name, or undefined if no header exists in this
     * collection with the provided name.
     * @param headerName - The name of the header.
     */ HttpHeaders.prototype.get = function(headerName) {
        var header = this._headersMap[getHeaderKey(headerName)];
        return !header ? undefined : header.value;
    };
    /**
     * Get whether or not this header collection contains a header entry for the provided header name.
     */ HttpHeaders.prototype.contains = function(headerName) {
        return !!this._headersMap[getHeaderKey(headerName)];
    };
    /**
     * Remove the header with the provided headerName. Return whether or not the header existed and
     * was removed.
     * @param headerName - The name of the header to remove.
     */ HttpHeaders.prototype.remove = function(headerName) {
        var result = this.contains(headerName);
        delete this._headersMap[getHeaderKey(headerName)];
        return result;
    };
    /**
     * Get the headers that are contained this collection as an object.
     */ HttpHeaders.prototype.rawHeaders = function() {
        var result = {};
        for(var headerKey in this._headersMap){
            var header = this._headersMap[headerKey];
            result[header.name.toLowerCase()] = header.value;
        }
        return result;
    };
    /**
     * Get the headers that are contained in this collection as an array.
     */ HttpHeaders.prototype.headersArray = function() {
        var headers = [];
        for(var headerKey in this._headersMap)headers.push(this._headersMap[headerKey]);
        return headers;
    };
    /**
     * Get the header names that are contained in this collection.
     */ HttpHeaders.prototype.headerNames = function() {
        var headerNames = [];
        var headers = this.headersArray();
        for(var i = 0; i < headers.length; ++i)headerNames.push(headers[i].name);
        return headerNames;
    };
    /**
     * Get the header values that are contained in this collection.
     */ HttpHeaders.prototype.headerValues = function() {
        var headerValues = [];
        var headers = this.headersArray();
        for(var i = 0; i < headers.length; ++i)headerValues.push(headers[i].value);
        return headerValues;
    };
    /**
     * Get the JSON object representation of this HTTP header collection.
     */ HttpHeaders.prototype.toJson = function() {
        return this.rawHeaders();
    };
    /**
     * Get the string representation of this HTTP header collection.
     */ HttpHeaders.prototype.toString = function() {
        return JSON.stringify(this.toJson());
    };
    /**
     * Create a deep clone/copy of this HttpHeaders collection.
     */ HttpHeaders.prototype.clone = function() {
        return new HttpHeaders(this.rawHeaders());
    };
    return HttpHeaders;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4pdUf":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable eqeqeq */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Serializer", ()=>Serializer);
// TODO: why is this here?
parcelHelpers.export(exports, "serializeObject", ()=>serializeObject);
parcelHelpers.export(exports, "MapperType", ()=>MapperType);
var _tslib = require("tslib");
var _base64 = require("./util/base64");
var _utils = require("./util/utils");
var _serializerCommon = require("./util/serializer.common");
var Serializer = /** @class */ function() {
    function Serializer(modelMappers, isXML) {
        if (modelMappers === void 0) modelMappers = {};
        this.modelMappers = modelMappers;
        this.isXML = isXML;
    }
    Serializer.prototype.validateConstraints = function(mapper, value, objectName) {
        var failValidation = function(constraintName, constraintValue) {
            throw new Error("\"" + objectName + "\" with value \"" + value + "\" should satisfy the constraint \"" + constraintName + "\": " + constraintValue + ".");
        };
        if (mapper.constraints && value != undefined) {
            var valueAsNumber = value;
            var _a = mapper.constraints, ExclusiveMaximum = _a.ExclusiveMaximum, ExclusiveMinimum = _a.ExclusiveMinimum, InclusiveMaximum = _a.InclusiveMaximum, InclusiveMinimum = _a.InclusiveMinimum, MaxItems = _a.MaxItems, MaxLength = _a.MaxLength, MinItems = _a.MinItems, MinLength = _a.MinLength, MultipleOf = _a.MultipleOf, Pattern = _a.Pattern, UniqueItems = _a.UniqueItems;
            if (ExclusiveMaximum != undefined && valueAsNumber >= ExclusiveMaximum) failValidation("ExclusiveMaximum", ExclusiveMaximum);
            if (ExclusiveMinimum != undefined && valueAsNumber <= ExclusiveMinimum) failValidation("ExclusiveMinimum", ExclusiveMinimum);
            if (InclusiveMaximum != undefined && valueAsNumber > InclusiveMaximum) failValidation("InclusiveMaximum", InclusiveMaximum);
            if (InclusiveMinimum != undefined && valueAsNumber < InclusiveMinimum) failValidation("InclusiveMinimum", InclusiveMinimum);
            var valueAsArray = value;
            if (MaxItems != undefined && valueAsArray.length > MaxItems) failValidation("MaxItems", MaxItems);
            if (MaxLength != undefined && valueAsArray.length > MaxLength) failValidation("MaxLength", MaxLength);
            if (MinItems != undefined && valueAsArray.length < MinItems) failValidation("MinItems", MinItems);
            if (MinLength != undefined && valueAsArray.length < MinLength) failValidation("MinLength", MinLength);
            if (MultipleOf != undefined && valueAsNumber % MultipleOf !== 0) failValidation("MultipleOf", MultipleOf);
            if (Pattern) {
                var pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
                if (typeof value !== "string" || value.match(pattern) === null) failValidation("Pattern", Pattern);
            }
            if (UniqueItems && valueAsArray.some(function(item, i, ar) {
                return ar.indexOf(item) !== i;
            })) failValidation("UniqueItems", UniqueItems);
        }
    };
    /**
     * Serialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     * @param object - A valid Javascript object to be serialized
     * @param objectName - Name of the serialized object
     * @param options - additional options to deserialization
     * @returns A valid serialized Javascript object
     */ Serializer.prototype.serialize = function(mapper, object, objectName, options) {
        var _a, _b, _c;
        if (options === void 0) options = {};
        var updatedOptions = {
            rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
            includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : (0, _serializerCommon.XML_CHARKEY)
        };
        var payload = {};
        var mapperType = mapper.type.name;
        if (!objectName) objectName = mapper.serializedName;
        if (mapperType.match(/^Sequence$/i) !== null) payload = [];
        if (mapper.isConstant) object = mapper.defaultValue;
        // This table of allowed values should help explain
        // the mapper.required and mapper.nullable properties.
        // X means "neither undefined or null are allowed".
        //           || required
        //           || true      | false
        //  nullable || ==========================
        //      true || null      | undefined/null
        //     false || X         | undefined
        // undefined || X         | undefined/null
        var required = mapper.required, nullable = mapper.nullable;
        if (required && nullable && object === undefined) throw new Error(objectName + " cannot be undefined.");
        if (required && !nullable && object == undefined) throw new Error(objectName + " cannot be null or undefined.");
        if (!required && nullable === false && object === null) throw new Error(objectName + " cannot be null.");
        if (object == undefined) payload = object;
        else {
            // Validate Constraints if any
            this.validateConstraints(mapper, object, objectName);
            if (mapperType.match(/^any$/i) !== null) payload = object;
            else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) payload = serializeBasicTypes(mapperType, objectName, object);
            else if (mapperType.match(/^Enum$/i) !== null) {
                var enumMapper = mapper;
                payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
            } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) payload = serializeDateTypes(mapperType, object, objectName);
            else if (mapperType.match(/^ByteArray$/i) !== null) payload = serializeByteArrayType(objectName, object);
            else if (mapperType.match(/^Base64Url$/i) !== null) payload = serializeBase64UrlType(objectName, object);
            else if (mapperType.match(/^Sequence$/i) !== null) payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            else if (mapperType.match(/^Dictionary$/i) !== null) payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
            else if (mapperType.match(/^Composite$/i) !== null) payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
        }
        return payload;
    };
    /**
     * Deserialize the given object based on its metadata defined in the mapper
     *
     * @param mapper - The mapper which defines the metadata of the serializable object
     * @param responseBody - A valid Javascript entity to be deserialized
     * @param objectName - Name of the deserialized object
     * @param options - Controls behavior of XML parser and builder.
     * @returns A valid deserialized Javascript object
     */ Serializer.prototype.deserialize = function(mapper, responseBody, objectName, options) {
        var _a, _b, _c;
        if (options === void 0) options = {};
        var updatedOptions = {
            rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
            includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : (0, _serializerCommon.XML_CHARKEY)
        };
        if (responseBody == undefined) {
            if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) // Edge case for empty XML non-wrapped lists. xml2js can't distinguish
            // between the list being empty versus being missing,
            // so let's do the more user-friendly thing and return an empty list.
            responseBody = [];
            // specifically check for undefined as default value can be a falsey value `0, "", false, null`
            if (mapper.defaultValue !== undefined) responseBody = mapper.defaultValue;
            return responseBody;
        }
        var payload;
        var mapperType = mapper.type.name;
        if (!objectName) objectName = mapper.serializedName;
        if (mapperType.match(/^Composite$/i) !== null) payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
        else {
            if (this.isXML) {
                var xmlCharKey = updatedOptions.xmlCharKey;
                var castResponseBody = responseBody;
                /**
                 * If the mapper specifies this as a non-composite type value but the responseBody contains
                 * both header ("$" i.e., XML_ATTRKEY) and body ("#" i.e., XML_CHARKEY) properties,
                 * then just reduce the responseBody value to the body ("#" i.e., XML_CHARKEY) property.
                 */ if (castResponseBody[0, _serializerCommon.XML_ATTRKEY] != undefined && castResponseBody[xmlCharKey] != undefined) responseBody = castResponseBody[xmlCharKey];
            }
            if (mapperType.match(/^Number$/i) !== null) {
                payload = parseFloat(responseBody);
                if (isNaN(payload)) payload = responseBody;
            } else if (mapperType.match(/^Boolean$/i) !== null) {
                if (responseBody === "true") payload = true;
                else if (responseBody === "false") payload = false;
                else payload = responseBody;
            } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) payload = responseBody;
            else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) payload = new Date(responseBody);
            else if (mapperType.match(/^UnixTime$/i) !== null) payload = unixTimeToDate(responseBody);
            else if (mapperType.match(/^ByteArray$/i) !== null) payload = _base64.decodeString(responseBody);
            else if (mapperType.match(/^Base64Url$/i) !== null) payload = base64UrlToByteArray(responseBody);
            else if (mapperType.match(/^Sequence$/i) !== null) payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
            else if (mapperType.match(/^Dictionary$/i) !== null) payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
        }
        if (mapper.isConstant) payload = mapper.defaultValue;
        return payload;
    };
    return Serializer;
}();
function trimEnd(str, ch) {
    var len = str.length;
    while(len - 1 >= 0 && str[len - 1] === ch)--len;
    return str.substr(0, len);
}
function bufferToBase64Url(buffer) {
    if (!buffer) return undefined;
    if (!(buffer instanceof Uint8Array)) throw new Error("Please provide an input of type Uint8Array for converting to Base64Url.");
    // Uint8Array to Base64.
    var str = _base64.encodeByteArray(buffer);
    // Base64 to Base64Url.
    return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray(str) {
    if (!str) return undefined;
    if (str && typeof str.valueOf() !== "string") throw new Error("Please provide an input of type string for converting to Uint8Array");
    // Base64Url to Base64.
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    // Base64 to Uint8Array.
    return _base64.decodeString(str);
}
function splitSerializeName(prop) {
    var classes = [];
    var partialclass = "";
    if (prop) {
        var subwords = prop.split(".");
        for(var _i = 0, subwords_1 = subwords; _i < subwords_1.length; _i++){
            var item = subwords_1[_i];
            if (item.charAt(item.length - 1) === "\\") partialclass += item.substr(0, item.length - 1) + ".";
            else {
                partialclass += item;
                classes.push(partialclass);
                partialclass = "";
            }
        }
    }
    return classes;
}
function dateToUnixTime(d) {
    if (!d) return undefined;
    if (typeof d.valueOf() === "string") d = new Date(d);
    return Math.floor(d.getTime() / 1000);
}
function unixTimeToDate(n) {
    if (!n) return undefined;
    return new Date(n * 1000);
}
function serializeBasicTypes(typeName, objectName, value) {
    if (value !== null && value !== undefined) {
        if (typeName.match(/^Number$/i) !== null) {
            if (typeof value !== "number") throw new Error(objectName + " with value " + value + " must be of type number.");
        } else if (typeName.match(/^String$/i) !== null) {
            if (typeof value.valueOf() !== "string") throw new Error(objectName + " with value \"" + value + "\" must be of type string.");
        } else if (typeName.match(/^Uuid$/i) !== null) {
            if (!(typeof value.valueOf() === "string" && _utils.isValidUuid(value))) throw new Error(objectName + " with value \"" + value + "\" must be of type string and a valid uuid.");
        } else if (typeName.match(/^Boolean$/i) !== null) {
            if (typeof value !== "boolean") throw new Error(objectName + " with value " + value + " must be of type boolean.");
        } else if (typeName.match(/^Stream$/i) !== null) {
            var objectType = typeof value;
            if (objectType !== "string" && objectType !== "function" && !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob)) throw new Error(objectName + " must be a string, Blob, ArrayBuffer, ArrayBufferView, or a function returning NodeJS.ReadableStream.");
        }
    }
    return value;
}
function serializeEnumType(objectName, allowedValues, value) {
    if (!allowedValues) throw new Error("Please provide a set of allowedValues to validate " + objectName + " as an Enum Type.");
    var isPresent = allowedValues.some(function(item) {
        if (typeof item.valueOf() === "string") return item.toLowerCase() === value.toLowerCase();
        return item === value;
    });
    if (!isPresent) throw new Error(value + " is not a valid value for " + objectName + ". The valid values are: " + JSON.stringify(allowedValues) + ".");
    return value;
}
function serializeByteArrayType(objectName, value) {
    var returnValue = "";
    if (value != undefined) {
        if (!(value instanceof Uint8Array)) throw new Error(objectName + " must be of type Uint8Array.");
        returnValue = _base64.encodeByteArray(value);
    }
    return returnValue;
}
function serializeBase64UrlType(objectName, value) {
    var returnValue = "";
    if (value != undefined) {
        if (!(value instanceof Uint8Array)) throw new Error(objectName + " must be of type Uint8Array.");
        returnValue = bufferToBase64Url(value) || "";
    }
    return returnValue;
}
function serializeDateTypes(typeName, value, objectName) {
    if (value != undefined) {
        if (typeName.match(/^Date$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
            value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
        } else if (typeName.match(/^DateTime$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in ISO8601 format.");
            value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
        } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123 format.");
            value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
        } else if (typeName.match(/^UnixTime$/i) !== null) {
            if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) throw new Error(objectName + " must be an instanceof Date or a string in RFC-1123/ISO8601 format " + "for it to be serialized in UnixTime/Epoch format.");
            value = dateToUnixTime(value);
        } else if (typeName.match(/^TimeSpan$/i) !== null) {
            if (!_utils.isDuration(value)) throw new Error(objectName + " must be a string in ISO 8601 format. Instead was \"" + value + "\".");
        }
    }
    return value;
}
function serializeSequenceType(serializer, mapper, object, objectName, isXml, options) {
    var _a, _b;
    if (!Array.isArray(object)) throw new Error(objectName + " must be of type Array.");
    var elementType = mapper.type.element;
    if (!elementType || typeof elementType !== "object") throw new Error("element\" metadata for an Array must be defined in the " + ("mapper and it must of type \"object\" in " + objectName + "."));
    var tempArray = [];
    for(var i = 0; i < object.length; i++){
        var serializedValue = serializer.serialize(elementType, object[i], objectName, options);
        if (isXml && elementType.xmlNamespace) {
            var xmlnsKey = elementType.xmlNamespacePrefix ? "xmlns:" + elementType.xmlNamespacePrefix : "xmlns";
            if (elementType.type.name === "Composite") {
                tempArray[i] = (0, _tslib.__assign)({}, serializedValue);
                tempArray[i][0, _serializerCommon.XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = elementType.xmlNamespace, _a);
            } else {
                tempArray[i] = {};
                tempArray[i][options.xmlCharKey] = serializedValue;
                tempArray[i][0, _serializerCommon.XML_ATTRKEY] = (_b = {}, _b[xmlnsKey] = elementType.xmlNamespace, _b);
            }
        } else tempArray[i] = serializedValue;
    }
    return tempArray;
}
function serializeDictionaryType(serializer, mapper, object, objectName, isXml, options) {
    var _a;
    if (typeof object !== "object") throw new Error(objectName + " must be of type object.");
    var valueType = mapper.type.value;
    if (!valueType || typeof valueType !== "object") throw new Error("\"value\" metadata for a Dictionary must be defined in the " + ("mapper and it must of type \"object\" in " + objectName + "."));
    var tempDictionary = {};
    for(var _i = 0, _b = Object.keys(object); _i < _b.length; _i++){
        var key = _b[_i];
        var serializedValue = serializer.serialize(valueType, object[key], objectName, options);
        // If the element needs an XML namespace we need to add it within the $ property
        tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
    }
    // Add the namespace to the root element if needed
    if (isXml && mapper.xmlNamespace) {
        var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns";
        var result = tempDictionary;
        result[0, _serializerCommon.XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a);
        return result;
    }
    return tempDictionary;
}
/**
 * Resolves the additionalProperties property from a referenced mapper
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 * @param objectName - Name of the object being serialized
 */ function resolveAdditionalProperties(serializer, mapper, objectName) {
    var additionalProperties = mapper.type.additionalProperties;
    if (!additionalProperties && mapper.type.className) {
        var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
    }
    return additionalProperties;
}
/**
 * Finds the mapper referenced by className
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 * @param objectName - Name of the object being serialized
 */ function resolveReferencedMapper(serializer, mapper, objectName) {
    var className = mapper.type.className;
    if (!className) throw new Error("Class name for model \"" + objectName + "\" is not provided in the mapper \"" + JSON.stringify(mapper, undefined, 2) + "\".");
    return serializer.modelMappers[className];
}
/**
 * Resolves a composite mapper's modelProperties.
 * @param serializer - The serializer containing the entire set of mappers
 * @param mapper - The composite mapper to resolve
 */ function resolveModelProperties(serializer, mapper, objectName) {
    var modelProps = mapper.type.modelProperties;
    if (!modelProps) {
        var modelMapper = resolveReferencedMapper(serializer, mapper, objectName);
        if (!modelMapper) throw new Error("mapper() cannot be null or undefined for model \"" + mapper.type.className + "\".");
        modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
        if (!modelProps) throw new Error("modelProperties cannot be null or undefined in the " + ("mapper \"" + JSON.stringify(modelMapper) + "\" of type \"" + mapper.type.className + "\" for object \"" + objectName + "\"."));
    }
    return modelProps;
}
function serializeCompositeType(serializer, mapper, object, objectName, isXml, options) {
    var _a, _b;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, object, "clientName");
    if (object != undefined) {
        var payload = {};
        var modelProps = resolveModelProperties(serializer, mapper, objectName);
        for(var _i = 0, _c = Object.keys(modelProps); _i < _c.length; _i++){
            var key = _c[_i];
            var propertyMapper = modelProps[key];
            if (propertyMapper.readOnly) continue;
            var propName = void 0;
            var parentObject = payload;
            if (serializer.isXML) {
                if (propertyMapper.xmlIsWrapped) propName = propertyMapper.xmlName;
                else propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
            } else {
                var paths = splitSerializeName(propertyMapper.serializedName);
                propName = paths.pop();
                for(var _d = 0, paths_1 = paths; _d < paths_1.length; _d++){
                    var pathName = paths_1[_d];
                    var childObject = parentObject[pathName];
                    if (childObject == undefined && (object[key] != undefined || propertyMapper.defaultValue !== undefined)) parentObject[pathName] = {};
                    parentObject = parentObject[pathName];
                }
            }
            if (parentObject != undefined) {
                if (isXml && mapper.xmlNamespace) {
                    var xmlnsKey = mapper.xmlNamespacePrefix ? "xmlns:" + mapper.xmlNamespacePrefix : "xmlns";
                    parentObject[0, _serializerCommon.XML_ATTRKEY] = (0, _tslib.__assign)((0, _tslib.__assign)({}, parentObject[0, _serializerCommon.XML_ATTRKEY]), (_a = {}, _a[xmlnsKey] = mapper.xmlNamespace, _a));
                }
                var propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
                var toSerialize = object[key];
                var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
                if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && toSerialize == undefined) toSerialize = mapper.serializedName;
                var serializedValue = serializer.serialize(propertyMapper, toSerialize, propertyObjectName, options);
                if (serializedValue !== undefined && propName != undefined) {
                    var value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
                    if (isXml && propertyMapper.xmlIsAttribute) {
                        // XML_ATTRKEY, i.e., $ is the key attributes are kept under in xml2js.
                        // This keeps things simple while preventing name collision
                        // with names in user documents.
                        parentObject[0, _serializerCommon.XML_ATTRKEY] = parentObject[0, _serializerCommon.XML_ATTRKEY] || {};
                        parentObject[0, _serializerCommon.XML_ATTRKEY][propName] = serializedValue;
                    } else if (isXml && propertyMapper.xmlIsWrapped) parentObject[propName] = (_b = {}, _b[propertyMapper.xmlElementName] = value, _b);
                    else parentObject[propName] = value;
                }
            }
        }
        var additionalPropertiesMapper = resolveAdditionalProperties(serializer, mapper, objectName);
        if (additionalPropertiesMapper) {
            var propNames = Object.keys(modelProps);
            var _loop_1 = function(clientPropName) {
                var isAdditionalProperty = propNames.every(function(pn) {
                    return pn !== clientPropName;
                });
                if (isAdditionalProperty) payload[clientPropName] = serializer.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
            };
            for(var clientPropName in object)_loop_1(clientPropName);
        }
        return payload;
    }
    return object;
}
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
    var _a;
    if (!isXml || !propertyMapper.xmlNamespace) return serializedValue;
    var xmlnsKey = propertyMapper.xmlNamespacePrefix ? "xmlns:" + propertyMapper.xmlNamespacePrefix : "xmlns";
    var xmlNamespace = (_a = {}, _a[xmlnsKey] = propertyMapper.xmlNamespace, _a);
    if ([
        "Composite"
    ].includes(propertyMapper.type.name)) {
        if (serializedValue[0, _serializerCommon.XML_ATTRKEY]) return serializedValue;
        else {
            var result_1 = (0, _tslib.__assign)({}, serializedValue);
            result_1[0, _serializerCommon.XML_ATTRKEY] = xmlNamespace;
            return result_1;
        }
    }
    var result = {};
    result[options.xmlCharKey] = serializedValue;
    result[0, _serializerCommon.XML_ATTRKEY] = xmlNamespace;
    return result;
}
function isSpecialXmlProperty(propertyName, options) {
    return [
        (0, _serializerCommon.XML_ATTRKEY),
        options.xmlCharKey
    ].includes(propertyName);
}
function deserializeCompositeType(serializer, mapper, responseBody, objectName, options) {
    var _a;
    if (getPolymorphicDiscriminatorRecursively(serializer, mapper)) mapper = getPolymorphicMapper(serializer, mapper, responseBody, "serializedName");
    var modelProps = resolveModelProperties(serializer, mapper, objectName);
    var instance = {};
    var handledPropertyNames = [];
    for(var _i = 0, _b = Object.keys(modelProps); _i < _b.length; _i++){
        var key = _b[_i];
        var propertyMapper = modelProps[key];
        var paths = splitSerializeName(modelProps[key].serializedName);
        handledPropertyNames.push(paths[0]);
        var serializedName = propertyMapper.serializedName, xmlName = propertyMapper.xmlName, xmlElementName = propertyMapper.xmlElementName;
        var propertyObjectName = objectName;
        if (serializedName !== "" && serializedName !== undefined) propertyObjectName = objectName + "." + serializedName;
        var headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
            var dictionary = {};
            for(var _c = 0, _d = Object.keys(responseBody); _c < _d.length; _c++){
                var headerKey = _d[_c];
                if (headerKey.startsWith(headerCollectionPrefix)) dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
                handledPropertyNames.push(headerKey);
            }
            instance[key] = dictionary;
        } else if (serializer.isXML) {
            if (propertyMapper.xmlIsAttribute && responseBody[0, _serializerCommon.XML_ATTRKEY]) instance[key] = serializer.deserialize(propertyMapper, responseBody[0, _serializerCommon.XML_ATTRKEY][xmlName], propertyObjectName, options);
            else {
                var propertyName = xmlElementName || xmlName || serializedName;
                if (propertyMapper.xmlIsWrapped) {
                    /* a list of <xmlElementName> wrapped by <xmlName>
                      For the xml example below
                        <Cors>
                          <CorsRule>...</CorsRule>
                          <CorsRule>...</CorsRule>
                        </Cors>
                      the responseBody has
                        {
                          Cors: {
                            CorsRule: [{...}, {...}]
                          }
                        }
                      xmlName is "Cors" and xmlElementName is"CorsRule".
                    */ var wrapped = responseBody[xmlName];
                    var elementList = (_a = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _a !== void 0 ? _a : [];
                    instance[key] = serializer.deserialize(propertyMapper, elementList, propertyObjectName, options);
                } else {
                    var property = responseBody[propertyName];
                    instance[key] = serializer.deserialize(propertyMapper, property, propertyObjectName, options);
                }
            }
        } else {
            // deserialize the property if it is present in the provided responseBody instance
            var propertyInstance = void 0;
            var res = responseBody;
            // traversing the object step by step.
            for(var _e = 0, paths_2 = paths; _e < paths_2.length; _e++){
                var item = paths_2[_e];
                if (!res) break;
                res = res[item];
            }
            propertyInstance = res;
            var polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
            // checking that the model property name (key)(ex: "fishtype") and the
            // clientName of the polymorphicDiscriminator {metadata} (ex: "fishtype")
            // instead of the serializedName of the polymorphicDiscriminator (ex: "fish.type")
            // is a better approach. The generator is not consistent with escaping '\.' in the
            // serializedName of the property (ex: "fish\.type") that is marked as polymorphic discriminator
            // and the serializedName of the metadata polymorphicDiscriminator (ex: "fish.type"). However,
            // the clientName transformation of the polymorphicDiscriminator (ex: "fishtype") and
            // the transformation of model property name (ex: "fishtype") is done consistently.
            // Hence, it is a safer bet to rely on the clientName of the polymorphicDiscriminator.
            if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && propertyInstance == undefined) propertyInstance = mapper.serializedName;
            var serializedValue = void 0;
            // paging
            if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
                propertyInstance = responseBody[key];
                instance = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
            } else if (propertyInstance !== undefined || propertyMapper.defaultValue !== undefined) {
                serializedValue = serializer.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
                instance[key] = serializedValue;
            }
        }
    }
    var additionalPropertiesMapper = mapper.type.additionalProperties;
    if (additionalPropertiesMapper) {
        var isAdditionalProperty = function(responsePropName) {
            for(var clientPropName in modelProps){
                var paths = splitSerializeName(modelProps[clientPropName].serializedName);
                if (paths[0] === responsePropName) return false;
            }
            return true;
        };
        for(var responsePropName in responseBody)if (isAdditionalProperty(responsePropName)) instance[responsePropName] = serializer.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
    } else if (responseBody) for(var _f = 0, _g = Object.keys(responseBody); _f < _g.length; _f++){
        var key = _g[_f];
        if (instance[key] === undefined && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) instance[key] = responseBody[key];
    }
    return instance;
}
function deserializeDictionaryType(serializer, mapper, responseBody, objectName, options) {
    var value = mapper.type.value;
    if (!value || typeof value !== "object") throw new Error("\"value\" metadata for a Dictionary must be defined in the " + ("mapper and it must of type \"object\" in " + objectName));
    if (responseBody) {
        var tempDictionary = {};
        for(var _i = 0, _a = Object.keys(responseBody); _i < _a.length; _i++){
            var key = _a[_i];
            tempDictionary[key] = serializer.deserialize(value, responseBody[key], objectName, options);
        }
        return tempDictionary;
    }
    return responseBody;
}
function deserializeSequenceType(serializer, mapper, responseBody, objectName, options) {
    var element = mapper.type.element;
    if (!element || typeof element !== "object") throw new Error("element\" metadata for an Array must be defined in the " + ("mapper and it must of type \"object\" in " + objectName));
    if (responseBody) {
        if (!Array.isArray(responseBody)) // xml2js will interpret a single element array as just the element, so force it to be an array
        responseBody = [
            responseBody
        ];
        var tempArray = [];
        for(var i = 0; i < responseBody.length; i++)tempArray[i] = serializer.deserialize(element, responseBody[i], objectName + "[" + i + "]", options);
        return tempArray;
    }
    return responseBody;
}
function getPolymorphicMapper(serializer, mapper, object, polymorphicPropertyName) {
    var polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer, mapper);
    if (polymorphicDiscriminator) {
        var discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
        if (discriminatorName != undefined) {
            var discriminatorValue = object[discriminatorName];
            if (discriminatorValue != undefined) {
                var typeName = mapper.type.uberParent || mapper.type.className;
                var indexDiscriminator = discriminatorValue === typeName ? discriminatorValue : typeName + "." + discriminatorValue;
                var polymorphicMapper = serializer.modelMappers.discriminators[indexDiscriminator];
                if (polymorphicMapper) mapper = polymorphicMapper;
            }
        }
    }
    return mapper;
}
function getPolymorphicDiscriminatorRecursively(serializer, mapper) {
    return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer, mapper.type.className);
}
function getPolymorphicDiscriminatorSafely(serializer, typeName) {
    return typeName && serializer.modelMappers[typeName] && serializer.modelMappers[typeName].type.polymorphicDiscriminator;
}
function serializeObject(toSerialize) {
    var castToSerialize = toSerialize;
    if (toSerialize == undefined) return undefined;
    if (toSerialize instanceof Uint8Array) {
        toSerialize = _base64.encodeByteArray(toSerialize);
        return toSerialize;
    } else if (toSerialize instanceof Date) return toSerialize.toISOString();
    else if (Array.isArray(toSerialize)) {
        var array = [];
        for(var i = 0; i < toSerialize.length; i++)array.push(serializeObject(toSerialize[i]));
        return array;
    } else if (typeof toSerialize === "object") {
        var dictionary = {};
        for(var property in toSerialize)dictionary[property] = serializeObject(castToSerialize[property]);
        return dictionary;
    }
    return toSerialize;
}
/**
 * Utility function to create a K:V from a list of strings
 */ function strEnum(o) {
    var result = {};
    for(var _i = 0, o_1 = o; _i < o_1.length; _i++){
        var key = o_1[_i];
        result[key] = key;
    }
    return result;
}
var MapperType = strEnum([
    "Base64Url",
    "Boolean",
    "ByteArray",
    "Composite",
    "Date",
    "DateTime",
    "DateTimeRfc1123",
    "Dictionary",
    "Enum",
    "Number",
    "Object",
    "Sequence",
    "String",
    "Stream",
    "TimeSpan",
    "UnixTime"
]);

},{"tslib":"iC1Dx","./util/base64":"4KQ12","./util/utils":"3ok7s","./util/serializer.common":"1KFRt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4KQ12":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Encodes a string in base64 format.
 * @param value - The string to encode
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeString", ()=>encodeString);
/**
 * Encodes a byte array in base64 format.
 * @param value - The Uint8Aray to encode
 */ parcelHelpers.export(exports, "encodeByteArray", ()=>encodeByteArray);
/**
 * Decodes a base64 string into a byte array.
 * @param value - The base64 string to decode
 */ parcelHelpers.export(exports, "decodeString", ()=>decodeString);
function encodeString(value) {
    return btoa(value);
}
function encodeByteArray(value) {
    var str = "";
    for(var i = 0; i < value.length; i++)str += String.fromCharCode(value[i]);
    return btoa(str);
}
function decodeString(value) {
    var byteString = atob(value);
    var arr = new Uint8Array(byteString.length);
    for(var i = 0; i < byteString.length; i++)arr[i] = byteString.charCodeAt(i);
    return arr;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3ok7s":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNode", ()=>isNode);
/**
 * Checks if a parsed URL is HTTPS
 *
 * @param urlToCheck - The url to check
 * @returns True if the URL is HTTPS; false otherwise.
 */ parcelHelpers.export(exports, "urlIsHTTPS", ()=>urlIsHTTPS);
/**
 * Encodes an URI.
 *
 * @param uri - The URI to be encoded.
 * @returns The encoded URI.
 */ parcelHelpers.export(exports, "encodeUri", ()=>encodeUri);
/**
 * Returns a stripped version of the Http Response which only contains body,
 * headers and the status.
 *
 * @param response - The Http Response
 * @returns The stripped version of Http Response.
 */ parcelHelpers.export(exports, "stripResponse", ()=>stripResponse);
/**
 * Returns a stripped version of the Http Request that does not contain the
 * Authorization header.
 *
 * @param request - The Http Request object
 * @returns The stripped version of Http Request.
 */ parcelHelpers.export(exports, "stripRequest", ()=>stripRequest);
/**
 * Validates the given uuid as a string
 *
 * @param uuid - The uuid as a string that needs to be validated
 * @returns True if the uuid is valid; false otherwise.
 */ parcelHelpers.export(exports, "isValidUuid", ()=>isValidUuid);
/**
 * Generated UUID
 *
 * @returns RFC4122 v4 UUID.
 */ parcelHelpers.export(exports, "generateUuid", ()=>generateUuid);
/**
 * Executes an array of promises sequentially. Inspiration of this method is here:
 * https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html. An awesome blog on promises!
 *
 * @param promiseFactories - An array of promise factories(A function that return a promise)
 * @param kickstart - Input to the first promise that is used to kickstart the promise chain.
 * If not provided then the promise chain starts with undefined.
 * @returns A chain of resolved or rejected promises
 */ parcelHelpers.export(exports, "executePromisesSequentially", ()=>executePromisesSequentially);
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @param t - The number of milliseconds to be delayed.
 * @param value - The value to be resolved with after a timeout of t milliseconds.
 * @returns Resolved promise
 */ parcelHelpers.export(exports, "delay", ()=>delay);
/**
 * Converts a Promise to a callback.
 * @param promise - The Promise to be converted to a callback
 * @returns A function that takes the callback `(cb: Function) => void`
 * @deprecated generated code should instead depend on responseToBody
 */ // eslint-disable-next-line @typescript-eslint/ban-types
parcelHelpers.export(exports, "promiseToCallback", ()=>promiseToCallback);
/**
 * Converts a Promise to a service callback.
 * @param promise - The Promise of HttpOperationResponse to be converted to a service callback
 * @returns A function that takes the service callback (cb: ServiceCallback<T>): void
 */ parcelHelpers.export(exports, "promiseToServiceCallback", ()=>promiseToServiceCallback);
parcelHelpers.export(exports, "prepareXMLRootList", ()=>prepareXMLRootList);
/**
 * Applies the properties on the prototype of sourceCtors to the prototype of targetCtor
 * @param targetCtor - The target object on which the properties need to be applied.
 * @param sourceCtors - An array of source objects from which the properties need to be taken.
 */ parcelHelpers.export(exports, "applyMixins", ()=>applyMixins);
/**
 * Indicates whether the given string is in ISO 8601 format.
 * @param value - The value to be validated for ISO 8601 duration format.
 * @returns `true` if valid, `false` otherwise.
 */ parcelHelpers.export(exports, "isDuration", ()=>isDuration);
/**
 * Replace all of the instances of searchValue in value with the provided replaceValue.
 * @param value - The value to search and replace in.
 * @param searchValue - The value to search for in the value argument.
 * @param replaceValue - The value to replace searchValue with in the value argument.
 * @returns The value where each instance of searchValue was replaced with replacedValue.
 */ parcelHelpers.export(exports, "replaceAll", ()=>replaceAll);
/**
 * Determines whether the given entity is a basic/primitive type
 * (string, number, boolean, null, undefined).
 * @param value - Any entity
 * @returns true is it is primitive type, false otherwise.
 */ parcelHelpers.export(exports, "isPrimitiveType", ()=>isPrimitiveType);
parcelHelpers.export(exports, "getEnvironmentValue", ()=>getEnvironmentValue);
var _uuid = require("uuid");
var _constants = require("./constants");
var _serializerCommon = require("./serializer.common");
var process = require("f43539c04a37f4ed");
var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var isNode = false;
function urlIsHTTPS(urlToCheck) {
    return urlToCheck.protocol.toLowerCase() === (0, _constants.Constants).HTTPS;
}
function encodeUri(uri) {
    return encodeURIComponent(uri).replace(/!/g, "%21").replace(/"/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
}
function stripResponse(response) {
    var strippedResponse = {};
    strippedResponse.body = response.bodyAsText;
    strippedResponse.headers = response.headers;
    strippedResponse.status = response.status;
    return strippedResponse;
}
function stripRequest(request) {
    var strippedRequest = request.clone();
    if (strippedRequest.headers) strippedRequest.headers.remove("authorization");
    return strippedRequest;
}
function isValidUuid(uuid) {
    return validUuidRegex.test(uuid);
}
function generateUuid() {
    return (0, _uuid.v4)();
}
function executePromisesSequentially(promiseFactories, kickstart) {
    var result = Promise.resolve(kickstart);
    promiseFactories.forEach(function(promiseFactory) {
        result = result.then(promiseFactory);
    });
    return result;
}
function delay(t, value) {
    return new Promise(function(resolve) {
        return setTimeout(function() {
            return resolve(value);
        }, t);
    });
}
function promiseToCallback(promise) {
    if (typeof promise.then !== "function") throw new Error("The provided input is not a Promise.");
    // eslint-disable-next-line @typescript-eslint/ban-types
    return function(cb) {
        promise.then(function(data) {
            // eslint-disable-next-line promise/no-callback-in-promise
            return cb(undefined, data);
        }).catch(function(err) {
            // eslint-disable-next-line promise/no-callback-in-promise
            cb(err);
        });
    };
}
function promiseToServiceCallback(promise) {
    if (typeof promise.then !== "function") throw new Error("The provided input is not a Promise.");
    return function(cb) {
        promise.then(function(data) {
            return process.nextTick(cb, undefined, data.parsedBody, data.request, data);
        }).catch(function(err) {
            process.nextTick(cb, err);
        });
    };
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
    var _a, _b, _c;
    if (!Array.isArray(obj)) obj = [
        obj
    ];
    if (!xmlNamespaceKey || !xmlNamespace) return _a = {}, _a[elementName] = obj, _a;
    var result = (_b = {}, _b[elementName] = obj, _b);
    result[0, _serializerCommon.XML_ATTRKEY] = (_c = {}, _c[xmlNamespaceKey] = xmlNamespace, _c);
    return result;
}
function applyMixins(targetCtorParam, sourceCtors) {
    var castTargetCtorParam = targetCtorParam;
    sourceCtors.forEach(function(sourceCtor) {
        Object.getOwnPropertyNames(sourceCtor.prototype).forEach(function(name) {
            castTargetCtorParam.prototype[name] = sourceCtor.prototype[name];
        });
    });
}
var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function isDuration(value) {
    return validateISODuration.test(value);
}
function replaceAll(value, searchValue, replaceValue) {
    return !value || !searchValue ? value : value.split(searchValue).join(replaceValue || "");
}
function isPrimitiveType(value) {
    return typeof value !== "object" && typeof value !== "function" || value === null;
}
function getEnvironmentValue(name) {
    if (process.env[name]) return process.env[name];
    else if (process.env[name.toLowerCase()]) return process.env[name.toLowerCase()];
    return undefined;
}

},{"f43539c04a37f4ed":"euskh","uuid":"f1qTK","./constants":"bc7jT","./serializer.common":"1KFRt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f1qTK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":false,"./v3.js":false,"./v4.js":"7Sd5x","./v5.js":false,"./nil.js":false,"./version.js":false,"./validate.js":false,"./stringify.js":false,"./parse.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Sd5x":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(var i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJsDefault.default)(rnds);
}
exports.default = v4;

},{"./rng.js":"aMz2Q","./stringify.js":"9dsAN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aMz2Q":[function(require,module,exports,__globalThis) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rng);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);
        if (!getRandomValues) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
    return getRandomValues(rnds8);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9dsAN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ var byteToHex = [];
for(var i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).substr(1));
function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError('Stringified UUID is invalid');
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"3wmxZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3wmxZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === 'string' && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"9mE1W","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9mE1W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bc7jT":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Constants", ()=>Constants);
var Constants = {
    /**
     * The core-http version
     */ coreHttpVersion: "1.2.4",
    /**
     * Specifies HTTP.
     */ HTTP: "http:",
    /**
     * Specifies HTTPS.
     */ HTTPS: "https:",
    /**
     * Specifies HTTP Proxy.
     */ HTTP_PROXY: "HTTP_PROXY",
    /**
     * Specifies HTTPS Proxy.
     */ HTTPS_PROXY: "HTTPS_PROXY",
    /**
     * Specifies NO Proxy.
     */ NO_PROXY: "NO_PROXY",
    /**
     * Specifies ALL Proxy.
     */ ALL_PROXY: "ALL_PROXY",
    HttpConstants: {
        /**
         * Http Verbs
         */ HttpVerbs: {
            PUT: "PUT",
            GET: "GET",
            DELETE: "DELETE",
            POST: "POST",
            MERGE: "MERGE",
            HEAD: "HEAD",
            PATCH: "PATCH"
        },
        StatusCodes: {
            TooManyRequests: 429
        }
    },
    /**
     * Defines constants for use with HTTP headers.
     */ HeaderConstants: {
        /**
         * The Authorization header.
         */ AUTHORIZATION: "authorization",
        AUTHORIZATION_SCHEME: "Bearer",
        /**
         * The Retry-After response-header field can be used with a 503 (Service
         * Unavailable) or 349 (Too Many Requests) responses to indicate how long
         * the service is expected to be unavailable to the requesting client.
         */ RETRY_AFTER: "Retry-After",
        /**
         * The UserAgent header.
         */ USER_AGENT: "User-Agent"
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1KFRt":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Default key used to access the XML attributes.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XML_ATTRKEY", ()=>XML_ATTRKEY);
parcelHelpers.export(exports, "XML_CHARKEY", ()=>XML_CHARKEY);
var XML_ATTRKEY = "$";
var XML_CHARKEY = "_";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"13Xl5":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultHttpClient", ()=>(0, _xhrHttpClient.XhrHttpClient));
var _xhrHttpClient = require("./xhrHttpClient");

},{"./xhrHttpClient":"8IoDR","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8IoDR":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "XhrHttpClient", ()=>XhrHttpClient);
// exported locally for testing
parcelHelpers.export(exports, "parseHeaders", ()=>parseHeaders);
var _abortController = require("@azure/abort-controller");
var _httpHeaders = require("./httpHeaders");
var _restError = require("./restError");
/**
 * A HttpClient implementation that uses XMLHttpRequest to send HTTP requests.
 */ var XhrHttpClient = /** @class */ function() {
    function XhrHttpClient() {}
    XhrHttpClient.prototype.sendRequest = function(request) {
        var _a;
        var xhr = new XMLHttpRequest();
        if (request.proxySettings) throw new Error("HTTP proxy is not supported in browser environment");
        var abortSignal = request.abortSignal;
        if (abortSignal) {
            if (abortSignal.aborted) return Promise.reject(new (0, _abortController.AbortError)("The operation was aborted."));
            var listener_1 = function() {
                xhr.abort();
            };
            abortSignal.addEventListener("abort", listener_1);
            xhr.addEventListener("readystatechange", function() {
                if (xhr.readyState === XMLHttpRequest.DONE) abortSignal.removeEventListener("abort", listener_1);
            });
        }
        addProgressListener(xhr.upload, request.onUploadProgress);
        addProgressListener(xhr, request.onDownloadProgress);
        if (request.formData) {
            var formData = request.formData;
            var requestForm_1 = new FormData();
            var appendFormValue = function(key, value) {
                if (value && Object.prototype.hasOwnProperty.call(value, "value") && Object.prototype.hasOwnProperty.call(value, "options")) requestForm_1.append(key, value.value, value.options);
                else requestForm_1.append(key, value);
            };
            for(var _i = 0, _b = Object.keys(formData); _i < _b.length; _i++){
                var formKey = _b[_i];
                var formValue = formData[formKey];
                if (Array.isArray(formValue)) for(var j = 0; j < formValue.length; j++)appendFormValue(formKey, formValue[j]);
                else appendFormValue(formKey, formValue);
            }
            request.body = requestForm_1;
            request.formData = undefined;
            var contentType = request.headers.get("Content-Type");
            if (contentType && contentType.indexOf("multipart/form-data") !== -1) // browser will automatically apply a suitable content-type header
            request.headers.remove("Content-Type");
        }
        xhr.open(request.method, request.url);
        xhr.timeout = request.timeout;
        xhr.withCredentials = request.withCredentials;
        for(var _c = 0, _d = request.headers.headersArray(); _c < _d.length; _c++){
            var header = _d[_c];
            xhr.setRequestHeader(header.name, header.value);
        }
        xhr.responseType = ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.size) || request.streamResponseBody ? "blob" : "text";
        // tslint:disable-next-line:no-null-keyword
        xhr.send(request.body === undefined ? null : request.body);
        if (xhr.responseType === "blob") return new Promise(function(resolve, reject) {
            handleBlobResponse(xhr, request, resolve, reject);
            rejectOnTerminalEvent(request, xhr, reject);
        });
        else return new Promise(function(resolve, reject) {
            xhr.addEventListener("load", function() {
                return resolve({
                    request: request,
                    status: xhr.status,
                    headers: parseHeaders(xhr),
                    bodyAsText: xhr.responseText
                });
            });
            rejectOnTerminalEvent(request, xhr, reject);
        });
    };
    return XhrHttpClient;
}();
function handleBlobResponse(xhr, request, res, rej) {
    xhr.addEventListener("readystatechange", function() {
        var _a;
        // Resolve as soon as headers are loaded
        if (xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED) {
            if (request.streamResponseBody || ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(xhr.status))) {
                var blobBody = new Promise(function(resolve, reject) {
                    xhr.addEventListener("load", function() {
                        resolve(xhr.response);
                    });
                    rejectOnTerminalEvent(request, xhr, reject);
                });
                res({
                    request: request,
                    status: xhr.status,
                    headers: parseHeaders(xhr),
                    blobBody: blobBody
                });
            } else xhr.addEventListener("load", function() {
                // xhr.response is of Blob type if the request is sent with xhr.responseType === "blob"
                // but the status code is not one of the stream response status codes,
                // so treat it as text and convert from Blob to text
                if (xhr.response) {
                    // Blob.text() is not supported in IE so using FileReader instead
                    var reader_1 = new FileReader();
                    reader_1.onload = function(e) {
                        var _a;
                        var text = (_a = e.target) === null || _a === void 0 ? void 0 : _a.result;
                        res({
                            request: request,
                            status: xhr.status,
                            headers: parseHeaders(xhr),
                            bodyAsText: text
                        });
                    };
                    reader_1.onerror = function(_e) {
                        rej(reader_1.error);
                    };
                    reader_1.readAsText(xhr.response, "UTF-8");
                } else res({
                    request: request,
                    status: xhr.status,
                    headers: parseHeaders(xhr)
                });
            });
        }
    });
}
function addProgressListener(xhr, listener) {
    if (listener) xhr.addEventListener("progress", function(rawEvent) {
        return listener({
            loadedBytes: rawEvent.loaded
        });
    });
}
function parseHeaders(xhr) {
    var responseHeaders = new (0, _httpHeaders.HttpHeaders)();
    var headerLines = xhr.getAllResponseHeaders().trim().split(/[\r\n]+/);
    for(var _i = 0, headerLines_1 = headerLines; _i < headerLines_1.length; _i++){
        var line = headerLines_1[_i];
        var index = line.indexOf(":");
        var headerName = line.slice(0, index);
        var headerValue = line.slice(index + 2);
        responseHeaders.set(headerName, headerValue);
    }
    return responseHeaders;
}
function rejectOnTerminalEvent(request, xhr, reject) {
    xhr.addEventListener("error", function() {
        return reject(new (0, _restError.RestError)("Failed to send request to " + request.url, (0, _restError.RestError).REQUEST_SEND_ERROR, undefined, request));
    });
    var abortError = new (0, _abortController.AbortError)("The operation was aborted.");
    xhr.addEventListener("abort", function() {
        return reject(abortError);
    });
    xhr.addEventListener("timeout", function() {
        return reject(abortError);
    });
}

},{"@azure/abort-controller":"6sTq4","./httpHeaders":"dFs7b","./restError":"bqwGr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6sTq4":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// Changes to Aborter
// * Rename Aborter to AbortSignal
// * Remove withValue and getValue - async context should be solved differently/wholistically, not tied to cancellation
// * Remove withTimeout, it's moved to the controller
// * AbortSignal constructor no longer takes a parent. Cancellation graphs are created from the controller.
// Potential changes to align with DOM Spec
// * dispatchEvent on Signal
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortController", ()=>(0, _abortController.AbortController));
parcelHelpers.export(exports, "AbortError", ()=>(0, _abortController.AbortError));
parcelHelpers.export(exports, "AbortSignal", ()=>(0, _abortSignal.AbortSignal));
var _abortController = require("./AbortController");
var _abortSignal = require("./AbortSignal");

},{"./AbortController":"jDzBi","./AbortSignal":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jDzBi":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortError", ()=>AbortError);
parcelHelpers.export(exports, "AbortController", ()=>AbortController);
var _tslib = require("tslib");
var _abortSignal = require("./AbortSignal");
/**
 * This error is thrown when an asynchronous operation has been aborted.
 * Check for this error by testing the `name` that the name property of the
 * error matches `"AbortError"`.
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * controller.abort();
 * try {
 *   doAsyncWork(controller.signal)
 * } catch (e) {
 *   if (e.name === 'AbortError') {
 *     // handle abort error here.
 *   }
 * }
 * ```
 */ var AbortError = /** @class */ function(_super) {
    (0, _tslib.__extends)(AbortError, _super);
    function AbortError(message) {
        var _this = _super.call(this, message) || this;
        _this.name = "AbortError";
        return _this;
    }
    return AbortError;
}(Error);
/**
 * An AbortController provides an AbortSignal and the associated controls to signal
 * that an asynchronous operation should be aborted.
 *
 * @example
 * Abort an operation when another event fires
 * ```ts
 * const controller = new AbortController();
 * const signal = controller.signal;
 * doAsyncWork(signal);
 * button.addEventListener('click', () => controller.abort());
 * ```
 *
 * @example
 * Share aborter cross multiple operations in 30s
 * ```ts
 * // Upload the same data to 2 different data centers at the same time,
 * // abort another when any of them is finished
 * const controller = AbortController.withTimeout(30 * 1000);
 * doAsyncWork(controller.signal).then(controller.abort);
 * doAsyncWork(controller.signal).then(controller.abort);
 *```
 *
 * @example
 * Cascaded aborting
 * ```ts
 * // All operations can't take more than 30 seconds
 * const aborter = Aborter.timeout(30 * 1000);
 *
 * // Following 2 operations can't take more than 25 seconds
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * await doAsyncWork(aborter.withTimeout(25 * 1000));
 * ```
 */ var AbortController = /** @class */ function() {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function AbortController(parentSignals) {
        var _this = this;
        this._signal = new (0, _abortSignal.AbortSignal)();
        if (!parentSignals) return;
        // coerce parentSignals into an array
        if (!Array.isArray(parentSignals)) // eslint-disable-next-line prefer-rest-params
        parentSignals = arguments;
        for(var _i = 0, parentSignals_1 = parentSignals; _i < parentSignals_1.length; _i++){
            var parentSignal = parentSignals_1[_i];
            // if the parent signal has already had abort() called,
            // then call abort on this signal as well.
            if (parentSignal.aborted) this.abort();
            else // when the parent signal aborts, this signal should as well.
            parentSignal.addEventListener("abort", function() {
                _this.abort();
            });
        }
    }
    Object.defineProperty(AbortController.prototype, "signal", {
        /**
         * The AbortSignal associated with this controller that will signal aborted
         * when the abort method is called on this controller.
         *
         * @readonly
         */ get: function() {
            return this._signal;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Signal that any operations passed this controller's associated abort signal
     * to cancel any remaining work and throw an `AbortError`.
     */ AbortController.prototype.abort = function() {
        (0, _abortSignal.abortSignal)(this._signal);
    };
    /**
     * Creates a new AbortSignal instance that will abort after the provided ms.
     * @param ms - Elapsed time in milliseconds to trigger an abort.
     */ AbortController.timeout = function(ms) {
        var signal = new (0, _abortSignal.AbortSignal)();
        var timer = setTimeout((0, _abortSignal.abortSignal), ms, signal);
        // Prevent the active Timer from keeping the Node.js event loop active.
        if (typeof timer.unref === "function") timer.unref();
        return signal;
    };
    return AbortController;
}();

},{"tslib":"iC1Dx","./AbortSignal":"jM8Ip","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jM8Ip":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortSignal", ()=>AbortSignal);
/**
 * Helper to trigger an abort event immediately, the onabort and all abort event listeners will be triggered.
 * Will try to trigger abort event for all linked AbortSignal nodes.
 *
 * - If there is a timeout, the timer will be cancelled.
 * - If aborted is true, nothing will happen.
 *
 * @internal
 */ // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
parcelHelpers.export(exports, "abortSignal", ()=>abortSignal);
var listenersMap = new WeakMap();
var abortedMap = new WeakMap();
/**
 * An aborter instance implements AbortSignal interface, can abort HTTP requests.
 *
 * - Call AbortSignal.none to create a new AbortSignal instance that cannot be cancelled.
 * Use `AbortSignal.none` when you are required to pass a cancellation token but the operation
 * cannot or will not ever be cancelled.
 *
 * @example
 * Abort without timeout
 * ```ts
 * await doAsyncWork(AbortSignal.none);
 * ```
 */ var AbortSignal = /** @class */ function() {
    function AbortSignal() {
        /**
         * onabort event listener.
         */ this.onabort = null;
        listenersMap.set(this, []);
        abortedMap.set(this, false);
    }
    Object.defineProperty(AbortSignal.prototype, "aborted", {
        /**
         * Status of whether aborted or not.
         *
         * @readonly
         */ get: function() {
            if (!abortedMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
            return abortedMap.get(this);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbortSignal, "none", {
        /**
         * Creates a new AbortSignal instance that will never be aborted.
         *
         * @readonly
         */ get: function() {
            return new AbortSignal();
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Added new "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be added
     */ AbortSignal.prototype.addEventListener = function(// tslint:disable-next-line:variable-name
    _type, listener) {
        if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        var listeners = listenersMap.get(this);
        listeners.push(listener);
    };
    /**
     * Remove "abort" event listener, only support "abort" event.
     *
     * @param _type - Only support "abort" event
     * @param listener - The listener to be removed
     */ AbortSignal.prototype.removeEventListener = function(// tslint:disable-next-line:variable-name
    _type, listener) {
        if (!listenersMap.has(this)) throw new TypeError("Expected `this` to be an instance of AbortSignal.");
        var listeners = listenersMap.get(this);
        var index = listeners.indexOf(listener);
        if (index > -1) listeners.splice(index, 1);
    };
    /**
     * Dispatches a synthetic event to the AbortSignal.
     */ AbortSignal.prototype.dispatchEvent = function(_event) {
        throw new Error("This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.");
    };
    return AbortSignal;
}();
function abortSignal(signal) {
    if (signal.aborted) return;
    if (signal.onabort) signal.onabort.call(signal);
    var listeners = listenersMap.get(signal);
    if (listeners) // Create a copy of listeners so mutations to the array
    // (e.g. via removeListener calls) don't affect the listeners
    // we invoke.
    listeners.slice().forEach(function(listener) {
        listener.call(signal, {
            type: "abort"
        });
    });
    abortedMap.set(signal, true);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bqwGr":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RestError", ()=>RestError);
var _tslib = require("tslib");
var _inspect = require("./util/inspect");
var _sanitizer = require("./util/sanitizer");
var errorSanitizer = new (0, _sanitizer.Sanitizer)();
var RestError = /** @class */ function(_super) {
    (0, _tslib.__extends)(RestError, _super);
    function RestError(message, code, statusCode, request, response) {
        var _this = _super.call(this, message) || this;
        _this.name = "RestError";
        _this.code = code;
        _this.statusCode = statusCode;
        _this.request = request;
        _this.response = response;
        Object.setPrototypeOf(_this, RestError.prototype);
        return _this;
    }
    /**
     * Logging method for util.inspect in Node
     */ RestError.prototype[0, _inspect.custom] = function() {
        return "RestError: " + this.message + " \n " + errorSanitizer.sanitize(this);
    };
    RestError.REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    RestError.PARSE_ERROR = "PARSE_ERROR";
    return RestError;
}(Error);

},{"tslib":"iC1Dx","./util/inspect":"2hSTm","./util/sanitizer":"xc0Vd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2hSTm":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "custom", ()=>custom);
var custom = {};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"xc0Vd":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Sanitizer", ()=>Sanitizer);
var _tslib = require("tslib");
var _url = require("../url");
var RedactedString = "REDACTED";
var defaultAllowedHeaderNames = [
    "x-ms-client-request-id",
    "x-ms-return-client-request-id",
    "x-ms-useragent",
    "x-ms-correlation-request-id",
    "x-ms-request-id",
    "client-request-id",
    "ms-cv",
    "return-client-request-id",
    "traceparent",
    "Access-Control-Allow-Credentials",
    "Access-Control-Allow-Headers",
    "Access-Control-Allow-Methods",
    "Access-Control-Allow-Origin",
    "Access-Control-Expose-Headers",
    "Access-Control-Max-Age",
    "Access-Control-Request-Headers",
    "Access-Control-Request-Method",
    "Origin",
    "Accept",
    "Cache-Control",
    "Connection",
    "Content-Length",
    "Content-Type",
    "Date",
    "ETag",
    "Expires",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "Last-Modified",
    "Pragma",
    "Request-Id",
    "Retry-After",
    "Server",
    "Transfer-Encoding",
    "User-Agent"
];
var defaultAllowedQueryParameters = [
    "api-version"
];
var Sanitizer = /** @class */ function() {
    function Sanitizer(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.allowedHeaderNames, allowedHeaderNames = _c === void 0 ? [] : _c, _d = _b.allowedQueryParameters, allowedQueryParameters = _d === void 0 ? [] : _d;
        allowedHeaderNames = Array.isArray(allowedHeaderNames) ? defaultAllowedHeaderNames.concat(allowedHeaderNames) : defaultAllowedHeaderNames;
        allowedQueryParameters = Array.isArray(allowedQueryParameters) ? defaultAllowedQueryParameters.concat(allowedQueryParameters) : defaultAllowedQueryParameters;
        this.allowedHeaderNames = new Set(allowedHeaderNames.map(function(n) {
            return n.toLowerCase();
        }));
        this.allowedQueryParameters = new Set(allowedQueryParameters.map(function(p) {
            return p.toLowerCase();
        }));
    }
    Sanitizer.prototype.sanitize = function(obj) {
        return JSON.stringify(obj, this.replacer.bind(this), 2);
    };
    Sanitizer.prototype.replacer = function(key, value) {
        // Ensure Errors include their interesting non-enumerable members
        if (value instanceof Error) return (0, _tslib.__assign)((0, _tslib.__assign)({}, value), {
            name: value.name,
            message: value.message
        });
        if (key === "_headersMap") return this.sanitizeHeaders(key, value);
        else if (key === "url") return this.sanitizeUrl(value);
        else if (key === "query") return this.sanitizeQuery(value);
        else if (key === "body") // Don't log the request body
        return undefined;
        else if (key === "response") // Don't log response again
        return undefined;
        else if (key === "operationSpec") // When using sendOperationRequest, the request carries a massive
        // field with the autorest spec. No need to log it.
        return undefined;
        return value;
    };
    Sanitizer.prototype.sanitizeHeaders = function(_, value) {
        return this.sanitizeObject(value, this.allowedHeaderNames, function(v, k) {
            return v[k].value;
        });
    };
    Sanitizer.prototype.sanitizeQuery = function(value) {
        return this.sanitizeObject(value, this.allowedQueryParameters, function(v, k) {
            return v[k];
        });
    };
    Sanitizer.prototype.sanitizeObject = function(value, allowedKeys, accessor) {
        if (typeof value !== "object" || value === null) return value;
        var sanitized = {};
        for(var _i = 0, _a = Object.keys(value); _i < _a.length; _i++){
            var k = _a[_i];
            if (allowedKeys.has(k.toLowerCase())) sanitized[k] = accessor(value, k);
            else sanitized[k] = RedactedString;
        }
        return sanitized;
    };
    Sanitizer.prototype.sanitizeUrl = function(value) {
        if (typeof value !== "string" || value === null) return value;
        var urlBuilder = (0, _url.URLBuilder).parse(value);
        var queryString = urlBuilder.getQuery();
        if (!queryString) return value;
        var query = (0, _url.URLQuery).parse(queryString);
        for(var _i = 0, _a = query.keys(); _i < _a.length; _i++){
            var k = _a[_i];
            if (!this.allowedQueryParameters.has(k.toLowerCase())) query.set(k, RedactedString);
        }
        urlBuilder.setQuery(query.toString());
        return urlBuilder.toString();
    };
    return Sanitizer;
}();

},{"tslib":"iC1Dx","../url":"6ht7o","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6ht7o":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "URL", ()=>(0, _url.URL));
parcelHelpers.export(exports, "URLQuery", ()=>URLQuery);
parcelHelpers.export(exports, "URLBuilder", ()=>URLBuilder);
parcelHelpers.export(exports, "URLToken", ()=>URLToken);
/**
 * Get whether or not the provided character (single character string) is an alphanumeric (letter or
 * digit) character.
 */ parcelHelpers.export(exports, "isAlphaNumericCharacter", ()=>isAlphaNumericCharacter);
parcelHelpers.export(exports, "URLTokenizer", ()=>URLTokenizer);
var _utils = require("./util/utils");
var _url = require("./util/url");
/**
 * A class that handles the query portion of a URLBuilder.
 */ var URLQuery = /** @class */ function() {
    function URLQuery() {
        this._rawQuery = {};
    }
    /**
     * Get whether or not there any query parameters in this URLQuery.
     */ URLQuery.prototype.any = function() {
        return Object.keys(this._rawQuery).length > 0;
    };
    /**
     * Get the keys of the query string.
     */ URLQuery.prototype.keys = function() {
        return Object.keys(this._rawQuery);
    };
    /**
     * Set a query parameter with the provided name and value. If the parameterValue is undefined or
     * empty, then this will attempt to remove an existing query parameter with the provided
     * parameterName.
     */ URLQuery.prototype.set = function(parameterName, parameterValue) {
        var caseParameterValue = parameterValue;
        if (parameterName) {
            if (caseParameterValue !== undefined && caseParameterValue !== null) {
                var newValue = Array.isArray(caseParameterValue) ? caseParameterValue : caseParameterValue.toString();
                this._rawQuery[parameterName] = newValue;
            } else delete this._rawQuery[parameterName];
        }
    };
    /**
     * Get the value of the query parameter with the provided name. If no parameter exists with the
     * provided parameter name, then undefined will be returned.
     */ URLQuery.prototype.get = function(parameterName) {
        return parameterName ? this._rawQuery[parameterName] : undefined;
    };
    /**
     * Get the string representation of this query. The return value will not start with a "?".
     */ URLQuery.prototype.toString = function() {
        var result = "";
        for(var parameterName in this._rawQuery){
            if (result) result += "&";
            var parameterValue = this._rawQuery[parameterName];
            if (Array.isArray(parameterValue)) {
                var parameterStrings = [];
                for(var _i = 0, parameterValue_1 = parameterValue; _i < parameterValue_1.length; _i++){
                    var parameterValueElement = parameterValue_1[_i];
                    parameterStrings.push(parameterName + "=" + parameterValueElement);
                }
                result += parameterStrings.join("&");
            } else result += parameterName + "=" + parameterValue;
        }
        return result;
    };
    /**
     * Parse a URLQuery from the provided text.
     */ URLQuery.parse = function(text) {
        var result = new URLQuery();
        if (text) {
            if (text.startsWith("?")) text = text.substring(1);
            var currentState = "ParameterName";
            var parameterName = "";
            var parameterValue = "";
            for(var i = 0; i < text.length; ++i){
                var currentCharacter = text[i];
                switch(currentState){
                    case "ParameterName":
                        switch(currentCharacter){
                            case "=":
                                currentState = "ParameterValue";
                                break;
                            case "&":
                                parameterName = "";
                                parameterValue = "";
                                break;
                            default:
                                parameterName += currentCharacter;
                                break;
                        }
                        break;
                    case "ParameterValue":
                        switch(currentCharacter){
                            case "&":
                                result.set(parameterName, parameterValue);
                                parameterName = "";
                                parameterValue = "";
                                currentState = "ParameterName";
                                break;
                            default:
                                parameterValue += currentCharacter;
                                break;
                        }
                        break;
                    default:
                        throw new Error("Unrecognized URLQuery parse state: " + currentState);
                }
            }
            if (currentState === "ParameterValue") result.set(parameterName, parameterValue);
        }
        return result;
    };
    return URLQuery;
}();
/**
 * A class that handles creating, modifying, and parsing URLs.
 */ var URLBuilder = /** @class */ function() {
    function URLBuilder() {}
    /**
     * Set the scheme/protocol for this URL. If the provided scheme contains other parts of a URL
     * (such as a host, port, path, or query), those parts will be added to this URL as well.
     */ URLBuilder.prototype.setScheme = function(scheme) {
        if (!scheme) this._scheme = undefined;
        else this.set(scheme, "SCHEME");
    };
    /**
     * Get the scheme that has been set in this URL.
     */ URLBuilder.prototype.getScheme = function() {
        return this._scheme;
    };
    /**
     * Set the host for this URL. If the provided host contains other parts of a URL (such as a
     * port, path, or query), those parts will be added to this URL as well.
     */ URLBuilder.prototype.setHost = function(host) {
        if (!host) this._host = undefined;
        else this.set(host, "SCHEME_OR_HOST");
    };
    /**
     * Get the host that has been set in this URL.
     */ URLBuilder.prototype.getHost = function() {
        return this._host;
    };
    /**
     * Set the port for this URL. If the provided port contains other parts of a URL (such as a
     * path or query), those parts will be added to this URL as well.
     */ URLBuilder.prototype.setPort = function(port) {
        if (port === undefined || port === null || port === "") this._port = undefined;
        else this.set(port.toString(), "PORT");
    };
    /**
     * Get the port that has been set in this URL.
     */ URLBuilder.prototype.getPort = function() {
        return this._port;
    };
    /**
     * Set the path for this URL. If the provided path contains a query, then it will be added to
     * this URL as well.
     */ URLBuilder.prototype.setPath = function(path) {
        if (!path) this._path = undefined;
        else {
            var schemeIndex = path.indexOf("://");
            if (schemeIndex !== -1) {
                var schemeStart = path.lastIndexOf("/", schemeIndex);
                // Make sure to only grab the URL part of the path before setting the state back to SCHEME
                // this will handle cases such as "/a/b/c/https://microsoft.com" => "https://microsoft.com"
                this.set(schemeStart === -1 ? path : path.substr(schemeStart + 1), "SCHEME");
            } else this.set(path, "PATH");
        }
    };
    /**
     * Append the provided path to this URL's existing path. If the provided path contains a query,
     * then it will be added to this URL as well.
     */ URLBuilder.prototype.appendPath = function(path) {
        if (path) {
            var currentPath = this.getPath();
            if (currentPath) {
                if (!currentPath.endsWith("/")) currentPath += "/";
                if (path.startsWith("/")) path = path.substring(1);
                path = currentPath + path;
            }
            this.set(path, "PATH");
        }
    };
    /**
     * Get the path that has been set in this URL.
     */ URLBuilder.prototype.getPath = function() {
        return this._path;
    };
    /**
     * Set the query in this URL.
     */ URLBuilder.prototype.setQuery = function(query) {
        if (!query) this._query = undefined;
        else this._query = URLQuery.parse(query);
    };
    /**
     * Set a query parameter with the provided name and value in this URL's query. If the provided
     * query parameter value is undefined or empty, then the query parameter will be removed if it
     * existed.
     */ URLBuilder.prototype.setQueryParameter = function(queryParameterName, queryParameterValue) {
        if (queryParameterName) {
            if (!this._query) this._query = new URLQuery();
            this._query.set(queryParameterName, queryParameterValue);
        }
    };
    /**
     * Get the value of the query parameter with the provided query parameter name. If no query
     * parameter exists with the provided name, then undefined will be returned.
     */ URLBuilder.prototype.getQueryParameterValue = function(queryParameterName) {
        return this._query ? this._query.get(queryParameterName) : undefined;
    };
    /**
     * Get the query in this URL.
     */ URLBuilder.prototype.getQuery = function() {
        return this._query ? this._query.toString() : undefined;
    };
    /**
     * Set the parts of this URL by parsing the provided text using the provided startState.
     */ URLBuilder.prototype.set = function(text, startState) {
        var tokenizer = new URLTokenizer(text, startState);
        while(tokenizer.next()){
            var token = tokenizer.current();
            var tokenPath = void 0;
            if (token) switch(token.type){
                case "SCHEME":
                    this._scheme = token.text || undefined;
                    break;
                case "HOST":
                    this._host = token.text || undefined;
                    break;
                case "PORT":
                    this._port = token.text || undefined;
                    break;
                case "PATH":
                    tokenPath = token.text || undefined;
                    if (!this._path || this._path === "/" || tokenPath !== "/") this._path = tokenPath;
                    break;
                case "QUERY":
                    this._query = URLQuery.parse(token.text);
                    break;
                default:
                    throw new Error("Unrecognized URLTokenType: " + token.type);
            }
        }
    };
    URLBuilder.prototype.toString = function() {
        var result = "";
        if (this._scheme) result += this._scheme + "://";
        if (this._host) result += this._host;
        if (this._port) result += ":" + this._port;
        if (this._path) {
            if (!this._path.startsWith("/")) result += "/";
            result += this._path;
        }
        if (this._query && this._query.any()) result += "?" + this._query.toString();
        return result;
    };
    /**
     * If the provided searchValue is found in this URLBuilder, then replace it with the provided
     * replaceValue.
     */ URLBuilder.prototype.replaceAll = function(searchValue, replaceValue) {
        if (searchValue) {
            this.setScheme((0, _utils.replaceAll)(this.getScheme(), searchValue, replaceValue));
            this.setHost((0, _utils.replaceAll)(this.getHost(), searchValue, replaceValue));
            this.setPort((0, _utils.replaceAll)(this.getPort(), searchValue, replaceValue));
            this.setPath((0, _utils.replaceAll)(this.getPath(), searchValue, replaceValue));
            this.setQuery((0, _utils.replaceAll)(this.getQuery(), searchValue, replaceValue));
        }
    };
    URLBuilder.parse = function(text) {
        var result = new URLBuilder();
        result.set(text, "SCHEME_OR_HOST");
        return result;
    };
    return URLBuilder;
}();
var URLToken = /** @class */ function() {
    function URLToken(text, type) {
        this.text = text;
        this.type = type;
    }
    URLToken.scheme = function(text) {
        return new URLToken(text, "SCHEME");
    };
    URLToken.host = function(text) {
        return new URLToken(text, "HOST");
    };
    URLToken.port = function(text) {
        return new URLToken(text, "PORT");
    };
    URLToken.path = function(text) {
        return new URLToken(text, "PATH");
    };
    URLToken.query = function(text) {
        return new URLToken(text, "QUERY");
    };
    return URLToken;
}();
function isAlphaNumericCharacter(character) {
    var characterCode = character.charCodeAt(0);
    return 48 /* '0' */  <= characterCode && characterCode <= 57 || 65 /* 'A' */  <= characterCode && characterCode <= 90 || 97 /* 'a' */  <= characterCode && characterCode <= 122;
}
/**
 * A class that tokenizes URL strings.
 */ var URLTokenizer = /** @class */ function() {
    function URLTokenizer(_text, state) {
        this._text = _text;
        this._textLength = _text ? _text.length : 0;
        this._currentState = state !== undefined && state !== null ? state : "SCHEME_OR_HOST";
        this._currentIndex = 0;
    }
    /**
     * Get the current URLToken this URLTokenizer is pointing at, or undefined if the URLTokenizer
     * hasn't started or has finished tokenizing.
     */ URLTokenizer.prototype.current = function() {
        return this._currentToken;
    };
    /**
     * Advance to the next URLToken and return whether or not a URLToken was found.
     */ URLTokenizer.prototype.next = function() {
        if (!hasCurrentCharacter(this)) this._currentToken = undefined;
        else switch(this._currentState){
            case "SCHEME":
                nextScheme(this);
                break;
            case "SCHEME_OR_HOST":
                nextSchemeOrHost(this);
                break;
            case "HOST":
                nextHost(this);
                break;
            case "PORT":
                nextPort(this);
                break;
            case "PATH":
                nextPath(this);
                break;
            case "QUERY":
                nextQuery(this);
                break;
            default:
                throw new Error("Unrecognized URLTokenizerState: " + this._currentState);
        }
        return !!this._currentToken;
    };
    return URLTokenizer;
}();
/**
 * Read the remaining characters from this Tokenizer's character stream.
 */ function readRemaining(tokenizer) {
    var result = "";
    if (tokenizer._currentIndex < tokenizer._textLength) {
        result = tokenizer._text.substring(tokenizer._currentIndex);
        tokenizer._currentIndex = tokenizer._textLength;
    }
    return result;
}
/**
 * Whether or not this URLTokenizer has a current character.
 */ function hasCurrentCharacter(tokenizer) {
    return tokenizer._currentIndex < tokenizer._textLength;
}
/**
 * Get the character in the text string at the current index.
 */ function getCurrentCharacter(tokenizer) {
    return tokenizer._text[tokenizer._currentIndex];
}
/**
 * Advance to the character in text that is "step" characters ahead. If no step value is provided,
 * then step will default to 1.
 */ function nextCharacter(tokenizer, step) {
    if (hasCurrentCharacter(tokenizer)) {
        if (!step) step = 1;
        tokenizer._currentIndex += step;
    }
}
/**
 * Starting with the current character, peek "charactersToPeek" number of characters ahead in this
 * Tokenizer's stream of characters.
 */ function peekCharacters(tokenizer, charactersToPeek) {
    var endIndex = tokenizer._currentIndex + charactersToPeek;
    if (tokenizer._textLength < endIndex) endIndex = tokenizer._textLength;
    return tokenizer._text.substring(tokenizer._currentIndex, endIndex);
}
/**
 * Read characters from this Tokenizer until the end of the stream or until the provided condition
 * is false when provided the current character.
 */ function readWhile(tokenizer, condition) {
    var result = "";
    while(hasCurrentCharacter(tokenizer)){
        var currentCharacter = getCurrentCharacter(tokenizer);
        if (!condition(currentCharacter)) break;
        else {
            result += currentCharacter;
            nextCharacter(tokenizer);
        }
    }
    return result;
}
/**
 * Read characters from this Tokenizer until a non-alphanumeric character or the end of the
 * character stream is reached.
 */ function readWhileLetterOrDigit(tokenizer) {
    return readWhile(tokenizer, function(character) {
        return isAlphaNumericCharacter(character);
    });
}
/**
 * Read characters from this Tokenizer until one of the provided terminating characters is read or
 * the end of the character stream is reached.
 */ function readUntilCharacter(tokenizer) {
    var terminatingCharacters = [];
    for(var _i = 1; _i < arguments.length; _i++)terminatingCharacters[_i - 1] = arguments[_i];
    return readWhile(tokenizer, function(character) {
        return terminatingCharacters.indexOf(character) === -1;
    });
}
function nextScheme(tokenizer) {
    var scheme = readWhileLetterOrDigit(tokenizer);
    tokenizer._currentToken = URLToken.scheme(scheme);
    if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
    else tokenizer._currentState = "HOST";
}
function nextSchemeOrHost(tokenizer) {
    var schemeOrHost = readUntilCharacter(tokenizer, ":", "/", "?");
    if (!hasCurrentCharacter(tokenizer)) {
        tokenizer._currentToken = URLToken.host(schemeOrHost);
        tokenizer._currentState = "DONE";
    } else if (getCurrentCharacter(tokenizer) === ":") {
        if (peekCharacters(tokenizer, 3) === "://") {
            tokenizer._currentToken = URLToken.scheme(schemeOrHost);
            tokenizer._currentState = "HOST";
        } else {
            tokenizer._currentToken = URLToken.host(schemeOrHost);
            tokenizer._currentState = "PORT";
        }
    } else {
        tokenizer._currentToken = URLToken.host(schemeOrHost);
        if (getCurrentCharacter(tokenizer) === "/") tokenizer._currentState = "PATH";
        else tokenizer._currentState = "QUERY";
    }
}
function nextHost(tokenizer) {
    if (peekCharacters(tokenizer, 3) === "://") nextCharacter(tokenizer, 3);
    var host = readUntilCharacter(tokenizer, ":", "/", "?");
    tokenizer._currentToken = URLToken.host(host);
    if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
    else if (getCurrentCharacter(tokenizer) === ":") tokenizer._currentState = "PORT";
    else if (getCurrentCharacter(tokenizer) === "/") tokenizer._currentState = "PATH";
    else tokenizer._currentState = "QUERY";
}
function nextPort(tokenizer) {
    if (getCurrentCharacter(tokenizer) === ":") nextCharacter(tokenizer);
    var port = readUntilCharacter(tokenizer, "/", "?");
    tokenizer._currentToken = URLToken.port(port);
    if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
    else if (getCurrentCharacter(tokenizer) === "/") tokenizer._currentState = "PATH";
    else tokenizer._currentState = "QUERY";
}
function nextPath(tokenizer) {
    var path = readUntilCharacter(tokenizer, "?");
    tokenizer._currentToken = URLToken.path(path);
    if (!hasCurrentCharacter(tokenizer)) tokenizer._currentState = "DONE";
    else tokenizer._currentState = "QUERY";
}
function nextQuery(tokenizer) {
    if (getCurrentCharacter(tokenizer) === "?") nextCharacter(tokenizer);
    var query = readRemaining(tokenizer);
    tokenizer._currentToken = URLToken.query(query);
    tokenizer._currentState = "DONE";
}

},{"./util/utils":"3ok7s","./util/url":"1mnln","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1mnln":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "URL", ()=>url);
var url = URL;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5X4Pz":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The different levels of logs that can be used with the HttpPipelineLogger.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HttpPipelineLogLevel", ()=>HttpPipelineLogLevel);
var HttpPipelineLogLevel;
(function(HttpPipelineLogLevel) {
    /**
     * A log level that indicates that no logs will be logged.
     */ HttpPipelineLogLevel[HttpPipelineLogLevel["OFF"] = 0] = "OFF";
    /**
     * An error log.
     */ HttpPipelineLogLevel[HttpPipelineLogLevel["ERROR"] = 1] = "ERROR";
    /**
     * A warning log.
     */ HttpPipelineLogLevel[HttpPipelineLogLevel["WARNING"] = 2] = "WARNING";
    /**
     * An information log.
     */ HttpPipelineLogLevel[HttpPipelineLogLevel["INFO"] = 3] = "INFO";
})(HttpPipelineLogLevel || (HttpPipelineLogLevel = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6kYTS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts an OperationOptions to a RequestOptionsBase
 *
 * @param opts - OperationOptions object to convert to RequestOptionsBase
 */ parcelHelpers.export(exports, "operationOptionsToRequestOptionsBase", ()=>operationOptionsToRequestOptionsBase);
var _tslib = require("tslib");
function operationOptionsToRequestOptionsBase(opts) {
    var requestOptions = opts.requestOptions, tracingOptions = opts.tracingOptions, additionalOptions = (0, _tslib.__rest)(opts, [
        "requestOptions",
        "tracingOptions"
    ]);
    var result = additionalOptions;
    if (requestOptions) result = (0, _tslib.__assign)((0, _tslib.__assign)({}, result), requestOptions);
    if (tracingOptions) {
        result.spanOptions = tracingOptions.spanOptions;
        result.tracingContext = tracingOptions.tracingContext;
    }
    return result;
}

},{"tslib":"iC1Dx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2jEVW":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ServiceClient", ()=>ServiceClient);
parcelHelpers.export(exports, "serializeRequestBody", ()=>serializeRequestBody);
parcelHelpers.export(exports, "createPipelineFromOptions", ()=>createPipelineFromOptions);
/**
 * Get the property parent for the property at the provided path when starting with the provided
 * parent object.
 */ parcelHelpers.export(exports, "getPropertyParent", ()=>getPropertyParent);
parcelHelpers.export(exports, "getOperationArgumentValueFromParameterPath", ()=>getOperationArgumentValueFromParameterPath);
parcelHelpers.export(exports, "flattenResponse", ()=>flattenResponse);
var _tslib = require("tslib");
var _coreAuth = require("@azure/core-auth");
var _logPolicy = require("./policies/logPolicy");
var _operationParameter = require("./operationParameter");
var _operationSpec = require("./operationSpec");
var _deserializationPolicy = require("./policies/deserializationPolicy");
var _exponentialRetryPolicy = require("./policies/exponentialRetryPolicy");
var _generateClientRequestIdPolicy = require("./policies/generateClientRequestIdPolicy");
var _userAgentPolicy = require("./policies/userAgentPolicy");
var _redirectPolicy = require("./policies/redirectPolicy");
var _requestPolicy = require("./policies/requestPolicy");
var _rpRegistrationPolicy = require("./policies/rpRegistrationPolicy");
var _bearerTokenAuthenticationPolicy = require("./policies/bearerTokenAuthenticationPolicy");
var _systemErrorRetryPolicy = require("./policies/systemErrorRetryPolicy");
var _queryCollectionFormat = require("./queryCollectionFormat");
var _serializer = require("./serializer");
var _url = require("./url");
var _utils = require("./util/utils");
var _xml = require("./util/xml");
var _webResource = require("./webResource");
var _proxyPolicy = require("./policies/proxyPolicy");
var _throttlingRetryPolicy = require("./policies/throttlingRetryPolicy");
var _signingPolicy = require("./policies/signingPolicy");
var _log = require("./log");
var _keepAlivePolicy = require("./policies/keepAlivePolicy");
var _tracingPolicy = require("./policies/tracingPolicy");
var _disableResponseDecompressionPolicy = require("./policies/disableResponseDecompressionPolicy");
var _ndJsonPolicy = require("./policies/ndJsonPolicy");
var _serializerCommon = require("./util/serializer.common");
var _httpClientCache = require("./httpClientCache");
/**
 * ServiceClient sends service requests and receives responses.
 */ var ServiceClient = /** @class */ function() {
    /**
     * The ServiceClient constructor
     * @param credentials - The credentials used for authentication with the service.
     * @param options - The service client options that govern the behavior of the client.
     */ function ServiceClient(credentials, /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */ options) {
        var _this = this;
        if (!options) options = {};
        this._withCredentials = options.withCredentials || false;
        this._httpClient = options.httpClient || (0, _httpClientCache.getCachedDefaultHttpClient)();
        this._requestPolicyOptions = new (0, _requestPolicy.RequestPolicyOptions)(options.httpPipelineLogger);
        var requestPolicyFactories;
        if (Array.isArray(options.requestPolicyFactories)) {
            (0, _log.logger).info("ServiceClient: using custom request policies");
            requestPolicyFactories = options.requestPolicyFactories;
        } else {
            var authPolicyFactory = undefined;
            if ((0, _coreAuth.isTokenCredential)(credentials)) {
                (0, _log.logger).info("ServiceClient: creating bearer token authentication policy from provided credentials");
                // Create a wrapped RequestPolicyFactory here so that we can provide the
                // correct scope to the BearerTokenAuthenticationPolicy at the first time
                // one is requested.  This is needed because generated ServiceClient
                // implementations do not set baseUri until after ServiceClient's constructor
                // is finished, leaving baseUri empty at the time when it is needed to
                // build the correct scope name.
                var wrappedPolicyFactory = function() {
                    var bearerTokenPolicyFactory = undefined;
                    // eslint-disable-next-line @typescript-eslint/no-this-alias
                    var serviceClient = _this;
                    var serviceClientOptions = options;
                    return {
                        create: function(nextPolicy, createOptions) {
                            var credentialScopes = getCredentialScopes(serviceClientOptions, serviceClient.baseUri);
                            if (!credentialScopes) throw new Error("When using credential, the ServiceClient must contain a baseUri or a credentialScopes in ServiceClientOptions. Unable to create a bearerTokenAuthenticationPolicy");
                            if (bearerTokenPolicyFactory === undefined || bearerTokenPolicyFactory === null) bearerTokenPolicyFactory = (0, _bearerTokenAuthenticationPolicy.bearerTokenAuthenticationPolicy)(credentials, credentialScopes);
                            return bearerTokenPolicyFactory.create(nextPolicy, createOptions);
                        }
                    };
                };
                authPolicyFactory = wrappedPolicyFactory();
            } else if (credentials && typeof credentials.signRequest === "function") {
                (0, _log.logger).info("ServiceClient: creating signing policy from provided credentials");
                authPolicyFactory = (0, _signingPolicy.signingPolicy)(credentials);
            } else if (credentials !== undefined && credentials !== null) throw new Error("The credentials argument must implement the TokenCredential interface");
            (0, _log.logger).info("ServiceClient: using default request policies");
            requestPolicyFactories = createDefaultRequestPolicyFactories(authPolicyFactory, options);
            if (options.requestPolicyFactories) {
                // options.requestPolicyFactories can also be a function that manipulates
                // the default requestPolicyFactories array
                var newRequestPolicyFactories = options.requestPolicyFactories(requestPolicyFactories);
                if (newRequestPolicyFactories) requestPolicyFactories = newRequestPolicyFactories;
            }
        }
        this._requestPolicyFactories = requestPolicyFactories;
    }
    /**
     * Send the provided httpRequest.
     */ ServiceClient.prototype.sendRequest = function(options) {
        if (options === null || options === undefined || typeof options !== "object") throw new Error("options cannot be null or undefined and it must be of type object.");
        var httpRequest;
        try {
            if ((0, _webResource.isWebResourceLike)(options)) {
                options.validateRequestProperties();
                httpRequest = options;
            } else {
                httpRequest = new (0, _webResource.WebResource)();
                httpRequest = httpRequest.prepare(options);
            }
        } catch (error) {
            return Promise.reject(error);
        }
        var httpPipeline = this._httpClient;
        if (this._requestPolicyFactories && this._requestPolicyFactories.length > 0) for(var i = this._requestPolicyFactories.length - 1; i >= 0; --i)httpPipeline = this._requestPolicyFactories[i].create(httpPipeline, this._requestPolicyOptions);
        return httpPipeline.sendRequest(httpRequest);
    };
    /**
     * Send an HTTP request that is populated using the provided OperationSpec.
     * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
     * @param operationSpec - The OperationSpec to use to populate the httpRequest.
     * @param callback - The callback to call when the response is received.
     */ ServiceClient.prototype.sendOperationRequest = function(operationArguments, operationSpec, callback) {
        var _a;
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            var serializerOptions, httpRequest, result, baseUri, requestUrl, _i, _b, urlParameter, urlParameterValue, _c, _d, queryParameter, queryParameterValue, index, item, index, contentType, _e, _f, headerParameter, headerValue, headerCollectionPrefix, _g, _h, key, options, customHeaderName, rawResponse, sendRequestError, error_1, error_2, cb;
            return (0, _tslib.__generator)(this, function(_j) {
                switch(_j.label){
                    case 0:
                        if (typeof operationArguments.options === "function") {
                            callback = operationArguments.options;
                            operationArguments.options = undefined;
                        }
                        serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
                        httpRequest = new (0, _webResource.WebResource)();
                        _j.label = 1;
                    case 1:
                        _j.trys.push([
                            1,
                            6,
                            ,
                            7
                        ]);
                        baseUri = operationSpec.baseUrl || this.baseUri;
                        if (!baseUri) throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a baseUri string property that contains the base URL to use.");
                        httpRequest.method = operationSpec.httpMethod;
                        httpRequest.operationSpec = operationSpec;
                        requestUrl = (0, _url.URLBuilder).parse(baseUri);
                        if (operationSpec.path) requestUrl.appendPath(operationSpec.path);
                        if (operationSpec.urlParameters && operationSpec.urlParameters.length > 0) for(_i = 0, _b = operationSpec.urlParameters; _i < _b.length; _i++){
                            urlParameter = _b[_i];
                            urlParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, urlParameter, operationSpec.serializer);
                            urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, (0, _operationParameter.getPathStringFromParameter)(urlParameter), serializerOptions);
                            if (!urlParameter.skipEncoding) urlParameterValue = encodeURIComponent(urlParameterValue);
                            requestUrl.replaceAll("{" + (urlParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(urlParameter)) + "}", urlParameterValue);
                        }
                        if (operationSpec.queryParameters && operationSpec.queryParameters.length > 0) for(_c = 0, _d = operationSpec.queryParameters; _c < _d.length; _c++){
                            queryParameter = _d[_c];
                            queryParameterValue = getOperationArgumentValueFromParameter(this, operationArguments, queryParameter, operationSpec.serializer);
                            if (queryParameterValue !== undefined && queryParameterValue !== null) {
                                queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, (0, _operationParameter.getPathStringFromParameter)(queryParameter), serializerOptions);
                                if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null) {
                                    if (queryParameter.collectionFormat === (0, _queryCollectionFormat.QueryCollectionFormat).Multi) {
                                        if (queryParameterValue.length === 0) continue;
                                        else for(index in queryParameterValue){
                                            item = queryParameterValue[index];
                                            queryParameterValue[index] = item === undefined || item === null ? "" : item.toString();
                                        }
                                    } else if (queryParameter.collectionFormat === (0, _queryCollectionFormat.QueryCollectionFormat).Ssv || queryParameter.collectionFormat === (0, _queryCollectionFormat.QueryCollectionFormat).Tsv) queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                                }
                                if (!queryParameter.skipEncoding) {
                                    if (Array.isArray(queryParameterValue)) {
                                        for(index in queryParameterValue)if (queryParameterValue[index] !== undefined && queryParameterValue[index] !== null) queryParameterValue[index] = encodeURIComponent(queryParameterValue[index]);
                                    } else queryParameterValue = encodeURIComponent(queryParameterValue);
                                }
                                if (queryParameter.collectionFormat !== undefined && queryParameter.collectionFormat !== null && queryParameter.collectionFormat !== (0, _queryCollectionFormat.QueryCollectionFormat).Multi && queryParameter.collectionFormat !== (0, _queryCollectionFormat.QueryCollectionFormat).Ssv && queryParameter.collectionFormat !== (0, _queryCollectionFormat.QueryCollectionFormat).Tsv) queryParameterValue = queryParameterValue.join(queryParameter.collectionFormat);
                                requestUrl.setQueryParameter(queryParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(queryParameter), queryParameterValue);
                            }
                        }
                        httpRequest.url = requestUrl.toString();
                        contentType = operationSpec.contentType || this.requestContentType;
                        if (contentType && operationSpec.requestBody) httpRequest.headers.set("Content-Type", contentType);
                        if (operationSpec.headerParameters) for(_e = 0, _f = operationSpec.headerParameters; _e < _f.length; _e++){
                            headerParameter = _f[_e];
                            headerValue = getOperationArgumentValueFromParameter(this, operationArguments, headerParameter, operationSpec.serializer);
                            if (headerValue !== undefined && headerValue !== null) {
                                headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, (0, _operationParameter.getPathStringFromParameter)(headerParameter), serializerOptions);
                                headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
                                if (headerCollectionPrefix) for(_g = 0, _h = Object.keys(headerValue); _g < _h.length; _g++){
                                    key = _h[_g];
                                    httpRequest.headers.set(headerCollectionPrefix + key, headerValue[key]);
                                }
                                else httpRequest.headers.set(headerParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(headerParameter), headerValue);
                            }
                        }
                        options = operationArguments.options;
                        if (options) {
                            if (options.customHeaders) for(customHeaderName in options.customHeaders)httpRequest.headers.set(customHeaderName, options.customHeaders[customHeaderName]);
                            if (options.abortSignal) httpRequest.abortSignal = options.abortSignal;
                            if (options.timeout) httpRequest.timeout = options.timeout;
                            if (options.onUploadProgress) httpRequest.onUploadProgress = options.onUploadProgress;
                            if (options.onDownloadProgress) httpRequest.onDownloadProgress = options.onDownloadProgress;
                            if (options.spanOptions) httpRequest.spanOptions = options.spanOptions;
                            if (options.tracingContext) httpRequest.tracingContext = options.tracingContext;
                            if (options.shouldDeserialize !== undefined && options.shouldDeserialize !== null) httpRequest.shouldDeserialize = options.shouldDeserialize;
                        }
                        httpRequest.withCredentials = this._withCredentials;
                        serializeRequestBody(this, httpRequest, operationArguments, operationSpec);
                        if (httpRequest.streamResponseStatusCodes === undefined) httpRequest.streamResponseStatusCodes = (0, _operationSpec.getStreamResponseStatusCodes)(operationSpec);
                        rawResponse = void 0;
                        sendRequestError = void 0;
                        _j.label = 2;
                    case 2:
                        _j.trys.push([
                            2,
                            4,
                            ,
                            5
                        ]);
                        return [
                            4 /*yield*/ ,
                            this.sendRequest(httpRequest)
                        ];
                    case 3:
                        rawResponse = _j.sent();
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 4:
                        error_1 = _j.sent();
                        sendRequestError = error_1;
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 5:
                        if (sendRequestError) {
                            if (sendRequestError.response) sendRequestError.details = flattenResponse(sendRequestError.response, operationSpec.responses[sendRequestError.statusCode] || operationSpec.responses["default"]);
                            result = Promise.reject(sendRequestError);
                        } else result = Promise.resolve(flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]));
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 6:
                        error_2 = _j.sent();
                        result = Promise.reject(error_2);
                        return [
                            3 /*break*/ ,
                            7
                        ];
                    case 7:
                        cb = callback;
                        if (cb) result.then(function(res) {
                            return cb(null, res._response.parsedBody, res._response.request, res._response);
                        }).catch(function(err) {
                            return cb(err);
                        });
                        return [
                            2 /*return*/ ,
                            result
                        ];
                }
            });
        });
    };
    return ServiceClient;
}();
function serializeRequestBody(serviceClient, httpRequest, operationArguments, operationSpec) {
    var _a, _b, _c, _d, _e, _f;
    var serializerOptions = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions) !== null && _b !== void 0 ? _b : {};
    var updatedOptions = {
        rootName: (_c = serializerOptions.rootName) !== null && _c !== void 0 ? _c : "",
        includeRoot: (_d = serializerOptions.includeRoot) !== null && _d !== void 0 ? _d : false,
        xmlCharKey: (_e = serializerOptions.xmlCharKey) !== null && _e !== void 0 ? _e : (0, _serializerCommon.XML_CHARKEY)
    };
    var xmlCharKey = serializerOptions.xmlCharKey;
    if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
        httpRequest.body = getOperationArgumentValueFromParameter(serviceClient, operationArguments, operationSpec.requestBody, operationSpec.serializer);
        var bodyMapper = operationSpec.requestBody.mapper;
        var required = bodyMapper.required, xmlName = bodyMapper.xmlName, xmlElementName = bodyMapper.xmlElementName, serializedName = bodyMapper.serializedName, xmlNamespace = bodyMapper.xmlNamespace, xmlNamespacePrefix = bodyMapper.xmlNamespacePrefix;
        var typeName = bodyMapper.type.name;
        try {
            if (httpRequest.body !== undefined && httpRequest.body !== null || required) {
                var requestBodyParameterPathString = (0, _operationParameter.getPathStringFromParameter)(operationSpec.requestBody);
                httpRequest.body = operationSpec.serializer.serialize(bodyMapper, httpRequest.body, requestBodyParameterPathString, updatedOptions);
                var isStream = typeName === (0, _serializer.MapperType).Stream;
                if (operationSpec.isXML) {
                    var xmlnsKey = xmlNamespacePrefix ? "xmlns:" + xmlNamespacePrefix : "xmlns";
                    var value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, httpRequest.body, updatedOptions);
                    if (typeName === (0, _serializer.MapperType).Sequence) httpRequest.body = (0, _xml.stringifyXML)(_utils.prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), {
                        rootName: xmlName || serializedName,
                        xmlCharKey: xmlCharKey
                    });
                    else if (!isStream) httpRequest.body = (0, _xml.stringifyXML)(value, {
                        rootName: xmlName || serializedName,
                        xmlCharKey: xmlCharKey
                    });
                } else if (typeName === (0, _serializer.MapperType).String && (((_f = operationSpec.contentType) === null || _f === void 0 ? void 0 : _f.match("text/plain")) || operationSpec.mediaType === "text")) // the String serializer has validated that request body is a string
                // so just send the string.
                return;
                else if (!isStream) httpRequest.body = JSON.stringify(httpRequest.body);
            }
        } catch (error) {
            throw new Error("Error \"" + error.message + "\" occurred in serializing the payload - " + JSON.stringify(serializedName, undefined, "  ") + ".");
        }
    } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
        httpRequest.formData = {};
        for(var _i = 0, _g = operationSpec.formDataParameters; _i < _g.length; _i++){
            var formDataParameter = _g[_i];
            var formDataParameterValue = getOperationArgumentValueFromParameter(serviceClient, operationArguments, formDataParameter, operationSpec.serializer);
            if (formDataParameterValue !== undefined && formDataParameterValue !== null) {
                var formDataParameterPropertyName = formDataParameter.mapper.serializedName || (0, _operationParameter.getPathStringFromParameter)(formDataParameter);
                httpRequest.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, (0, _operationParameter.getPathStringFromParameter)(formDataParameter), updatedOptions);
            }
        }
    }
}
/**
 * Adds an xml namespace to the xml serialized object if needed, otherwise it just returns the value itself
 */ function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
    var _a;
    // Composite and Sequence schemas already got their root namespace set during serialization
    // We just need to add xmlns to the other schema types
    if (xmlNamespace && ![
        "Composite",
        "Sequence",
        "Dictionary"
    ].includes(typeName)) {
        var result = {};
        result[options.xmlCharKey] = serializedValue;
        result[0, _serializerCommon.XML_ATTRKEY] = (_a = {}, _a[xmlnsKey] = xmlNamespace, _a);
        return result;
    }
    return serializedValue;
}
function getValueOrFunctionResult(value, defaultValueCreator) {
    var result;
    if (typeof value === "string") result = value;
    else {
        result = defaultValueCreator();
        if (typeof value === "function") result = value(result);
    }
    return result;
}
function createDefaultRequestPolicyFactories(authPolicyFactory, options) {
    var factories = [];
    if (options.generateClientRequestIdHeader) factories.push((0, _generateClientRequestIdPolicy.generateClientRequestIdPolicy)(options.clientRequestIdHeaderName));
    if (authPolicyFactory) factories.push(authPolicyFactory);
    var userAgentHeaderName = getValueOrFunctionResult(options.userAgentHeaderName, (0, _userAgentPolicy.getDefaultUserAgentHeaderName));
    var userAgentHeaderValue = getValueOrFunctionResult(options.userAgent, (0, _userAgentPolicy.getDefaultUserAgentValue));
    if (userAgentHeaderName && userAgentHeaderValue) factories.push((0, _userAgentPolicy.userAgentPolicy)({
        key: userAgentHeaderName,
        value: userAgentHeaderValue
    }));
    factories.push((0, _redirectPolicy.redirectPolicy)());
    factories.push((0, _rpRegistrationPolicy.rpRegistrationPolicy)(options.rpRegistrationRetryTimeout));
    if (!options.noRetryPolicy) {
        factories.push((0, _exponentialRetryPolicy.exponentialRetryPolicy)());
        factories.push((0, _systemErrorRetryPolicy.systemErrorRetryPolicy)());
        factories.push((0, _throttlingRetryPolicy.throttlingRetryPolicy)());
    }
    factories.push((0, _deserializationPolicy.deserializationPolicy)(options.deserializationContentTypes));
    if (0, _utils.isNode) factories.push((0, _proxyPolicy.proxyPolicy)(options.proxySettings));
    factories.push((0, _logPolicy.logPolicy)({
        logger: (0, _log.logger).info
    }));
    return factories;
}
function createPipelineFromOptions(pipelineOptions, authPolicyFactory) {
    var requestPolicyFactories = [];
    if (pipelineOptions.sendStreamingJson) requestPolicyFactories.push((0, _ndJsonPolicy.ndJsonPolicy)());
    var userAgentValue = undefined;
    if (pipelineOptions.userAgentOptions && pipelineOptions.userAgentOptions.userAgentPrefix) {
        var userAgentInfo = [];
        userAgentInfo.push(pipelineOptions.userAgentOptions.userAgentPrefix);
        // Add the default user agent value if it isn't already specified
        // by the userAgentPrefix option.
        var defaultUserAgentInfo = (0, _userAgentPolicy.getDefaultUserAgentValue)();
        if (userAgentInfo.indexOf(defaultUserAgentInfo) === -1) userAgentInfo.push(defaultUserAgentInfo);
        userAgentValue = userAgentInfo.join(" ");
    }
    var keepAliveOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _keepAlivePolicy.DefaultKeepAliveOptions)), pipelineOptions.keepAliveOptions);
    var retryOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _exponentialRetryPolicy.DefaultRetryOptions)), pipelineOptions.retryOptions);
    var redirectOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _redirectPolicy.DefaultRedirectOptions)), pipelineOptions.redirectOptions);
    if (0, _utils.isNode) requestPolicyFactories.push((0, _proxyPolicy.proxyPolicy)(pipelineOptions.proxyOptions));
    var deserializationOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, (0, _deserializationPolicy.DefaultDeserializationOptions)), pipelineOptions.deserializationOptions);
    var loggingOptions = (0, _tslib.__assign)({}, pipelineOptions.loggingOptions);
    requestPolicyFactories.push((0, _tracingPolicy.tracingPolicy)({
        userAgent: userAgentValue
    }), (0, _keepAlivePolicy.keepAlivePolicy)(keepAliveOptions), (0, _userAgentPolicy.userAgentPolicy)({
        value: userAgentValue
    }), (0, _generateClientRequestIdPolicy.generateClientRequestIdPolicy)(), (0, _deserializationPolicy.deserializationPolicy)(deserializationOptions.expectedContentTypes), (0, _throttlingRetryPolicy.throttlingRetryPolicy)(), (0, _systemErrorRetryPolicy.systemErrorRetryPolicy)(), (0, _exponentialRetryPolicy.exponentialRetryPolicy)(retryOptions.maxRetries, retryOptions.retryDelayInMs, retryOptions.maxRetryDelayInMs));
    if (redirectOptions.handleRedirects) requestPolicyFactories.push((0, _redirectPolicy.redirectPolicy)(redirectOptions.maxRetries));
    if (authPolicyFactory) requestPolicyFactories.push(authPolicyFactory);
    requestPolicyFactories.push((0, _logPolicy.logPolicy)(loggingOptions));
    if ((0, _utils.isNode) && pipelineOptions.decompressResponse === false) requestPolicyFactories.push((0, _disableResponseDecompressionPolicy.disableResponseDecompressionPolicy)());
    return {
        httpClient: pipelineOptions.httpClient,
        requestPolicyFactories: requestPolicyFactories
    };
}
function getPropertyParent(parent, propertyPath) {
    if (parent && propertyPath) {
        var propertyPathLength = propertyPath.length;
        for(var i = 0; i < propertyPathLength - 1; ++i){
            var propertyName = propertyPath[i];
            if (!parent[propertyName]) parent[propertyName] = {};
            parent = parent[propertyName];
        }
    }
    return parent;
}
function getOperationArgumentValueFromParameter(serviceClient, operationArguments, parameter, serializer) {
    return getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameter.parameterPath, parameter.mapper, serializer);
}
function getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, parameterPath, parameterMapper, serializer) {
    var _a;
    var value;
    if (typeof parameterPath === "string") parameterPath = [
        parameterPath
    ];
    var serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
    if (Array.isArray(parameterPath)) {
        if (parameterPath.length > 0) {
            if (parameterMapper.isConstant) value = parameterMapper.defaultValue;
            else {
                var propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
                if (!propertySearchResult.propertyFound) propertySearchResult = getPropertyFromParameterPath(serviceClient, parameterPath);
                var useDefaultValue = false;
                if (!propertySearchResult.propertyFound) useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
            }
            // Serialize just for validation purposes.
            var parameterPathString = (0, _operationParameter.getPathStringFromParameterPath)(parameterPath, parameterMapper);
            serializer.serialize(parameterMapper, value, parameterPathString, serializerOptions);
        }
    } else {
        if (parameterMapper.required) value = {};
        for(var propertyName in parameterPath){
            var propertyMapper = parameterMapper.type.modelProperties[propertyName];
            var propertyPath = parameterPath[propertyName];
            var propertyValue = getOperationArgumentValueFromParameterPath(serviceClient, operationArguments, propertyPath, propertyMapper, serializer);
            // Serialize just for validation purposes.
            var propertyPathString = (0, _operationParameter.getPathStringFromParameterPath)(propertyPath, propertyMapper);
            serializer.serialize(propertyMapper, propertyValue, propertyPathString, serializerOptions);
            if (propertyValue !== undefined && propertyValue !== null) {
                if (!value) value = {};
                value[propertyName] = propertyValue;
            }
        }
    }
    return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
    var result = {
        propertyFound: false
    };
    var i = 0;
    for(; i < parameterPath.length; ++i){
        var parameterPathPart = parameterPath[i];
        // Make sure to check inherited properties too, so don't use hasOwnProperty().
        if (parent !== undefined && parent !== null && parameterPathPart in parent) parent = parent[parameterPathPart];
        else break;
    }
    if (i === parameterPath.length) {
        result.propertyValue = parent;
        result.propertyFound = true;
    }
    return result;
}
function flattenResponse(_response, responseSpec) {
    var parsedHeaders = _response.parsedHeaders;
    var bodyMapper = responseSpec && responseSpec.bodyMapper;
    var addOperationResponse = function(obj) {
        return Object.defineProperty(obj, "_response", {
            value: _response
        });
    };
    if (bodyMapper) {
        var typeName = bodyMapper.type.name;
        if (typeName === "Stream") return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), {
            blobBody: _response.blobBody,
            readableStreamBody: _response.readableStreamBody
        }));
        var modelProperties_1 = typeName === "Composite" && bodyMapper.type.modelProperties || {};
        var isPageableResponse = Object.keys(modelProperties_1).some(function(k) {
            return modelProperties_1[k].serializedName === "";
        });
        if (typeName === "Sequence" || isPageableResponse) {
            var arrayResponse = (0, _tslib.__spreadArray)([], _response.parsedBody || []);
            for(var _i = 0, _a = Object.keys(modelProperties_1); _i < _a.length; _i++){
                var key = _a[_i];
                if (modelProperties_1[key].serializedName) arrayResponse[key] = _response.parsedBody[key];
            }
            if (parsedHeaders) for(var _b = 0, _c = Object.keys(parsedHeaders); _b < _c.length; _b++){
                var key = _c[_b];
                arrayResponse[key] = parsedHeaders[key];
            }
            addOperationResponse(arrayResponse);
            return arrayResponse;
        }
        if (typeName === "Composite" || typeName === "Dictionary") return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), _response.parsedBody));
    }
    if (bodyMapper || _response.request.method === "HEAD" || _utils.isPrimitiveType(_response.parsedBody)) // primitive body types and HEAD booleans
    return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), {
        body: _response.parsedBody
    }));
    return addOperationResponse((0, _tslib.__assign)((0, _tslib.__assign)({}, parsedHeaders), _response.parsedBody));
}
function getCredentialScopes(options, baseUri) {
    if (options === null || options === void 0 ? void 0 : options.credentialScopes) {
        var scopes = options.credentialScopes;
        return Array.isArray(scopes) ? scopes.map(function(scope) {
            return new (0, _url.URL)(scope).toString();
        }) : new (0, _url.URL)(scopes).toString();
    }
    if (baseUri) return baseUri + "/.default";
    return undefined;
}

},{"tslib":"iC1Dx","@azure/core-auth":"nCqHG","./policies/logPolicy":"aJgvb","./operationParameter":"f55ct","./operationSpec":"dFmM7","./policies/deserializationPolicy":"3LuMW","./policies/exponentialRetryPolicy":"2RHu1","./policies/generateClientRequestIdPolicy":"h0Glf","./policies/userAgentPolicy":"hPQrK","./policies/redirectPolicy":"fPfUj","./policies/requestPolicy":"hwRyd","./policies/rpRegistrationPolicy":"aa6Ix","./policies/bearerTokenAuthenticationPolicy":"d1DQw","./policies/systemErrorRetryPolicy":"9Dfm1","./queryCollectionFormat":"fFmLI","./serializer":"4pdUf","./url":"6ht7o","./util/utils":"3ok7s","./util/xml":"bNo0R","./webResource":"77t2g","./policies/proxyPolicy":"5pJXW","./policies/throttlingRetryPolicy":"cYNpY","./policies/signingPolicy":"gFY9S","./log":"bojeI","./policies/keepAlivePolicy":"4ufUI","./policies/tracingPolicy":"9BOvG","./policies/disableResponseDecompressionPolicy":"o23vK","./policies/ndJsonPolicy":"3S1Dv","./util/serializer.common":"1KFRt","./httpClientCache":"c3XKl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"nCqHG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AzureKeyCredential", ()=>(0, _azureKeyCredentialJs.AzureKeyCredential));
parcelHelpers.export(exports, "isKeyCredential", ()=>(0, _keyCredentialJs.isKeyCredential));
parcelHelpers.export(exports, "AzureNamedKeyCredential", ()=>(0, _azureNamedKeyCredentialJs.AzureNamedKeyCredential));
parcelHelpers.export(exports, "isNamedKeyCredential", ()=>(0, _azureNamedKeyCredentialJs.isNamedKeyCredential));
parcelHelpers.export(exports, "AzureSASCredential", ()=>(0, _azureSASCredentialJs.AzureSASCredential));
parcelHelpers.export(exports, "isSASCredential", ()=>(0, _azureSASCredentialJs.isSASCredential));
parcelHelpers.export(exports, "isTokenCredential", ()=>(0, _tokenCredentialJs.isTokenCredential));
var _azureKeyCredentialJs = require("./azureKeyCredential.js");
var _keyCredentialJs = require("./keyCredential.js");
var _azureNamedKeyCredentialJs = require("./azureNamedKeyCredential.js");
var _azureSASCredentialJs = require("./azureSASCredential.js");
var _tokenCredentialJs = require("./tokenCredential.js");

},{"./azureKeyCredential.js":"1d0cN","./keyCredential.js":"fvUFo","./azureNamedKeyCredential.js":"12TbF","./azureSASCredential.js":"4ZYs1","./tokenCredential.js":"h7pe1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1d0cN":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * A static-key-based credential that supports updating
 * the underlying key value.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AzureKeyCredential", ()=>AzureKeyCredential);
class AzureKeyCredential {
    /**
     * The value of the key to be used in authentication
     */ get key() {
        return this._key;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newKey - The new key value to be used
     */ update(newKey) {
        this._key = newKey;
    }
    /**
     * Create an instance of an AzureKeyCredential for use
     * with a service client.
     *
     * @param key - The initial value of the key to use in authentication
     */ constructor(key){
        if (!key) throw new Error("key must be a non-empty string");
        this._key = key;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fvUFo":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Tests an object to determine whether it implements KeyCredential.
 *
 * @param credential - The assumed KeyCredential to be tested.
 */ parcelHelpers.export(exports, "isKeyCredential", ()=>isKeyCredential);
var _coreUtil = require("@azure/core-util");
function isKeyCredential(credential) {
    return (0, _coreUtil.isObjectWithProperties)(credential, [
        "key"
    ]) && typeof credential.key === "string";
}

},{"@azure/core-util":"f9CIf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f9CIf":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "delay", ()=>(0, _delayJs.delay));
parcelHelpers.export(exports, "calculateRetryDelay", ()=>(0, _delayJs.calculateRetryDelay));
parcelHelpers.export(exports, "cancelablePromiseRace", ()=>(0, _aborterUtilsJs.cancelablePromiseRace));
parcelHelpers.export(exports, "createAbortablePromise", ()=>(0, _createAbortablePromiseJs.createAbortablePromise));
parcelHelpers.export(exports, "getRandomIntegerInclusive", ()=>(0, _randomJs.getRandomIntegerInclusive));
parcelHelpers.export(exports, "isObject", ()=>(0, _objectJs.isObject));
parcelHelpers.export(exports, "isError", ()=>(0, _errorJs.isError));
parcelHelpers.export(exports, "getErrorMessage", ()=>(0, _errorJs.getErrorMessage));
parcelHelpers.export(exports, "computeSha256Hash", ()=>(0, _sha256Js.computeSha256Hash));
parcelHelpers.export(exports, "computeSha256Hmac", ()=>(0, _sha256Js.computeSha256Hmac));
parcelHelpers.export(exports, "isDefined", ()=>(0, _typeGuardsJs.isDefined));
parcelHelpers.export(exports, "isObjectWithProperties", ()=>(0, _typeGuardsJs.isObjectWithProperties));
parcelHelpers.export(exports, "objectHasProperty", ()=>(0, _typeGuardsJs.objectHasProperty));
parcelHelpers.export(exports, "randomUUID", ()=>(0, _uuidUtilsJs.randomUUID));
parcelHelpers.export(exports, "isBrowser", ()=>(0, _checkEnvironmentJs.isBrowser));
parcelHelpers.export(exports, "isBun", ()=>(0, _checkEnvironmentJs.isBun));
parcelHelpers.export(exports, "isNode", ()=>(0, _checkEnvironmentJs.isNode));
parcelHelpers.export(exports, "isNodeLike", ()=>(0, _checkEnvironmentJs.isNodeLike));
parcelHelpers.export(exports, "isNodeRuntime", ()=>(0, _checkEnvironmentJs.isNodeRuntime));
parcelHelpers.export(exports, "isDeno", ()=>(0, _checkEnvironmentJs.isDeno));
parcelHelpers.export(exports, "isReactNative", ()=>(0, _checkEnvironmentJs.isReactNative));
parcelHelpers.export(exports, "isWebWorker", ()=>(0, _checkEnvironmentJs.isWebWorker));
parcelHelpers.export(exports, "uint8ArrayToString", ()=>(0, _bytesEncodingJs.uint8ArrayToString));
parcelHelpers.export(exports, "stringToUint8Array", ()=>(0, _bytesEncodingJs.stringToUint8Array));
var _delayJs = require("./delay.js");
var _aborterUtilsJs = require("./aborterUtils.js");
var _createAbortablePromiseJs = require("./createAbortablePromise.js");
var _randomJs = require("./random.js");
var _objectJs = require("./object.js");
var _errorJs = require("./error.js");
var _sha256Js = require("./sha256.js");
var _typeGuardsJs = require("./typeGuards.js");
var _uuidUtilsJs = require("./uuidUtils.js");
var _checkEnvironmentJs = require("./checkEnvironment.js");
var _bytesEncodingJs = require("./bytesEncoding.js");

},{"./delay.js":"d1baW","./aborterUtils.js":"6ilR8","./createAbortablePromise.js":"aeHwO","./random.js":"ctFHj","./object.js":"4bT1O","./error.js":"683qF","./sha256.js":"9hG5k","./typeGuards.js":"d0jjf","./uuidUtils.js":"iQEeZ","./checkEnvironment.js":"klGYR","./bytesEncoding.js":"8mt4b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d1baW":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A wrapper for setTimeout that resolves a promise after timeInMs milliseconds.
 * @param timeInMs - The number of milliseconds to be delayed.
 * @param options - The options for delay - currently abort options
 * @returns Promise that is resolved after timeInMs
 */ parcelHelpers.export(exports, "delay", ()=>delay);
/**
 * Calculates the delay interval for retry attempts using exponential delay with jitter.
 * @param retryAttempt - The current retry attempt number.
 * @param config - The exponential retry configuration.
 * @returns An object containing the calculated retry delay.
 */ parcelHelpers.export(exports, "calculateRetryDelay", ()=>calculateRetryDelay);
var _createAbortablePromiseJs = require("./createAbortablePromise.js");
var _randomJs = require("./random.js");
const StandardAbortMessage = "The delay was aborted.";
function delay(timeInMs, options) {
    let token;
    const { abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
    return (0, _createAbortablePromiseJs.createAbortablePromise)((resolve)=>{
        token = setTimeout(resolve, timeInMs);
    }, {
        cleanupBeforeAbort: ()=>clearTimeout(token),
        abortSignal,
        abortErrorMsg: abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : StandardAbortMessage
    });
}
function calculateRetryDelay(retryAttempt, config) {
    // Exponentially increase the delay each time
    const exponentialDelay = config.retryDelayInMs * Math.pow(2, retryAttempt);
    // Don't let the delay exceed the maximum
    const clampedDelay = Math.min(config.maxRetryDelayInMs, exponentialDelay);
    // Allow the final value to have some "jitter" (within 50% of the delay size) so
    // that retries across multiple clients don't occur simultaneously.
    const retryAfterInMs = clampedDelay / 2 + (0, _randomJs.getRandomIntegerInclusive)(0, clampedDelay / 2);
    return {
        retryAfterInMs
    };
}

},{"./createAbortablePromise.js":"aeHwO","./random.js":"ctFHj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aeHwO":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates an abortable promise.
 * @param buildPromise - A function that takes the resolve and reject functions as parameters.
 * @param options - The options for the abortable promise.
 * @returns A promise that can be aborted.
 */ parcelHelpers.export(exports, "createAbortablePromise", ()=>createAbortablePromise);
var _abortController = require("@azure/abort-controller");
function createAbortablePromise(buildPromise, options) {
    const { cleanupBeforeAbort, abortSignal, abortErrorMsg } = options !== null && options !== void 0 ? options : {};
    return new Promise((resolve, reject)=>{
        function rejectOnAbort() {
            reject(new (0, _abortController.AbortError)(abortErrorMsg !== null && abortErrorMsg !== void 0 ? abortErrorMsg : "The operation was aborted."));
        }
        function removeListeners() {
            abortSignal === null || abortSignal === void 0 || abortSignal.removeEventListener("abort", onAbort);
        }
        function onAbort() {
            cleanupBeforeAbort === null || cleanupBeforeAbort === void 0 || cleanupBeforeAbort();
            removeListeners();
            rejectOnAbort();
        }
        if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) return rejectOnAbort();
        try {
            buildPromise((x)=>{
                removeListeners();
                resolve(x);
            }, (x)=>{
                removeListeners();
                reject(x);
            });
        } catch (err) {
            reject(err);
        }
        abortSignal === null || abortSignal === void 0 || abortSignal.addEventListener("abort", onAbort);
    });
}

},{"@azure/abort-controller":"eji5O","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eji5O":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortError", ()=>(0, _abortErrorJs.AbortError));
var _abortErrorJs = require("./AbortError.js");

},{"./AbortError.js":"jgn7P","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jgn7P":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * This error is thrown when an asynchronous operation has been aborted.
 * Check for this error by testing the `name` that the name property of the
 * error matches `"AbortError"`.
 *
 * @example
 * ```ts
 * const controller = new AbortController();
 * controller.abort();
 * try {
 *   doAsyncWork(controller.signal)
 * } catch (e) {
 *   if (e.name === 'AbortError') {
 *     // handle abort error here.
 *   }
 * }
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbortError", ()=>AbortError);
class AbortError extends Error {
    constructor(message){
        super(message);
        this.name = "AbortError";
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ctFHj":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Returns a random integer value between a lower and upper bound,
 * inclusive of both bounds.
 * Note that this uses Math.random and isn't secure. If you need to use
 * this for any kind of security purpose, find a better source of random.
 * @param min - The smallest integer value allowed.
 * @param max - The largest integer value allowed.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRandomIntegerInclusive", ()=>getRandomIntegerInclusive);
function getRandomIntegerInclusive(min, max) {
    // Make sure inputs are integers.
    min = Math.ceil(min);
    max = Math.floor(max);
    // Pick a random offset from zero to the size of the range.
    // Since Math.random() can never return 1, we have to make the range one larger
    // in order to be inclusive of the maximum value after we take the floor.
    const offset = Math.floor(Math.random() * (max - min + 1));
    return offset + min;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6ilR8":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * promise.race() wrapper that aborts rest of promises as soon as the first promise settles.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cancelablePromiseRace", ()=>cancelablePromiseRace);
async function cancelablePromiseRace(abortablePromiseBuilders, options) {
    var _a, _b;
    const aborter = new AbortController();
    function abortHandler() {
        aborter.abort();
    }
    (_a = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _a === void 0 || _a.addEventListener("abort", abortHandler);
    try {
        return await Promise.race(abortablePromiseBuilders.map((p)=>p({
                abortSignal: aborter.signal
            })));
    } finally{
        aborter.abort();
        (_b = options === null || options === void 0 ? void 0 : options.abortSignal) === null || _b === void 0 || _b.removeEventListener("abort", abortHandler);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4bT1O":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Helper to determine when an input is a generic JS object.
 * @returns true when input is an object type that is not null, Array, RegExp, or Date.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isObject", ()=>isObject);
function isObject(input) {
    return typeof input === "object" && input !== null && !Array.isArray(input) && !(input instanceof RegExp) && !(input instanceof Date);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"683qF":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Typeguard for an error object shape (has name and message)
 * @param e - Something caught by a catch clause.
 */ parcelHelpers.export(exports, "isError", ()=>isError);
/**
 * Given what is thought to be an error object, return the message if possible.
 * If the message is missing, returns a stringified version of the input.
 * @param e - Something thrown from a try block
 * @returns The error message or a string of the input
 */ parcelHelpers.export(exports, "getErrorMessage", ()=>getErrorMessage);
var _objectJs = require("./object.js");
function isError(e) {
    if ((0, _objectJs.isObject)(e)) {
        const hasName = typeof e.name === "string";
        const hasMessage = typeof e.message === "string";
        return hasName && hasMessage;
    }
    return false;
}
function getErrorMessage(e) {
    if (isError(e)) return e.message;
    else {
        let stringified;
        try {
            if (typeof e === "object" && e) stringified = JSON.stringify(e);
            else stringified = String(e);
        } catch (err) {
            stringified = "[unable to stringify input]";
        }
        return `Unknown error ${stringified}`;
    }
}

},{"./object.js":"4bT1O","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9hG5k":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _sha256CommonJs = require("./sha256.common.js");
parcelHelpers.exportAll(_sha256CommonJs, exports);

},{"./sha256.common.js":"a3gD5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a3gD5":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Generates a SHA-256 HMAC signature.
 * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.
 * @param stringToSign - The data to be signed.
 * @param encoding - The textual encoding to use for the returned HMAC digest.
 */ parcelHelpers.export(exports, "computeSha256Hmac", ()=>computeSha256Hmac);
/**
 * Generates a SHA-256 hash.
 * @param content - The data to be included in the hash.
 * @param encoding - The textual encoding to use for the returned hash.
 */ parcelHelpers.export(exports, "computeSha256Hash", ()=>computeSha256Hash);
var _bytesEncodingJs = require("./bytesEncoding.js");
let subtleCrypto;
/**
 * Returns a cached reference to the Web API crypto.subtle object.
 * @internal
 */ function getCrypto() {
    if (subtleCrypto) return subtleCrypto;
    if (!self.crypto || !self.crypto.subtle) throw new Error("Your browser environment does not support cryptography functions.");
    subtleCrypto = self.crypto.subtle;
    return subtleCrypto;
}
async function computeSha256Hmac(key, stringToSign, encoding) {
    const crypto = getCrypto();
    const keyBytes = (0, _bytesEncodingJs.stringToUint8Array)(key, "base64");
    const stringToSignBytes = (0, _bytesEncodingJs.stringToUint8Array)(stringToSign, "utf-8");
    const cryptoKey = await crypto.importKey("raw", keyBytes, {
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, false, [
        "sign"
    ]);
    const signature = await crypto.sign({
        name: "HMAC",
        hash: {
            name: "SHA-256"
        }
    }, cryptoKey, stringToSignBytes);
    return (0, _bytesEncodingJs.uint8ArrayToString)(new Uint8Array(signature), encoding);
}
async function computeSha256Hash(content, encoding) {
    const contentBytes = (0, _bytesEncodingJs.stringToUint8Array)(content, "utf-8");
    const digest = await getCrypto().digest({
        name: "SHA-256"
    }, contentBytes);
    return (0, _bytesEncodingJs.uint8ArrayToString)(new Uint8Array(digest), encoding);
}

},{"./bytesEncoding.js":"8mt4b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8mt4b":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bytesEncodingCommonJs = require("./bytesEncoding.common.js");
parcelHelpers.exportAll(_bytesEncodingCommonJs, exports);

},{"./bytesEncoding.common.js":"89EA8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"89EA8":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * The helper that transforms bytes with specific character encoding into string
 * @param bytes - the uint8array bytes
 * @param format - the format we use to encode the byte
 * @returns a string of the encoded string
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uint8ArrayToString", ()=>uint8ArrayToString);
/**
 * The helper that transforms string to specific character encoded bytes array.
 * @param value - the string to be converted
 * @param format - the format we use to decode the value
 * @returns a uint8array
 */ parcelHelpers.export(exports, "stringToUint8Array", ()=>stringToUint8Array);
/**
 * Decodes a Uint8Array into a Base64 string.
 * @internal
 */ parcelHelpers.export(exports, "uint8ArrayToBase64", ()=>uint8ArrayToBase64);
/**
 * Decodes a Uint8Array into a Base64Url string.
 * @internal
 */ parcelHelpers.export(exports, "uint8ArrayToBase64Url", ()=>uint8ArrayToBase64Url);
/**
 * Decodes a Uint8Array into a javascript string.
 * @internal
 */ parcelHelpers.export(exports, "uint8ArrayToUtf8String", ()=>uint8ArrayToUtf8String);
/**
 * Decodes a Uint8Array into a hex string
 * @internal
 */ parcelHelpers.export(exports, "uint8ArrayToHexString", ()=>uint8ArrayToHexString);
/**
 * Encodes a JavaScript string into a Uint8Array.
 * @internal
 */ parcelHelpers.export(exports, "utf8StringToUint8Array", ()=>utf8StringToUint8Array);
/**
 * Encodes a Base64 string into a Uint8Array.
 * @internal
 */ parcelHelpers.export(exports, "base64ToUint8Array", ()=>base64ToUint8Array);
/**
 * Encodes a Base64Url string into a Uint8Array.
 * @internal
 */ parcelHelpers.export(exports, "base64UrlToUint8Array", ()=>base64UrlToUint8Array);
/**
 * Encodes a hex string into a Uint8Array
 * @internal
 */ parcelHelpers.export(exports, "hexStringToUint8Array", ()=>hexStringToUint8Array);
function uint8ArrayToString(bytes, format) {
    switch(format){
        case "utf-8":
            return uint8ArrayToUtf8String(bytes);
        case "base64":
            return uint8ArrayToBase64(bytes);
        case "base64url":
            return uint8ArrayToBase64Url(bytes);
        case "hex":
            return uint8ArrayToHexString(bytes);
    }
}
function stringToUint8Array(value, format) {
    switch(format){
        case "utf-8":
            return utf8StringToUint8Array(value);
        case "base64":
            return base64ToUint8Array(value);
        case "base64url":
            return base64UrlToUint8Array(value);
        case "hex":
            return hexStringToUint8Array(value);
    }
}
function uint8ArrayToBase64(bytes) {
    return btoa([
        ...bytes
    ].map((x)=>String.fromCharCode(x)).join(""));
}
function uint8ArrayToBase64Url(bytes) {
    return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function uint8ArrayToUtf8String(bytes) {
    const decoder = new TextDecoder();
    const dataString = decoder.decode(bytes);
    return dataString;
}
function uint8ArrayToHexString(bytes) {
    return [
        ...bytes
    ].map((x)=>x.toString(16).padStart(2, "0")).join("");
}
function utf8StringToUint8Array(value) {
    return new TextEncoder().encode(value);
}
function base64ToUint8Array(value) {
    return new Uint8Array([
        ...atob(value)
    ].map((x)=>x.charCodeAt(0)));
}
function base64UrlToUint8Array(value) {
    const base64String = value.replace(/-/g, "+").replace(/_/g, "/");
    return base64ToUint8Array(base64String);
}
const hexDigits = new Set("0123456789abcdefABCDEF");
function hexStringToUint8Array(value) {
    // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior
    const bytes = new Uint8Array(value.length / 2);
    for(let i = 0; i < value.length / 2; ++i){
        const highNibble = value[2 * i];
        const lowNibble = value[2 * i + 1];
        if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte
        return bytes.slice(0, i);
        bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);
    }
    return bytes;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d0jjf":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Helper TypeGuard that checks if something is defined or not.
 * @param thing - Anything
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isDefined", ()=>isDefined);
/**
 * Helper TypeGuard that checks if the input is an object with the specified properties.
 * @param thing - Anything.
 * @param properties - The name of the properties that should appear in the object.
 */ parcelHelpers.export(exports, "isObjectWithProperties", ()=>isObjectWithProperties);
/**
 * Helper TypeGuard that checks if the input is an object with the specified property.
 * @param thing - Any object.
 * @param property - The name of the property that should appear in the object.
 */ parcelHelpers.export(exports, "objectHasProperty", ()=>objectHasProperty);
function isDefined(thing) {
    return typeof thing !== "undefined" && thing !== null;
}
function isObjectWithProperties(thing, properties) {
    if (!isDefined(thing) || typeof thing !== "object") return false;
    for (const property of properties){
        if (!objectHasProperty(thing, property)) return false;
    }
    return true;
}
function objectHasProperty(thing, property) {
    return isDefined(thing) && typeof thing === "object" && property in thing;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iQEeZ":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 */ parcelHelpers.export(exports, "randomUUID", ()=>randomUUID);
var _uuidUtilsCommonJs = require("./uuidUtils.common.js");
var _a;
// NOTE: This could be undefined if not used in a secure context
const uuidFunction = typeof ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.randomUUID) === "function" ? globalThis.crypto.randomUUID.bind(globalThis.crypto) : (0, _uuidUtilsCommonJs.generateUUID);
function randomUUID() {
    return uuidFunction();
}

},{"./uuidUtils.common.js":"hqk9t","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hqk9t":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generateUUID", ()=>generateUUID);
/**
 * Generated Universally Unique Identifier
 *
 * @returns RFC4122 v4 UUID.
 */ parcelHelpers.export(exports, "randomUUID", ()=>randomUUID);
function generateUUID() {
    let uuid = "";
    for(let i = 0; i < 32; i++){
        // Generate a random number between 0 and 15
        const randomNumber = Math.floor(Math.random() * 16);
        // Set the UUID version to 4 in the 13th position
        if (i === 12) uuid += "4";
        else if (i === 16) // Set the UUID variant to "10" in the 17th position
        uuid += randomNumber & 0x3 | 0x8;
        else // Add a random hexadecimal digit to the UUID string
        uuid += randomNumber.toString(16);
        // Add hyphens to the UUID string at the appropriate positions
        if (i === 7 || i === 11 || i === 15 || i === 19) uuid += "-";
    }
    return uuid;
}
function randomUUID() {
    return generateUUID();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"klGYR":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "isWebWorker", ()=>isWebWorker);
parcelHelpers.export(exports, "isDeno", ()=>isDeno);
parcelHelpers.export(exports, "isBun", ()=>isBun);
parcelHelpers.export(exports, "isNodeLike", ()=>isNodeLike);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "isNodeRuntime", ()=>isNodeRuntime);
parcelHelpers.export(exports, "isReactNative", ()=>isReactNative);
var _a, _b, _c, _d;
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
const isWebWorker = typeof self === "object" && typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" && (((_a = self.constructor) === null || _a === void 0 ? void 0 : _a.name) === "DedicatedWorkerGlobalScope" || ((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "ServiceWorkerGlobalScope" || ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "SharedWorkerGlobalScope");
const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
const isNodeLike = typeof globalThis.process !== "undefined" && Boolean(globalThis.process.version) && Boolean((_d = globalThis.process.versions) === null || _d === void 0 ? void 0 : _d.node);
const isNode = isNodeLike;
const isNodeRuntime = isNodeLike && !isBun && !isDeno;
const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"12TbF":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A static name/key-based credential that supports updating
 * the underlying name and key values.
 */ parcelHelpers.export(exports, "AzureNamedKeyCredential", ()=>AzureNamedKeyCredential);
/**
 * Tests an object to determine whether it implements NamedKeyCredential.
 *
 * @param credential - The assumed NamedKeyCredential to be tested.
 */ parcelHelpers.export(exports, "isNamedKeyCredential", ()=>isNamedKeyCredential);
var _coreUtil = require("@azure/core-util");
class AzureNamedKeyCredential {
    /**
     * The value of the key to be used in authentication.
     */ get key() {
        return this._key;
    }
    /**
     * The value of the name to be used in authentication.
     */ get name() {
        return this._name;
    }
    /**
     * Change the value of the key.
     *
     * Updates will take effect upon the next request after
     * updating the key value.
     *
     * @param newName - The new name value to be used.
     * @param newKey - The new key value to be used.
     */ update(newName, newKey) {
        if (!newName || !newKey) throw new TypeError("newName and newKey must be non-empty strings");
        this._name = newName;
        this._key = newKey;
    }
    /**
     * Create an instance of an AzureNamedKeyCredential for use
     * with a service client.
     *
     * @param name - The initial value of the name to use in authentication.
     * @param key - The initial value of the key to use in authentication.
     */ constructor(name, key){
        if (!name || !key) throw new TypeError("name and key must be non-empty strings");
        this._name = name;
        this._key = key;
    }
}
function isNamedKeyCredential(credential) {
    return (0, _coreUtil.isObjectWithProperties)(credential, [
        "name",
        "key"
    ]) && typeof credential.key === "string" && typeof credential.name === "string";
}

},{"@azure/core-util":"f9CIf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4ZYs1":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A static-signature-based credential that supports updating
 * the underlying signature value.
 */ parcelHelpers.export(exports, "AzureSASCredential", ()=>AzureSASCredential);
/**
 * Tests an object to determine whether it implements SASCredential.
 *
 * @param credential - The assumed SASCredential to be tested.
 */ parcelHelpers.export(exports, "isSASCredential", ()=>isSASCredential);
var _coreUtil = require("@azure/core-util");
class AzureSASCredential {
    /**
     * The value of the shared access signature to be used in authentication
     */ get signature() {
        return this._signature;
    }
    /**
     * Change the value of the signature.
     *
     * Updates will take effect upon the next request after
     * updating the signature value.
     *
     * @param newSignature - The new shared access signature value to be used
     */ update(newSignature) {
        if (!newSignature) throw new Error("shared access signature must be a non-empty string");
        this._signature = newSignature;
    }
    /**
     * Create an instance of an AzureSASCredential for use
     * with a service client.
     *
     * @param signature - The initial value of the shared access signature to use in authentication
     */ constructor(signature){
        if (!signature) throw new Error("shared access signature must be a non-empty string");
        this._signature = signature;
    }
}
function isSASCredential(credential) {
    return (0, _coreUtil.isObjectWithProperties)(credential, [
        "signature"
    ]) && typeof credential.signature === "string";
}

},{"@azure/core-util":"f9CIf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h7pe1":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * @internal
 * @param accessToken - Access token
 * @returns Whether a token is bearer type or not
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBearerToken", ()=>isBearerToken);
/**
 * @internal
 * @param accessToken - Access token
 * @returns Whether a token is Pop token or not
 */ parcelHelpers.export(exports, "isPopToken", ()=>isPopToken);
/**
 * Tests an object to determine whether it implements TokenCredential.
 *
 * @param credential - The assumed TokenCredential to be tested.
 */ parcelHelpers.export(exports, "isTokenCredential", ()=>isTokenCredential);
function isBearerToken(accessToken) {
    return !accessToken.tokenType || accessToken.tokenType === "Bearer";
}
function isPopToken(accessToken) {
    return accessToken.tokenType === "pop";
}
function isTokenCredential(credential) {
    // Check for an object with a 'getToken' function and possibly with
    // a 'signRequest' function.  We do this check to make sure that
    // a ServiceClientCredentials implementor (like TokenClientCredentials
    // in ms-rest-nodeauth) doesn't get mistaken for a TokenCredential if
    // it doesn't actually implement TokenCredential also.
    const castCredential = credential;
    return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === undefined || castCredential.getToken.length > 0);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aJgvb":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logPolicy", ()=>logPolicy);
parcelHelpers.export(exports, "LogPolicy", ()=>LogPolicy);
var _tslib = require("tslib");
var _requestPolicy = require("./requestPolicy");
var _log = require("../log");
var _sanitizer = require("../util/sanitizer");
function logPolicy(loggingOptions) {
    if (loggingOptions === void 0) loggingOptions = {};
    return {
        create: function(nextPolicy, options) {
            return new LogPolicy(nextPolicy, options, loggingOptions);
        }
    };
}
var LogPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(LogPolicy, _super);
    function LogPolicy(nextPolicy, options, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.logger, logger = _c === void 0 ? (0, _log.logger).info : _c, _d = _b.allowedHeaderNames, allowedHeaderNames = _d === void 0 ? [] : _d, _e = _b.allowedQueryParameters, allowedQueryParameters = _e === void 0 ? [] : _e;
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.logger = logger;
        _this.sanitizer = new (0, _sanitizer.Sanitizer)({
            allowedHeaderNames: allowedHeaderNames,
            allowedQueryParameters: allowedQueryParameters
        });
        return _this;
    }
    Object.defineProperty(LogPolicy.prototype, "allowedHeaderNames", {
        /**
         * Header names whose values will be logged when logging is enabled. Defaults to
         * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
         * specified in this field will be added to that list.  Any other values will
         * be written to logs as "REDACTED".
         * @deprecated Pass these into the constructor instead.
         */ get: function() {
            return this.sanitizer.allowedHeaderNames;
        },
        /**
         * Header names whose values will be logged when logging is enabled. Defaults to
         * Date, traceparent, x-ms-client-request-id, and x-ms-request id.  Any headers
         * specified in this field will be added to that list.  Any other values will
         * be written to logs as "REDACTED".
         * @deprecated Pass these into the constructor instead.
         */ set: function(allowedHeaderNames) {
            this.sanitizer.allowedHeaderNames = allowedHeaderNames;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(LogPolicy.prototype, "allowedQueryParameters", {
        /**
         * Query string names whose values will be logged when logging is enabled. By default no
         * query string values are logged.
         * @deprecated Pass these into the constructor instead.
         */ get: function() {
            return this.sanitizer.allowedQueryParameters;
        },
        /**
         * Query string names whose values will be logged when logging is enabled. By default no
         * query string values are logged.
         * @deprecated Pass these into the constructor instead.
         */ set: function(allowedQueryParameters) {
            this.sanitizer.allowedQueryParameters = allowedQueryParameters;
        },
        enumerable: false,
        configurable: true
    });
    LogPolicy.prototype.sendRequest = function(request) {
        var _this = this;
        if (!this.logger.enabled) return this._nextPolicy.sendRequest(request);
        this.logRequest(request);
        return this._nextPolicy.sendRequest(request).then(function(response) {
            return _this.logResponse(response);
        });
    };
    LogPolicy.prototype.logRequest = function(request) {
        this.logger("Request: " + this.sanitizer.sanitize(request));
    };
    LogPolicy.prototype.logResponse = function(response) {
        this.logger("Response status code: " + response.status);
        this.logger("Headers: " + this.sanitizer.sanitize(response.headers));
        return response;
    };
    return LogPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","../log":"bojeI","../util/sanitizer":"xc0Vd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hwRyd":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseRequestPolicy", ()=>BaseRequestPolicy);
parcelHelpers.export(exports, "RequestPolicyOptions", ()=>RequestPolicyOptions);
var _httpPipelineLogLevel = require("../httpPipelineLogLevel");
var BaseRequestPolicy = /** @class */ function() {
    function BaseRequestPolicy(_nextPolicy, _options) {
        this._nextPolicy = _nextPolicy;
        this._options = _options;
    }
    /**
     * Get whether or not a log with the provided log level should be logged.
     * @param logLevel - The log level of the log that will be logged.
     * @returns Whether or not a log with the provided log level should be logged.
     */ BaseRequestPolicy.prototype.shouldLog = function(logLevel) {
        return this._options.shouldLog(logLevel);
    };
    /**
     * Attempt to log the provided message to the provided logger. If no logger was provided or if
     * the log level does not meat the logger's threshold, then nothing will be logged.
     * @param logLevel - The log level of this log.
     * @param message - The message of this log.
     */ BaseRequestPolicy.prototype.log = function(logLevel, message) {
        this._options.log(logLevel, message);
    };
    return BaseRequestPolicy;
}();
/**
 * Optional properties that can be used when creating a RequestPolicy.
 */ var RequestPolicyOptions = /** @class */ function() {
    function RequestPolicyOptions(_logger) {
        this._logger = _logger;
    }
    /**
     * Get whether or not a log with the provided log level should be logged.
     * @param logLevel - The log level of the log that will be logged.
     * @returns Whether or not a log with the provided log level should be logged.
     */ RequestPolicyOptions.prototype.shouldLog = function(logLevel) {
        return !!this._logger && logLevel !== (0, _httpPipelineLogLevel.HttpPipelineLogLevel).OFF && logLevel <= this._logger.minimumLogLevel;
    };
    /**
     * Attempt to log the provided message to the provided logger. If no logger was provided or if
     * the log level does not meet the logger's threshold, then nothing will be logged.
     * @param logLevel - The log level of this log.
     * @param message - The message of this log.
     */ RequestPolicyOptions.prototype.log = function(logLevel, message) {
        if (this._logger && this.shouldLog(logLevel)) this._logger.log(logLevel, message);
    };
    return RequestPolicyOptions;
}();

},{"../httpPipelineLogLevel":"5X4Pz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bojeI":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "logger", ()=>logger);
var _logger = require("@azure/logger");
var logger = (0, _logger.createClientLogger)("core-http");

},{"@azure/logger":"fqZlH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f55ct":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Get the path to this parameter's value as a dotted string (a.b.c).
 * @param parameter - The parameter to get the path string for.
 * @returns The path to this parameter's value as a dotted string.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getPathStringFromParameter", ()=>getPathStringFromParameter);
parcelHelpers.export(exports, "getPathStringFromParameterPath", ()=>getPathStringFromParameterPath);
function getPathStringFromParameter(parameter) {
    return getPathStringFromParameterPath(parameter.parameterPath, parameter.mapper);
}
function getPathStringFromParameterPath(parameterPath, mapper) {
    var result;
    if (typeof parameterPath === "string") result = parameterPath;
    else if (Array.isArray(parameterPath)) result = parameterPath.join(".");
    else result = mapper.serializedName;
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dFmM7":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the list of status codes for streaming responses.
 * @internal
 */ parcelHelpers.export(exports, "getStreamResponseStatusCodes", ()=>getStreamResponseStatusCodes);
var _serializer = require("./serializer");
function getStreamResponseStatusCodes(operationSpec) {
    var result = new Set();
    for(var statusCode in operationSpec.responses){
        var operationResponse = operationSpec.responses[statusCode];
        if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === (0, _serializer.MapperType).Stream) result.add(Number(statusCode));
    }
    return result;
}

},{"./serializer":"4pdUf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3LuMW":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Create a new serialization RequestPolicyCreator that will serialized HTTP request bodies as they
 * pass through the HTTP pipeline.
 */ parcelHelpers.export(exports, "deserializationPolicy", ()=>deserializationPolicy);
parcelHelpers.export(exports, "defaultJsonContentTypes", ()=>defaultJsonContentTypes);
parcelHelpers.export(exports, "defaultXmlContentTypes", ()=>defaultXmlContentTypes);
parcelHelpers.export(exports, "DefaultDeserializationOptions", ()=>DefaultDeserializationOptions);
parcelHelpers.export(exports, "DeserializationPolicy", ()=>DeserializationPolicy);
parcelHelpers.export(exports, "deserializeResponseBody", ()=>deserializeResponseBody);
var _tslib = require("tslib");
var _restError = require("../restError");
var _serializer = require("../serializer");
var _xml = require("../util/xml");
var _requestPolicy = require("./requestPolicy");
var _serializerCommon = require("../util/serializer.common");
function deserializationPolicy(deserializationContentTypes, parsingOptions) {
    return {
        create: function(nextPolicy, options) {
            return new DeserializationPolicy(nextPolicy, options, deserializationContentTypes, parsingOptions);
        }
    };
}
var defaultJsonContentTypes = [
    "application/json",
    "text/json"
];
var defaultXmlContentTypes = [
    "application/xml",
    "application/atom+xml"
];
var DefaultDeserializationOptions = {
    expectedContentTypes: {
        json: defaultJsonContentTypes,
        xml: defaultXmlContentTypes
    }
};
/**
 * A RequestPolicy that will deserialize HTTP response bodies and headers as they pass through the
 * HTTP pipeline.
 */ var DeserializationPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(DeserializationPolicy, _super);
    function DeserializationPolicy(nextPolicy, requestPolicyOptions, deserializationContentTypes, parsingOptions) {
        if (parsingOptions === void 0) parsingOptions = {};
        var _a;
        var _this = _super.call(this, nextPolicy, requestPolicyOptions) || this;
        _this.jsonContentTypes = deserializationContentTypes && deserializationContentTypes.json || defaultJsonContentTypes;
        _this.xmlContentTypes = deserializationContentTypes && deserializationContentTypes.xml || defaultXmlContentTypes;
        _this.xmlCharKey = (_a = parsingOptions.xmlCharKey) !== null && _a !== void 0 ? _a : (0, _serializerCommon.XML_CHARKEY);
        return _this;
    }
    DeserializationPolicy.prototype.sendRequest = function(request) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            var _this = this;
            return (0, _tslib.__generator)(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this._nextPolicy.sendRequest(request).then(function(response) {
                        return deserializeResponseBody(_this.jsonContentTypes, _this.xmlContentTypes, response, {
                            xmlCharKey: _this.xmlCharKey
                        });
                    })
                ];
            });
        });
    };
    return DeserializationPolicy;
}((0, _requestPolicy.BaseRequestPolicy));
function getOperationResponse(parsedResponse) {
    var result;
    var request = parsedResponse.request;
    var operationSpec = request.operationSpec;
    if (operationSpec) {
        var operationResponseGetter = request.operationResponseGetter;
        if (!operationResponseGetter) result = operationSpec.responses[parsedResponse.status];
        else result = operationResponseGetter(operationSpec, parsedResponse);
    }
    return result;
}
function shouldDeserializeResponse(parsedResponse) {
    var shouldDeserialize = parsedResponse.request.shouldDeserialize;
    var result;
    if (shouldDeserialize === undefined) result = true;
    else if (typeof shouldDeserialize === "boolean") result = shouldDeserialize;
    else result = shouldDeserialize(parsedResponse);
    return result;
}
function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options) {
    var _a, _b, _c;
    if (options === void 0) options = {};
    var updatedOptions = {
        rootName: (_a = options.rootName) !== null && _a !== void 0 ? _a : "",
        includeRoot: (_b = options.includeRoot) !== null && _b !== void 0 ? _b : false,
        xmlCharKey: (_c = options.xmlCharKey) !== null && _c !== void 0 ? _c : (0, _serializerCommon.XML_CHARKEY)
    };
    return parse(jsonContentTypes, xmlContentTypes, response, updatedOptions).then(function(parsedResponse) {
        if (!shouldDeserializeResponse(parsedResponse)) return parsedResponse;
        var operationSpec = parsedResponse.request.operationSpec;
        if (!operationSpec || !operationSpec.responses) return parsedResponse;
        var responseSpec = getOperationResponse(parsedResponse);
        var _a = handleErrorResponse(parsedResponse, operationSpec, responseSpec), error = _a.error, shouldReturnResponse = _a.shouldReturnResponse;
        if (error) throw error;
        else if (shouldReturnResponse) return parsedResponse;
        // An operation response spec does exist for current status code, so
        // use it to deserialize the response.
        if (responseSpec) {
            if (responseSpec.bodyMapper) {
                var valueToDeserialize = parsedResponse.parsedBody;
                if (operationSpec.isXML && responseSpec.bodyMapper.type.name === (0, _serializer.MapperType).Sequence) valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
                try {
                    parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
                } catch (innerError) {
                    var restError = new (0, _restError.RestError)("Error " + innerError + " occurred in deserializing the responseBody - " + parsedResponse.bodyAsText, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);
                    throw restError;
                }
            } else if (operationSpec.httpMethod === "HEAD") // head methods never have a body, but we return a boolean to indicate presence/absence of the resource
            parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
            if (responseSpec.headersMapper) parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders", options);
        }
        return parsedResponse;
    });
}
function isOperationSpecEmpty(operationSpec) {
    var expectedStatusCodes = Object.keys(operationSpec.responses);
    return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec) {
    var _a;
    var isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
    var isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
    if (isExpectedStatusCode) {
        if (responseSpec) {
            if (!responseSpec.isError) return {
                error: null,
                shouldReturnResponse: false
            };
        } else return {
            error: null,
            shouldReturnResponse: false
        };
    }
    var errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
    var streaming = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) || parsedResponse.request.streamResponseBody;
    var initialErrorMessage = streaming ? "Unexpected status code: " + parsedResponse.status : parsedResponse.bodyAsText;
    var error = new (0, _restError.RestError)(initialErrorMessage, undefined, parsedResponse.status, parsedResponse.request, parsedResponse);
    // If the item failed but there's no error spec or default spec to deserialize the error,
    // we should fail so we just throw the parsed response
    if (!errorResponseSpec) throw error;
    var defaultBodyMapper = errorResponseSpec.bodyMapper;
    var defaultHeadersMapper = errorResponseSpec.headersMapper;
    try {
        // If error response has a body, try to deserialize it using default body mapper.
        // Then try to extract error code & message from it
        if (parsedResponse.parsedBody) {
            var parsedBody = parsedResponse.parsedBody;
            var parsedError = void 0;
            if (defaultBodyMapper) {
                var valueToDeserialize = parsedBody;
                if (operationSpec.isXML && defaultBodyMapper.type.name === (0, _serializer.MapperType).Sequence) valueToDeserialize = typeof parsedBody === "object" ? parsedBody[defaultBodyMapper.xmlElementName] : [];
                parsedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody");
            }
            var internalError = parsedBody.error || parsedError || parsedBody;
            error.code = internalError.code;
            if (internalError.message) error.message = internalError.message;
            if (defaultBodyMapper) error.response.parsedBody = parsedError;
        }
        // If error response has headers, try to deserialize it using default header mapper
        if (parsedResponse.headers && defaultHeadersMapper) error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.rawHeaders(), "operationRes.parsedHeaders");
    } catch (defaultError) {
        error.message = "Error \"" + defaultError.message + "\" occurred in deserializing the responseBody - \"" + parsedResponse.bodyAsText + "\" for the default response.";
    }
    return {
        error: error,
        shouldReturnResponse: false
    };
}
function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts) {
    var _a;
    var errorHandler = function(err) {
        var msg = "Error \"" + err + "\" occurred while parsing the response body - " + operationResponse.bodyAsText + ".";
        var errCode = err.code || (0, _restError.RestError).PARSE_ERROR;
        var e = new (0, _restError.RestError)(msg, errCode, operationResponse.status, operationResponse.request, operationResponse);
        return Promise.reject(e);
    };
    var streaming = ((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) || operationResponse.request.streamResponseBody;
    if (!streaming && operationResponse.bodyAsText) {
        var text_1 = operationResponse.bodyAsText;
        var contentType = operationResponse.headers.get("Content-Type") || "";
        var contentComponents = !contentType ? [] : contentType.split(";").map(function(component) {
            return component.toLowerCase();
        });
        if (contentComponents.length === 0 || contentComponents.some(function(component) {
            return jsonContentTypes.indexOf(component) !== -1;
        })) return new Promise(function(resolve) {
            operationResponse.parsedBody = JSON.parse(text_1);
            resolve(operationResponse);
        }).catch(errorHandler);
        else if (contentComponents.some(function(component) {
            return xmlContentTypes.indexOf(component) !== -1;
        })) return (0, _xml.parseXML)(text_1, opts).then(function(body) {
            operationResponse.parsedBody = body;
            return operationResponse;
        }).catch(errorHandler);
    }
    return Promise.resolve(operationResponse);
}

},{"tslib":"iC1Dx","../restError":"bqwGr","../serializer":"4pdUf","../util/xml":"bNo0R","./requestPolicy":"hwRyd","../util/serializer.common":"1KFRt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bNo0R":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseXML", ()=>parseXML);
parcelHelpers.export(exports, "stringifyXML", ()=>stringifyXML);
var _serializerCommon = require("./serializer.common");
// tslint:disable-next-line:no-null-keyword
var doc = document.implementation.createDocument(null, null, null);
var parser = new DOMParser();
function parseXML(str, opts) {
    var _a, _b, _c;
    if (opts === void 0) opts = {};
    try {
        var updatedOptions = {
            rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "",
            includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
            xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : (0, _serializerCommon.XML_CHARKEY)
        };
        var dom = parser.parseFromString(str, "application/xml");
        throwIfError(dom);
        var obj = void 0;
        if (updatedOptions.includeRoot) obj = domToObject(dom, updatedOptions);
        else obj = domToObject(dom.childNodes[0], updatedOptions);
        return Promise.resolve(obj);
    } catch (err) {
        return Promise.reject(err);
    }
}
var errorNS;
function getErrorNamespace() {
    var _a;
    if (errorNS === undefined) try {
        errorNS = (_a = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI) !== null && _a !== void 0 ? _a : "";
    } catch (ignored) {
        // Most browsers will return a document containing <parsererror>, but IE will throw.
        errorNS = "";
    }
    return errorNS;
}
function throwIfError(dom) {
    var parserErrors = dom.getElementsByTagName("parsererror");
    if (parserErrors.length > 0 && getErrorNamespace()) for(var i = 0; i < parserErrors.length; i++){
        if (parserErrors[i].namespaceURI === errorNS) throw new Error(parserErrors[i].innerHTML);
    }
}
function isElement(node) {
    return !!node.attributes;
}
/**
 * Get the Element-typed version of the provided Node if the provided node is an element with
 * attributes. If it isn't, then undefined is returned.
 */ function asElementWithAttributes(node) {
    return isElement(node) && node.hasAttributes() ? node : undefined;
}
function domToObject(node, options) {
    var result = {};
    var childNodeCount = node.childNodes.length;
    var firstChildNode = node.childNodes[0];
    var onlyChildTextValue = firstChildNode && childNodeCount === 1 && firstChildNode.nodeType === Node.TEXT_NODE && firstChildNode.nodeValue || undefined;
    var elementWithAttributes = asElementWithAttributes(node);
    if (elementWithAttributes) {
        result[0, _serializerCommon.XML_ATTRKEY] = {};
        for(var i = 0; i < elementWithAttributes.attributes.length; i++){
            var attr = elementWithAttributes.attributes[i];
            result[0, _serializerCommon.XML_ATTRKEY][attr.nodeName] = attr.nodeValue;
        }
        if (onlyChildTextValue) result[options.xmlCharKey] = onlyChildTextValue;
    } else if (childNodeCount === 0) result = "";
    else if (onlyChildTextValue) result = onlyChildTextValue;
    if (!onlyChildTextValue) for(var i = 0; i < childNodeCount; i++){
        var child = node.childNodes[i];
        // Ignore leading/trailing whitespace nodes
        if (child.nodeType !== Node.TEXT_NODE) {
            var childObject = domToObject(child, options);
            if (!result[child.nodeName]) result[child.nodeName] = childObject;
            else if (Array.isArray(result[child.nodeName])) result[child.nodeName].push(childObject);
            else result[child.nodeName] = [
                result[child.nodeName],
                childObject
            ];
        }
    }
    return result;
}
var serializer = new XMLSerializer();
function stringifyXML(content, opts) {
    var _a, _b, _c;
    if (opts === void 0) opts = {};
    var updatedOptions = {
        rootName: (_a = opts.rootName) !== null && _a !== void 0 ? _a : "root",
        includeRoot: (_b = opts.includeRoot) !== null && _b !== void 0 ? _b : false,
        xmlCharKey: (_c = opts.xmlCharKey) !== null && _c !== void 0 ? _c : (0, _serializerCommon.XML_CHARKEY)
    };
    var dom = buildNode(content, updatedOptions.rootName, updatedOptions)[0];
    return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + serializer.serializeToString(dom);
}
function buildAttributes(attrs) {
    var result = [];
    for(var _i = 0, _a = Object.keys(attrs); _i < _a.length; _i++){
        var key = _a[_i];
        var attr = doc.createAttribute(key);
        attr.value = attrs[key].toString();
        result.push(attr);
    }
    return result;
}
function buildNode(obj, elementName, options) {
    if (obj === undefined || obj === null || typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
        var elem = doc.createElement(elementName);
        elem.textContent = obj === undefined || obj === null ? "" : obj.toString();
        return [
            elem
        ];
    } else if (Array.isArray(obj)) {
        var result = [];
        for(var _i = 0, obj_1 = obj; _i < obj_1.length; _i++){
            var arrayElem = obj_1[_i];
            for(var _a = 0, _b = buildNode(arrayElem, elementName, options); _a < _b.length; _a++){
                var child = _b[_a];
                result.push(child);
            }
        }
        return result;
    } else if (typeof obj === "object") {
        var elem = doc.createElement(elementName);
        for(var _c = 0, _d = Object.keys(obj); _c < _d.length; _c++){
            var key = _d[_c];
            if (key === (0, _serializerCommon.XML_ATTRKEY)) for(var _e = 0, _f = buildAttributes(obj[key]); _e < _f.length; _e++){
                var attr = _f[_e];
                elem.attributes.setNamedItem(attr);
            }
            else if (key === options.xmlCharKey) elem.textContent = obj[key].toString();
            else for(var _g = 0, _h = buildNode(obj[key], key, options); _g < _h.length; _g++){
                var child = _h[_g];
                elem.appendChild(child);
            }
        }
        return [
            elem
        ];
    } else throw new Error("Illegal value passed to buildObject: " + obj);
}

},{"./serializer.common":"1KFRt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2RHu1":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exponentialRetryPolicy", ()=>exponentialRetryPolicy);
parcelHelpers.export(exports, "RetryMode", ()=>RetryMode);
parcelHelpers.export(exports, "DefaultRetryOptions", ()=>DefaultRetryOptions);
parcelHelpers.export(exports, "ExponentialRetryPolicy", ()=>ExponentialRetryPolicy);
var _tslib = require("tslib");
var _utils = require("../util/utils");
var _requestPolicy = require("./requestPolicy");
var _exponentialBackoffStrategy = require("../util/exponentialBackoffStrategy");
var _restError = require("../restError");
var _log = require("../log");
function exponentialRetryPolicy(retryCount, retryInterval, maxRetryInterval) {
    return {
        create: function(nextPolicy, options) {
            return new ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval);
        }
    };
}
var RetryMode;
(function(RetryMode) {
    RetryMode[RetryMode["Exponential"] = 0] = "Exponential";
})(RetryMode || (RetryMode = {}));
var DefaultRetryOptions = {
    maxRetries: (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_COUNT),
    retryDelayInMs: (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_INTERVAL),
    maxRetryDelayInMs: (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_MAX_RETRY_INTERVAL)
};
/**
 * Instantiates a new "ExponentialRetryPolicyFilter" instance.
 */ var ExponentialRetryPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(ExponentialRetryPolicy, _super);
    /**
     * @param nextPolicy - The next RequestPolicy in the pipeline chain.
     * @param options - The options for this RequestPolicy.
     * @param retryCount - The client retry count.
     * @param retryInterval - The client retry interval, in milliseconds.
     * @param minRetryInterval - The minimum retry interval, in milliseconds.
     * @param maxRetryInterval - The maximum retry interval, in milliseconds.
     */ function ExponentialRetryPolicy(nextPolicy, options, retryCount, retryInterval, maxRetryInterval) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.retryCount = (0, _exponentialBackoffStrategy.isNumber)(retryCount) ? retryCount : (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_COUNT);
        _this.retryInterval = (0, _exponentialBackoffStrategy.isNumber)(retryInterval) ? retryInterval : (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_INTERVAL);
        _this.maxRetryInterval = (0, _exponentialBackoffStrategy.isNumber)(maxRetryInterval) ? maxRetryInterval : (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_MAX_RETRY_INTERVAL);
        return _this;
    }
    ExponentialRetryPolicy.prototype.sendRequest = function(request) {
        var _this = this;
        return this._nextPolicy.sendRequest(request.clone()).then(function(response) {
            return retry(_this, request, response);
        }).catch(function(error) {
            return retry(_this, request, error.response, undefined, error);
        });
    };
    return ExponentialRetryPolicy;
}((0, _requestPolicy.BaseRequestPolicy));
function retry(policy, request, response, retryData, requestError) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
        function shouldPolicyRetry(responseParam) {
            var statusCode = responseParam === null || responseParam === void 0 ? void 0 : responseParam.status;
            if (statusCode === undefined || statusCode < 500 && statusCode !== 408 || statusCode === 501 || statusCode === 505) return false;
            return true;
        }
        var isAborted, res, err_1, err;
        return (0, _tslib.__generator)(this, function(_a) {
            switch(_a.label){
                case 0:
                    retryData = (0, _exponentialBackoffStrategy.updateRetryData)({
                        retryInterval: policy.retryInterval,
                        minRetryInterval: 0,
                        maxRetryInterval: policy.maxRetryInterval
                    }, retryData, requestError);
                    isAborted = request.abortSignal && request.abortSignal.aborted;
                    if (!(!isAborted && (0, _exponentialBackoffStrategy.shouldRetry)(policy.retryCount, shouldPolicyRetry, retryData, response))) return [
                        3 /*break*/ ,
                        6
                    ];
                    (0, _log.logger).info("Retrying request in " + retryData.retryInterval);
                    _a.label = 1;
                case 1:
                    _a.trys.push([
                        1,
                        4,
                        ,
                        5
                    ]);
                    return [
                        4 /*yield*/ ,
                        _utils.delay(retryData.retryInterval)
                    ];
                case 2:
                    _a.sent();
                    return [
                        4 /*yield*/ ,
                        policy._nextPolicy.sendRequest(request.clone())
                    ];
                case 3:
                    res = _a.sent();
                    return [
                        2 /*return*/ ,
                        retry(policy, request, res, retryData)
                    ];
                case 4:
                    err_1 = _a.sent();
                    return [
                        2 /*return*/ ,
                        retry(policy, request, response, retryData, err_1)
                    ];
                case 5:
                    return [
                        3 /*break*/ ,
                        7
                    ];
                case 6:
                    if (isAborted || requestError || !response) {
                        err = retryData.error || new (0, _restError.RestError)("Failed to send the request.", (0, _restError.RestError).REQUEST_SEND_ERROR, response && response.status, response && response.request, response);
                        throw err;
                    } else return [
                        2 /*return*/ ,
                        response
                    ];
                    _a.label = 7;
                case 7:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}

},{"tslib":"iC1Dx","../util/utils":"3ok7s","./requestPolicy":"hwRyd","../util/exponentialBackoffStrategy":"dr3MD","../restError":"bqwGr","../log":"bojeI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dr3MD":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_CLIENT_RETRY_COUNT", ()=>DEFAULT_CLIENT_RETRY_COUNT);
parcelHelpers.export(exports, "DEFAULT_CLIENT_RETRY_INTERVAL", ()=>DEFAULT_CLIENT_RETRY_INTERVAL);
parcelHelpers.export(exports, "DEFAULT_CLIENT_MAX_RETRY_INTERVAL", ()=>DEFAULT_CLIENT_MAX_RETRY_INTERVAL);
parcelHelpers.export(exports, "DEFAULT_CLIENT_MIN_RETRY_INTERVAL", ()=>DEFAULT_CLIENT_MIN_RETRY_INTERVAL);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
/**
 * @internal
 * Determines if the operation should be retried.
 *
 * @param retryLimit - Specifies the max number of retries.
 * @param predicate - Initial chekck on whether to retry based on given responses or errors
 * @param retryData -  The retry data.
 * @returns True if the operation qualifies for a retry; false otherwise.
 */ parcelHelpers.export(exports, "shouldRetry", ()=>shouldRetry);
/**
 * @internal
 * Updates the retry data for the next attempt.
 *
 * @param retryOptions - specifies retry interval, and its lower bound and upper bound.
 * @param retryData -  The retry data.
 * @param err - The operation"s error, if any.
 */ parcelHelpers.export(exports, "updateRetryData", ()=>updateRetryData);
var DEFAULT_CLIENT_RETRY_COUNT = 3;
var DEFAULT_CLIENT_RETRY_INTERVAL = 30000;
var DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 90000;
var DEFAULT_CLIENT_MIN_RETRY_INTERVAL = 3000;
function isNumber(n) {
    return typeof n === "number";
}
function shouldRetry(retryLimit, predicate, retryData, response, error) {
    if (!predicate(response, error)) return false;
    return retryData.retryCount < retryLimit;
}
function updateRetryData(retryOptions, retryData, err) {
    if (retryData === void 0) retryData = {
        retryCount: 0,
        retryInterval: 0
    };
    if (err) {
        if (retryData.error) err.innerError = retryData.error;
        retryData.error = err;
    }
    // Adjust retry count
    retryData.retryCount++;
    // Adjust retry interval
    var incrementDelta = Math.pow(2, retryData.retryCount - 1) - 1;
    var boundedRandDelta = retryOptions.retryInterval * 0.8 + Math.floor(Math.random() * (retryOptions.retryInterval * 0.4));
    incrementDelta *= boundedRandDelta;
    retryData.retryInterval = Math.min(retryOptions.minRetryInterval + incrementDelta, retryOptions.maxRetryInterval);
    return retryData;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h0Glf":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generateClientRequestIdPolicy", ()=>generateClientRequestIdPolicy);
parcelHelpers.export(exports, "GenerateClientRequestIdPolicy", ()=>GenerateClientRequestIdPolicy);
var _tslib = require("tslib");
var _requestPolicy = require("./requestPolicy");
function generateClientRequestIdPolicy(requestIdHeaderName) {
    if (requestIdHeaderName === void 0) requestIdHeaderName = "x-ms-client-request-id";
    return {
        create: function(nextPolicy, options) {
            return new GenerateClientRequestIdPolicy(nextPolicy, options, requestIdHeaderName);
        }
    };
}
var GenerateClientRequestIdPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(GenerateClientRequestIdPolicy, _super);
    function GenerateClientRequestIdPolicy(nextPolicy, options, _requestIdHeaderName) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this._requestIdHeaderName = _requestIdHeaderName;
        return _this;
    }
    GenerateClientRequestIdPolicy.prototype.sendRequest = function(request) {
        if (!request.headers.contains(this._requestIdHeaderName)) request.headers.set(this._requestIdHeaderName, request.requestId);
        return this._nextPolicy.sendRequest(request);
    };
    return GenerateClientRequestIdPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hPQrK":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDefaultUserAgentHeaderName", ()=>getDefaultUserAgentHeaderName);
parcelHelpers.export(exports, "getDefaultUserAgentValue", ()=>getDefaultUserAgentValue);
parcelHelpers.export(exports, "userAgentPolicy", ()=>userAgentPolicy);
parcelHelpers.export(exports, "UserAgentPolicy", ()=>UserAgentPolicy);
var _tslib = require("tslib");
var _httpHeaders = require("../httpHeaders");
var _constants = require("../util/constants");
var _msRestUserAgentPolicy = require("./msRestUserAgentPolicy");
var _requestPolicy = require("./requestPolicy");
function getRuntimeInfo() {
    var msRestRuntime = {
        key: "core-http",
        value: (0, _constants.Constants).coreHttpVersion
    };
    return [
        msRestRuntime
    ];
}
function getUserAgentString(telemetryInfo, keySeparator, valueSeparator) {
    if (keySeparator === void 0) keySeparator = " ";
    if (valueSeparator === void 0) valueSeparator = "/";
    return telemetryInfo.map(function(info) {
        var value = info.value ? "" + valueSeparator + info.value : "";
        return "" + info.key + value;
    }).join(keySeparator);
}
var getDefaultUserAgentHeaderName = (0, _msRestUserAgentPolicy.getDefaultUserAgentKey);
function getDefaultUserAgentValue() {
    var runtimeInfo = getRuntimeInfo();
    var platformSpecificData = (0, _msRestUserAgentPolicy.getPlatformSpecificData)();
    var userAgent = getUserAgentString(runtimeInfo.concat(platformSpecificData));
    return userAgent;
}
function userAgentPolicy(userAgentData) {
    var key = !userAgentData || userAgentData.key === undefined || userAgentData.key === null ? (0, _msRestUserAgentPolicy.getDefaultUserAgentKey)() : userAgentData.key;
    var value = !userAgentData || userAgentData.value === undefined || userAgentData.value === null ? getDefaultUserAgentValue() : userAgentData.value;
    return {
        create: function(nextPolicy, options) {
            return new UserAgentPolicy(nextPolicy, options, key, value);
        }
    };
}
var UserAgentPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(UserAgentPolicy, _super);
    function UserAgentPolicy(_nextPolicy, _options, headerKey, headerValue) {
        var _this = _super.call(this, _nextPolicy, _options) || this;
        _this._nextPolicy = _nextPolicy;
        _this._options = _options;
        _this.headerKey = headerKey;
        _this.headerValue = headerValue;
        return _this;
    }
    UserAgentPolicy.prototype.sendRequest = function(request) {
        this.addUserAgentHeader(request);
        return this._nextPolicy.sendRequest(request);
    };
    UserAgentPolicy.prototype.addUserAgentHeader = function(request) {
        if (!request.headers) request.headers = new (0, _httpHeaders.HttpHeaders)();
        if (!request.headers.get(this.headerKey) && this.headerValue) request.headers.set(this.headerKey, this.headerValue);
    };
    return UserAgentPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","../httpHeaders":"dFs7b","../util/constants":"bc7jT","./msRestUserAgentPolicy":"7c12O","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7c12O":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDefaultUserAgentKey", ()=>getDefaultUserAgentKey);
parcelHelpers.export(exports, "getPlatformSpecificData", ()=>getPlatformSpecificData);
function getDefaultUserAgentKey() {
    return "x-ms-useragent";
}
function getPlatformSpecificData() {
    var navigator = self.navigator;
    var osInfo = {
        key: "OS",
        value: (navigator.oscpu || navigator.platform).replace(" ", "")
    };
    return [
        osInfo
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fPfUj":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultRedirectOptions", ()=>DefaultRedirectOptions);
parcelHelpers.export(exports, "redirectPolicy", ()=>redirectPolicy);
parcelHelpers.export(exports, "RedirectPolicy", ()=>RedirectPolicy);
var _tslib = require("tslib");
var _url = require("../url");
var _requestPolicy = require("./requestPolicy");
/**
 * Methods that are allowed to follow redirects 301 and 302
 */ var allowedRedirect = [
    "GET",
    "HEAD"
];
var DefaultRedirectOptions = {
    handleRedirects: true,
    maxRetries: 20
};
function redirectPolicy(maximumRetries) {
    if (maximumRetries === void 0) maximumRetries = 20;
    return {
        create: function(nextPolicy, options) {
            return new RedirectPolicy(nextPolicy, options, maximumRetries);
        }
    };
}
var RedirectPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(RedirectPolicy, _super);
    function RedirectPolicy(nextPolicy, options, maxRetries) {
        if (maxRetries === void 0) maxRetries = 20;
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.maxRetries = maxRetries;
        return _this;
    }
    RedirectPolicy.prototype.sendRequest = function(request) {
        var _this = this;
        return this._nextPolicy.sendRequest(request).then(function(response) {
            return handleRedirect(_this, response, 0);
        });
    };
    return RedirectPolicy;
}((0, _requestPolicy.BaseRequestPolicy));
function handleRedirect(policy, response, currentRetries) {
    var request = response.request, status = response.status;
    var locationHeader = response.headers.get("location");
    if (locationHeader && (status === 300 || status === 301 && allowedRedirect.includes(request.method) || status === 302 && allowedRedirect.includes(request.method) || status === 303 && request.method === "POST" || status === 307) && (!policy.maxRetries || currentRetries < policy.maxRetries)) {
        var builder = (0, _url.URLBuilder).parse(request.url);
        builder.setPath(locationHeader);
        request.url = builder.toString();
        // POST request with Status code 303 should be converted into a
        // redirected GET request if the redirect url is present in the location header
        if (status === 303) {
            request.method = "GET";
            delete request.body;
        }
        return policy._nextPolicy.sendRequest(request).then(function(res) {
            return handleRedirect(policy, res, currentRetries + 1);
        });
    }
    return Promise.resolve(response);
}

},{"tslib":"iC1Dx","../url":"6ht7o","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aa6Ix":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpRegistrationPolicy", ()=>rpRegistrationPolicy);
parcelHelpers.export(exports, "RPRegistrationPolicy", ()=>RPRegistrationPolicy);
var _tslib = require("tslib");
var _utils = require("../util/utils");
var _requestPolicy = require("./requestPolicy");
function rpRegistrationPolicy(retryTimeout) {
    if (retryTimeout === void 0) retryTimeout = 30;
    return {
        create: function(nextPolicy, options) {
            return new RPRegistrationPolicy(nextPolicy, options, retryTimeout);
        }
    };
}
var RPRegistrationPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(RPRegistrationPolicy, _super);
    function RPRegistrationPolicy(nextPolicy, options, _retryTimeout) {
        if (_retryTimeout === void 0) _retryTimeout = 30;
        var _this = _super.call(this, nextPolicy, options) || this;
        _this._retryTimeout = _retryTimeout;
        return _this;
    }
    RPRegistrationPolicy.prototype.sendRequest = function(request) {
        var _this = this;
        return this._nextPolicy.sendRequest(request.clone()).then(function(response) {
            return registerIfNeeded(_this, request, response);
        });
    };
    return RPRegistrationPolicy;
}((0, _requestPolicy.BaseRequestPolicy));
function registerIfNeeded(policy, request, response) {
    if (response.status === 409) {
        var rpName = checkRPNotRegisteredError(response.bodyAsText);
        if (rpName) {
            var urlPrefix = extractSubscriptionUrl(request.url);
            return registerRP(policy, urlPrefix, rpName, request)// Autoregistration of ${provider} failed for some reason. We will not return this error
            // instead will return the initial response with 409 status code back to the user.
            // do nothing here as we are returning the original response at the end of this method.
            .catch(function() {
                return false;
            }).then(function(registrationStatus) {
                if (registrationStatus) {
                    // Retry the original request. We have to change the x-ms-client-request-id
                    // otherwise Azure endpoint will return the initial 409 (cached) response.
                    request.headers.set("x-ms-client-request-id", _utils.generateUuid());
                    return policy._nextPolicy.sendRequest(request.clone());
                }
                return response;
            });
        }
    }
    return Promise.resolve(response);
}
/**
 * Reuses the headers of the original request and url (if specified).
 * @param originalRequest - The original request
 * @param reuseUrlToo - Should the url from the original request be reused as well. Default false.
 * @returns A new request object with desired headers.
 */ function getRequestEssentials(originalRequest, reuseUrlToo) {
    if (reuseUrlToo === void 0) reuseUrlToo = false;
    var reqOptions = originalRequest.clone();
    if (reuseUrlToo) reqOptions.url = originalRequest.url;
    // We have to change the x-ms-client-request-id otherwise Azure endpoint
    // will return the initial 409 (cached) response.
    reqOptions.headers.set("x-ms-client-request-id", _utils.generateUuid());
    // Set content-type to application/json
    reqOptions.headers.set("Content-Type", "application/json; charset=utf-8");
    return reqOptions;
}
/**
 * Validates the error code and message associated with 409 response status code. If it matches to that of
 * RP not registered then it returns the name of the RP else returns undefined.
 * @param body - The response body received after making the original request.
 * @returns The name of the RP if condition is satisfied else undefined.
 */ function checkRPNotRegisteredError(body) {
    var result, responseBody;
    if (body) {
        try {
            responseBody = JSON.parse(body);
        } catch (err) {
        // do nothing;
        }
        if (responseBody && responseBody.error && responseBody.error.message && responseBody.error.code && responseBody.error.code === "MissingSubscriptionRegistration") {
            var matchRes = responseBody.error.message.match(/.*'(.*)'/i);
            if (matchRes) result = matchRes.pop();
        }
    }
    return result;
}
/**
 * Extracts the first part of the URL, just after subscription:
 * https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
 * @param url - The original request url
 * @returns The url prefix as explained above.
 */ function extractSubscriptionUrl(url) {
    var result;
    var matchRes = url.match(/.*\/subscriptions\/[a-f0-9-]+\//gi);
    if (matchRes && matchRes[0]) result = matchRes[0];
    else throw new Error("Unable to extract subscriptionId from the given url - " + url + ".");
    return result;
}
/**
 * Registers the given provider.
 * @param policy - The RPRegistrationPolicy this function is being called against.
 * @param urlPrefix - https://management.azure.com/subscriptions/00000000-0000-0000-0000-000000000000/
 * @param provider - The provider name to be registered.
 * @param originalRequest - The original request sent by the user that returned a 409 response
 * with a message that the provider is not registered.
 * @param callback - The callback that handles the RP registration
 */ function registerRP(policy, urlPrefix, provider, originalRequest) {
    var postUrl = urlPrefix + "providers/" + provider + "/register?api-version=2016-02-01";
    var getUrl = urlPrefix + "providers/" + provider + "?api-version=2016-02-01";
    var reqOptions = getRequestEssentials(originalRequest);
    reqOptions.method = "POST";
    reqOptions.url = postUrl;
    return policy._nextPolicy.sendRequest(reqOptions).then(function(response) {
        if (response.status !== 200) throw new Error("Autoregistration of " + provider + " failed. Please try registering manually.");
        return getRegistrationStatus(policy, getUrl, originalRequest);
    });
}
/**
 * Polls the registration status of the provider that was registered. Polling happens at an interval of 30 seconds.
 * Polling will happen till the registrationState property of the response body is "Registered".
 * @param policy - The RPRegistrationPolicy this function is being called against.
 * @param url - The request url for polling
 * @param originalRequest - The original request sent by the user that returned a 409 response
 * with a message that the provider is not registered.
 * @returns True if RP Registration is successful.
 */ function getRegistrationStatus(policy, url, originalRequest) {
    var reqOptions = getRequestEssentials(originalRequest);
    reqOptions.url = url;
    reqOptions.method = "GET";
    return policy._nextPolicy.sendRequest(reqOptions).then(function(res) {
        var obj = res.parsedBody;
        if (res.parsedBody && obj.registrationState && obj.registrationState === "Registered") return true;
        else return _utils.delay(policy._retryTimeout * 1000).then(function() {
            return getRegistrationStatus(policy, url, originalRequest);
        });
    });
}

},{"tslib":"iC1Dx","../util/utils":"3ok7s","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d1DQw":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_CYCLER_OPTIONS", ()=>DEFAULT_CYCLER_OPTIONS);
// #endregion
/**
 * Creates a new factory for a RequestPolicy that applies a bearer token to
 * the requests' `Authorization` headers.
 *
 * @param credential - The TokenCredential implementation that can supply the bearer token.
 * @param scopes - The scopes for which the bearer token applies.
 */ parcelHelpers.export(exports, "bearerTokenAuthenticationPolicy", ()=>bearerTokenAuthenticationPolicy);
var _tslib = require("tslib");
var _requestPolicy = require("../policies/requestPolicy");
var _constants = require("../util/constants");
var _utils = require("../util/utils");
var DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 120000 // Start refreshing 2m before expiry
};
/**
 * Converts an an unreliable access token getter (which may resolve with null)
 * into an AccessTokenGetter by retrying the unreliable getter in a regular
 * interval.
 *
 * @param getAccessToken - a function that produces a promise of an access
 * token that may fail by returning null
 * @param retryIntervalInMs - the time (in milliseconds) to wait between retry
 * attempts
 * @param timeoutInMs - the timestamp after which the refresh attempt will fail,
 * throwing an exception
 * @returns - a promise that, if it resolves, will resolve with an access token
 */ function beginRefresh(getAccessToken, retryIntervalInMs, timeoutInMs) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
        // This wrapper handles exceptions gracefully as long as we haven't exceeded
        // the timeout.
        function tryGetAccessToken() {
            return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
                var _a, finalToken;
                return (0, _tslib.__generator)(this, function(_b) {
                    switch(_b.label){
                        case 0:
                            if (!(Date.now() < timeoutInMs)) return [
                                3 /*break*/ ,
                                5
                            ];
                            _b.label = 1;
                        case 1:
                            _b.trys.push([
                                1,
                                3,
                                ,
                                4
                            ]);
                            return [
                                4 /*yield*/ ,
                                getAccessToken()
                            ];
                        case 2:
                            return [
                                2 /*return*/ ,
                                _b.sent()
                            ];
                        case 3:
                            _a = _b.sent();
                            return [
                                2 /*return*/ ,
                                null
                            ];
                        case 4:
                            return [
                                3 /*break*/ ,
                                7
                            ];
                        case 5:
                            return [
                                4 /*yield*/ ,
                                getAccessToken()
                            ];
                        case 6:
                            finalToken = _b.sent();
                            // Timeout is up, so throw if it's still null
                            if (finalToken === null) throw new Error("Failed to refresh access token.");
                            return [
                                2 /*return*/ ,
                                finalToken
                            ];
                        case 7:
                            return [
                                2 /*return*/ 
                            ];
                    }
                });
            });
        }
        var token;
        return (0, _tslib.__generator)(this, function(_a) {
            switch(_a.label){
                case 0:
                    return [
                        4 /*yield*/ ,
                        tryGetAccessToken()
                    ];
                case 1:
                    token = _a.sent();
                    _a.label = 2;
                case 2:
                    if (!(token === null)) return [
                        3 /*break*/ ,
                        5
                    ];
                    return [
                        4 /*yield*/ ,
                        (0, _utils.delay)(retryIntervalInMs)
                    ];
                case 3:
                    _a.sent();
                    return [
                        4 /*yield*/ ,
                        tryGetAccessToken()
                    ];
                case 4:
                    token = _a.sent();
                    return [
                        3 /*break*/ ,
                        2
                    ];
                case 5:
                    return [
                        2 /*return*/ ,
                        token
                    ];
            }
        });
    });
}
/**
 * Creates a token cycler from a credential, scopes, and optional settings.
 *
 * A token cycler represents a way to reliably retrieve a valid access token
 * from a TokenCredential. It will handle initializing the token, refreshing it
 * when it nears expiration, and synchronizes refresh attempts to avoid
 * concurrency hazards.
 *
 * @param credential - the underlying TokenCredential that provides the access
 * token
 * @param scopes - the scopes to request authorization for
 * @param tokenCyclerOptions - optionally override default settings for the cycler
 *
 * @returns - a function that reliably produces a valid access token
 */ function createTokenCycler(credential, scopes, tokenCyclerOptions) {
    var _this = this;
    var refreshWorker = null;
    var token = null;
    var options = (0, _tslib.__assign)((0, _tslib.__assign)({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    /**
     * This little holder defines several predicates that we use to construct
     * the rules of refreshing the token.
     */ var cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */ get isRefreshing () {
            return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */ get shouldRefresh () {
            var _a;
            return !cycler.isRefreshing && ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now();
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */ get mustRefresh () {
            return token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now();
        }
    };
    /**
     * Starts a refresh job or returns the existing job if one is already
     * running.
     */ function refresh(getTokenOptions) {
        var _a;
        if (!cycler.isRefreshing) {
            // We bind `scopes` here to avoid passing it around a lot
            var tryGetAccessToken = function() {
                return credential.getToken(scopes, getTokenOptions);
            };
            // Take advantage of promise chaining to insert an assignment to `token`
            // before the refresh can be considered done.
            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, // If we don't have a token, then we should timeout immediately
            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now()).then(function(_token) {
                refreshWorker = null;
                token = _token;
                return token;
            }).catch(function(reason) {
                // We also should reset the refresher if we enter a failed state.  All
                // existing awaiters will throw, but subsequent requests will start a
                // new retry chain.
                refreshWorker = null;
                token = null;
                throw reason;
            });
        }
        return refreshWorker;
    }
    return function(tokenOptions) {
        return (0, _tslib.__awaiter)(_this, void 0, void 0, function() {
            return (0, _tslib.__generator)(this, function(_a) {
                //
                // Simple rules:
                // - If we MUST refresh, then return the refresh task, blocking
                //   the pipeline until a token is available.
                // - If we SHOULD refresh, then run refresh but don't return it
                //   (we can still use the cached token).
                // - Return the token, since it's fine if we didn't return in
                //   step 1.
                //
                if (cycler.mustRefresh) return [
                    2 /*return*/ ,
                    refresh(tokenOptions)
                ];
                if (cycler.shouldRefresh) refresh(tokenOptions);
                return [
                    2 /*return*/ ,
                    token
                ];
            });
        });
    };
}
function bearerTokenAuthenticationPolicy(credential, scopes) {
    // This simple function encapsulates the entire process of reliably retrieving the token
    var getToken = createTokenCycler(credential, scopes /* , options */ );
    var BearerTokenAuthenticationPolicy = /** @class */ function(_super) {
        (0, _tslib.__extends)(BearerTokenAuthenticationPolicy, _super);
        function BearerTokenAuthenticationPolicy(nextPolicy, options) {
            return _super.call(this, nextPolicy, options) || this;
        }
        BearerTokenAuthenticationPolicy.prototype.sendRequest = function(webResource) {
            return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
                var token;
                return (0, _tslib.__generator)(this, function(_a) {
                    switch(_a.label){
                        case 0:
                            return [
                                4 /*yield*/ ,
                                getToken({
                                    abortSignal: webResource.abortSignal,
                                    tracingOptions: {
                                        spanOptions: webResource.spanOptions,
                                        tracingContext: webResource.tracingContext
                                    }
                                })
                            ];
                        case 1:
                            token = _a.sent().token;
                            webResource.headers.set((0, _constants.Constants).HeaderConstants.AUTHORIZATION, "Bearer " + token);
                            return [
                                2 /*return*/ ,
                                this._nextPolicy.sendRequest(webResource)
                            ];
                    }
                });
            });
        };
        return BearerTokenAuthenticationPolicy;
    }((0, _requestPolicy.BaseRequestPolicy));
    return {
        create: function(nextPolicy, options) {
            return new BearerTokenAuthenticationPolicy(nextPolicy, options);
        }
    };
}

},{"tslib":"iC1Dx","../policies/requestPolicy":"hwRyd","../util/constants":"bc7jT","../util/utils":"3ok7s","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9Dfm1":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "systemErrorRetryPolicy", ()=>systemErrorRetryPolicy);
parcelHelpers.export(exports, "SystemErrorRetryPolicy", ()=>SystemErrorRetryPolicy);
var _tslib = require("tslib");
var _utils = require("../util/utils");
var _requestPolicy = require("./requestPolicy");
var _exponentialBackoffStrategy = require("../util/exponentialBackoffStrategy");
function systemErrorRetryPolicy(retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
    return {
        create: function(nextPolicy, options) {
            return new SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval);
        }
    };
}
/**
 * @param retryCount - The client retry count.
 * @param retryInterval - The client retry interval, in milliseconds.
 * @param minRetryInterval - The minimum retry interval, in milliseconds.
 * @param maxRetryInterval - The maximum retry interval, in milliseconds.
 */ var SystemErrorRetryPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(SystemErrorRetryPolicy, _super);
    function SystemErrorRetryPolicy(nextPolicy, options, retryCount, retryInterval, minRetryInterval, maxRetryInterval) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.retryCount = (0, _exponentialBackoffStrategy.isNumber)(retryCount) ? retryCount : (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_COUNT);
        _this.retryInterval = (0, _exponentialBackoffStrategy.isNumber)(retryInterval) ? retryInterval : (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_RETRY_INTERVAL);
        _this.minRetryInterval = (0, _exponentialBackoffStrategy.isNumber)(minRetryInterval) ? minRetryInterval : (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_MIN_RETRY_INTERVAL);
        _this.maxRetryInterval = (0, _exponentialBackoffStrategy.isNumber)(maxRetryInterval) ? maxRetryInterval : (0, _exponentialBackoffStrategy.DEFAULT_CLIENT_MAX_RETRY_INTERVAL);
        return _this;
    }
    SystemErrorRetryPolicy.prototype.sendRequest = function(request) {
        var _this = this;
        return this._nextPolicy.sendRequest(request.clone()).catch(function(error) {
            return retry(_this, request, error.response, error);
        });
    };
    return SystemErrorRetryPolicy;
}((0, _requestPolicy.BaseRequestPolicy));
function retry(policy, request, operationResponse, err, retryData) {
    return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
        function shouldPolicyRetry(_response, error) {
            if (error && error.code && (error.code === "ETIMEDOUT" || error.code === "ESOCKETTIMEDOUT" || error.code === "ECONNREFUSED" || error.code === "ECONNRESET" || error.code === "ENOENT")) return true;
            return false;
        }
        var nestedErr_1;
        return (0, _tslib.__generator)(this, function(_a) {
            switch(_a.label){
                case 0:
                    retryData = (0, _exponentialBackoffStrategy.updateRetryData)(policy, retryData, err);
                    if (!(0, _exponentialBackoffStrategy.shouldRetry)(policy.retryCount, shouldPolicyRetry, retryData, operationResponse, err)) return [
                        3 /*break*/ ,
                        5
                    ];
                    _a.label = 1;
                case 1:
                    _a.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4 /*yield*/ ,
                        _utils.delay(retryData.retryInterval)
                    ];
                case 2:
                    _a.sent();
                    return [
                        2 /*return*/ ,
                        policy._nextPolicy.sendRequest(request.clone())
                    ];
                case 3:
                    nestedErr_1 = _a.sent();
                    return [
                        2 /*return*/ ,
                        retry(policy, request, operationResponse, nestedErr_1, retryData)
                    ];
                case 4:
                    return [
                        3 /*break*/ ,
                        6
                    ];
                case 5:
                    if (err) // If the operation failed in the end, return all errors instead of just the last one
                    return [
                        2 /*return*/ ,
                        Promise.reject(retryData.error)
                    ];
                    return [
                        2 /*return*/ ,
                        operationResponse
                    ];
                case 6:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    });
}

},{"tslib":"iC1Dx","../util/utils":"3ok7s","./requestPolicy":"hwRyd","../util/exponentialBackoffStrategy":"dr3MD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fFmLI":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * The format that will be used to join an array of values together for a query parameter value.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QueryCollectionFormat", ()=>QueryCollectionFormat);
var QueryCollectionFormat;
(function(QueryCollectionFormat) {
    QueryCollectionFormat["Csv"] = ",";
    QueryCollectionFormat["Ssv"] = " ";
    QueryCollectionFormat["Tsv"] = "\t";
    QueryCollectionFormat["Pipes"] = "|";
    QueryCollectionFormat["Multi"] = "Multi";
})(QueryCollectionFormat || (QueryCollectionFormat = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5pJXW":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDefaultProxySettings", ()=>getDefaultProxySettings);
parcelHelpers.export(exports, "proxyPolicy", ()=>proxyPolicy);
parcelHelpers.export(exports, "ProxyPolicy", ()=>ProxyPolicy);
var _tslib = require("tslib");
var _requestPolicy = require("./requestPolicy");
var proxyNotSupportedInBrowser = new Error("ProxyPolicy is not supported in browser environment");
function getDefaultProxySettings(_proxyUrl) {
    return undefined;
}
function proxyPolicy(_proxySettings) {
    return {
        create: function(_nextPolicy, _options) {
            throw proxyNotSupportedInBrowser;
        }
    };
}
var ProxyPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(ProxyPolicy, _super);
    function ProxyPolicy(nextPolicy, options) {
        var _this = _super.call(this, nextPolicy, options) || this;
        throw proxyNotSupportedInBrowser;
    }
    ProxyPolicy.prototype.sendRequest = function(_request) {
        throw proxyNotSupportedInBrowser;
    };
    return ProxyPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cYNpY":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "throttlingRetryPolicy", ()=>throttlingRetryPolicy);
parcelHelpers.export(exports, "ThrottlingRetryPolicy", ()=>ThrottlingRetryPolicy);
var _tslib = require("tslib");
var _requestPolicy = require("./requestPolicy");
var _constants = require("../util/constants");
var _utils = require("../util/utils");
var StatusCodes = (0, _constants.Constants).HttpConstants.StatusCodes;
function throttlingRetryPolicy() {
    return {
        create: function(nextPolicy, options) {
            return new ThrottlingRetryPolicy(nextPolicy, options);
        }
    };
}
/**
 * To learn more, please refer to
 * https://docs.microsoft.com/en-us/azure/azure-resource-manager/resource-manager-request-limits,
 * https://docs.microsoft.com/en-us/azure/azure-subscription-service-limits and
 * https://docs.microsoft.com/en-us/azure/virtual-machines/troubleshooting/troubleshooting-throttling-errors
 */ var ThrottlingRetryPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(ThrottlingRetryPolicy, _super);
    function ThrottlingRetryPolicy(nextPolicy, options, _handleResponse) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this._handleResponse = _handleResponse || _this._defaultResponseHandler;
        return _this;
    }
    ThrottlingRetryPolicy.prototype.sendRequest = function(httpRequest) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            var _this = this;
            return (0, _tslib.__generator)(this, function(_a) {
                return [
                    2 /*return*/ ,
                    this._nextPolicy.sendRequest(httpRequest.clone()).then(function(response) {
                        if (response.status !== StatusCodes.TooManyRequests) return response;
                        else return _this._handleResponse(httpRequest, response);
                    })
                ];
            });
        });
    };
    ThrottlingRetryPolicy.prototype._defaultResponseHandler = function(httpRequest, httpResponse) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            var retryAfterHeader, delayInMs;
            var _this = this;
            return (0, _tslib.__generator)(this, function(_a) {
                retryAfterHeader = httpResponse.headers.get((0, _constants.Constants).HeaderConstants.RETRY_AFTER);
                if (retryAfterHeader) {
                    delayInMs = ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterHeader);
                    if (delayInMs) return [
                        2 /*return*/ ,
                        (0, _utils.delay)(delayInMs).then(function(_) {
                            return _this._nextPolicy.sendRequest(httpRequest);
                        })
                    ];
                }
                return [
                    2 /*return*/ ,
                    httpResponse
                ];
            });
        });
    };
    ThrottlingRetryPolicy.parseRetryAfterHeader = function(headerValue) {
        var retryAfterInSeconds = Number(headerValue);
        if (Number.isNaN(retryAfterInSeconds)) return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
        else return retryAfterInSeconds * 1000;
    };
    ThrottlingRetryPolicy.parseDateRetryAfterHeader = function(headerValue) {
        try {
            var now = Date.now();
            var date = Date.parse(headerValue);
            var diff = date - now;
            return Number.isNaN(diff) ? undefined : diff;
        } catch (error) {
            return undefined;
        }
    };
    return ThrottlingRetryPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","../util/constants":"bc7jT","../util/utils":"3ok7s","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gFY9S":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "signingPolicy", ()=>signingPolicy);
parcelHelpers.export(exports, "SigningPolicy", ()=>SigningPolicy);
var _tslib = require("tslib");
var _requestPolicy = require("./requestPolicy");
function signingPolicy(authenticationProvider) {
    return {
        create: function(nextPolicy, options) {
            return new SigningPolicy(nextPolicy, options, authenticationProvider);
        }
    };
}
var SigningPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(SigningPolicy, _super);
    function SigningPolicy(nextPolicy, options, authenticationProvider) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.authenticationProvider = authenticationProvider;
        return _this;
    }
    SigningPolicy.prototype.signRequest = function(request) {
        return this.authenticationProvider.signRequest(request);
    };
    SigningPolicy.prototype.sendRequest = function(request) {
        var _this = this;
        return this.signRequest(request).then(function(nextRequest) {
            return _this._nextPolicy.sendRequest(nextRequest);
        });
    };
    return SigningPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4ufUI":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultKeepAliveOptions", ()=>DefaultKeepAliveOptions);
parcelHelpers.export(exports, "keepAlivePolicy", ()=>keepAlivePolicy);
parcelHelpers.export(exports, "KeepAlivePolicy", ()=>KeepAlivePolicy);
var _tslib = require("tslib");
var _requestPolicy = require("./requestPolicy");
var DefaultKeepAliveOptions = {
    enable: true
};
function keepAlivePolicy(keepAliveOptions) {
    return {
        create: function(nextPolicy, options) {
            return new KeepAlivePolicy(nextPolicy, options, keepAliveOptions || DefaultKeepAliveOptions);
        }
    };
}
/**
 * KeepAlivePolicy is a policy used to control keep alive settings for every request.
 */ var KeepAlivePolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(KeepAlivePolicy, _super);
    /**
     * Creates an instance of KeepAlivePolicy.
     *
     * @param nextPolicy -
     * @param options -
     * @param keepAliveOptions -
     */ function KeepAlivePolicy(nextPolicy, options, keepAliveOptions) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.keepAliveOptions = keepAliveOptions;
        return _this;
    }
    /**
     * Sends out request.
     *
     * @param request -
     * @returns
     */ KeepAlivePolicy.prototype.sendRequest = function(request) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            return (0, _tslib.__generator)(this, function(_a) {
                request.keepAlive = this.keepAliveOptions.enable;
                return [
                    2 /*return*/ ,
                    this._nextPolicy.sendRequest(request)
                ];
            });
        });
    };
    return KeepAlivePolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9BOvG":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tracingPolicy", ()=>tracingPolicy);
parcelHelpers.export(exports, "TracingPolicy", ()=>TracingPolicy);
var _tslib = require("tslib");
var _coreTracing = require("@azure/core-tracing");
var _requestPolicy = require("./requestPolicy");
var _url = require("../url");
var createSpan = (0, _coreTracing.createSpanFunction)({
    packagePrefix: "",
    namespace: ""
});
function tracingPolicy(tracingOptions) {
    if (tracingOptions === void 0) tracingOptions = {};
    return {
        create: function(nextPolicy, options) {
            return new TracingPolicy(nextPolicy, options, tracingOptions);
        }
    };
}
var TracingPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(TracingPolicy, _super);
    function TracingPolicy(nextPolicy, options, tracingOptions) {
        var _this = _super.call(this, nextPolicy, options) || this;
        _this.userAgent = tracingOptions.userAgent;
        return _this;
    }
    TracingPolicy.prototype.sendRequest = function(request) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            var path, span, spanContext, traceParentHeader, traceState, response, serviceRequestId, err_1;
            return (0, _tslib.__generator)(this, function(_a) {
                switch(_a.label){
                    case 0:
                        if (!request.tracingContext) return [
                            2 /*return*/ ,
                            this._nextPolicy.sendRequest(request)
                        ];
                        path = (0, _url.URLBuilder).parse(request.url).getPath() || "/";
                        span = createSpan(path, {
                            tracingOptions: {
                                spanOptions: (0, _tslib.__assign)((0, _tslib.__assign)({}, request.spanOptions), {
                                    kind: (0, _coreTracing.SpanKind).CLIENT
                                }),
                                tracingContext: request.tracingContext
                            }
                        }).span;
                        span.setAttributes({
                            "http.method": request.method,
                            "http.url": request.url,
                            requestId: request.requestId
                        });
                        if (this.userAgent) span.setAttribute("http.user_agent", this.userAgent);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([
                            1,
                            3,
                            ,
                            4
                        ]);
                        spanContext = span.context();
                        traceParentHeader = (0, _coreTracing.getTraceParentHeader)(spanContext);
                        if (traceParentHeader) {
                            request.headers.set("traceparent", traceParentHeader);
                            traceState = spanContext.traceState && spanContext.traceState.serialize();
                            // if tracestate is set, traceparent MUST be set, so only set tracestate after traceparent
                            if (traceState) request.headers.set("tracestate", traceState);
                        }
                        return [
                            4 /*yield*/ ,
                            this._nextPolicy.sendRequest(request)
                        ];
                    case 2:
                        response = _a.sent();
                        span.setAttribute("http.status_code", response.status);
                        serviceRequestId = response.headers.get("x-ms-request-id");
                        if (serviceRequestId) span.setAttribute("serviceRequestId", serviceRequestId);
                        span.end();
                        return [
                            2 /*return*/ ,
                            response
                        ];
                    case 3:
                        err_1 = _a.sent();
                        span.end();
                        throw err_1;
                    case 4:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    return TracingPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","@azure/core-tracing":"4r2zW","./requestPolicy":"hwRyd","../url":"6ht7o","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4r2zW":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTracer", ()=>(0, _tracerProxy.getTracer));
parcelHelpers.export(exports, "setTracer", ()=>(0, _tracerProxy.setTracer));
// Tracers and wrappers
parcelHelpers.export(exports, "NoOpSpan", ()=>(0, _noOpSpan.NoOpSpan));
parcelHelpers.export(exports, "NoOpTracer", ()=>(0, _noOpTracer.NoOpTracer));
parcelHelpers.export(exports, "OpenCensusSpanWrapper", ()=>(0, _openCensusSpanWrapper.OpenCensusSpanWrapper));
parcelHelpers.export(exports, "OpenCensusTracerWrapper", ()=>(0, _openCensusTracerWrapper.OpenCensusTracerWrapper));
parcelHelpers.export(exports, "TestTracer", ()=>(0, _testTracer.TestTracer));
parcelHelpers.export(exports, "TestSpan", ()=>(0, _testSpan.TestSpan));
parcelHelpers.export(exports, "createSpanFunction", ()=>(0, _createSpan.createSpanFunction));
// Shared interfaces
parcelHelpers.export(exports, "context", ()=>(0, _interfaces.context));
parcelHelpers.export(exports, "getSpan", ()=>(0, _interfaces.getSpan));
parcelHelpers.export(exports, "getSpanContext", ()=>(0, _interfaces.getSpanContext));
parcelHelpers.export(exports, "setSpan", ()=>(0, _interfaces.setSpan));
parcelHelpers.export(exports, "setSpanContext", ()=>(0, _interfaces.setSpanContext));
parcelHelpers.export(exports, "SpanKind", ()=>(0, _interfaces.SpanKind));
parcelHelpers.export(exports, "SpanStatusCode", ()=>(0, _interfaces.SpanStatusCode));
// Utilities
parcelHelpers.export(exports, "extractSpanContextFromTraceParentHeader", ()=>(0, _traceParentHeader.extractSpanContextFromTraceParentHeader));
parcelHelpers.export(exports, "getTraceParentHeader", ()=>(0, _traceParentHeader.getTraceParentHeader));
var _tracerProxy = require("./tracerProxy");
var _noOpSpan = require("./tracers/noop/noOpSpan");
var _noOpTracer = require("./tracers/noop/noOpTracer");
var _openCensusSpanWrapper = require("./tracers/opencensus/openCensusSpanWrapper");
var _openCensusTracerWrapper = require("./tracers/opencensus/openCensusTracerWrapper");
var _testTracer = require("./tracers/test/testTracer");
var _testSpan = require("./tracers/test/testSpan");
var _createSpan = require("./createSpan");
var _interfaces = require("./interfaces");
var _traceParentHeader = require("./utils/traceParentHeader");

},{"./tracerProxy":false,"./tracers/noop/noOpSpan":false,"./tracers/noop/noOpTracer":false,"./tracers/opencensus/openCensusSpanWrapper":false,"./tracers/opencensus/openCensusTracerWrapper":false,"./tracers/test/testTracer":false,"./tracers/test/testSpan":false,"./createSpan":"6Lanb","./interfaces":"9tj0R","./utils/traceParentHeader":"cDtfM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gin6v":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sets the global tracer, enabling tracing for the Azure SDK.
 * @param tracer - An OpenTelemetry Tracer instance.
 */ parcelHelpers.export(exports, "setTracer", ()=>setTracer);
/**
 * Retrieves the active tracer, or returns a
 * no-op implementation if one is not set.
 */ parcelHelpers.export(exports, "getTracer", ()=>getTracer);
var _noOpTracer = require("./tracers/noop/noOpTracer");
var _cache = require("./utils/cache");
var defaultTracer;
function getDefaultTracer() {
    if (!defaultTracer) defaultTracer = new (0, _noOpTracer.NoOpTracer)();
    return defaultTracer;
}
function setTracer(tracer) {
    var cache = (0, _cache.getCache)();
    cache.tracer = tracer;
}
function getTracer() {
    var cache = (0, _cache.getCache)();
    if (!cache.tracer) return getDefaultTracer();
    return cache.tracer;
}

},{"./tracers/noop/noOpTracer":"cyY2H","./utils/cache":"jyeeJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cyY2H":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoOpTracer", ()=>NoOpTracer);
var _noOpSpan = require("./noOpSpan");
/**
 * A no-op implementation of Tracer that can be used when tracing
 * is disabled.
 */ var NoOpTracer = /** @class */ function() {
    function NoOpTracer() {}
    /**
     * Starts a new Span.
     * @param _name - The name of the span.
     * @param _options - The SpanOptions used during Span creation.
     */ NoOpTracer.prototype.startSpan = function(_name, _options) {
        return new (0, _noOpSpan.NoOpSpan)();
    };
    /**
     * Returns the current Span from the current context, if available.
     */ NoOpTracer.prototype.getCurrentSpan = function() {
        return new (0, _noOpSpan.NoOpSpan)();
    };
    /**
     * Executes the given function within the context provided by a Span.
     * @param _span - The span that provides the context.
     * @param fn - The function to be executed.
     */ NoOpTracer.prototype.withSpan = function(_span, fn) {
        return fn();
    };
    /**
     * Bind a Span as the target's scope
     * @param target - An object to bind the scope.
     * @param _span - A specific Span to use. Otherwise, use the current one.
     */ NoOpTracer.prototype.bind = function(target, _span) {
        return target;
    };
    return NoOpTracer;
}();

},{"./noOpSpan":"5XCJy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5XCJy":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * A no-op implementation of Span that can safely be used without side-effects.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoOpSpan", ()=>NoOpSpan);
var NoOpSpan = /** @class */ function() {
    function NoOpSpan() {}
    /**
     * Returns the SpanContext associated with this Span.
     */ NoOpSpan.prototype.context = function() {
        return {
            spanId: "",
            traceId: "",
            traceFlags: 0 /* NONE */ 
        };
    };
    /**
     * Marks the end of Span execution.
     * @param _endTime - The time to use as the Span's end time. Defaults to
     * the current time.
     */ NoOpSpan.prototype.end = function(_endTime) {
    /* Noop */ };
    /**
     * Sets an attribute on the Span
     * @param _key - The attribute key
     * @param _value - The attribute value
     */ NoOpSpan.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    /**
     * Sets attributes on the Span
     * @param _attributes - The attributes to add
     */ NoOpSpan.prototype.setAttributes = function(_attributes) {
        return this;
    };
    /**
     * Adds an event to the Span
     * @param _name - The name of the event
     * @param _attributes - The associated attributes to add for this event
     */ NoOpSpan.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    /**
     * Sets a status on the span. Overrides the default of SpanStatusCode.OK.
     * @param _status - The status to set.
     */ NoOpSpan.prototype.setStatus = function(_status) {
        return this;
    };
    /**
     * Updates the name of the Span
     * @param _name - the new Span name
     */ NoOpSpan.prototype.updateName = function(_name) {
        return this;
    };
    /**
     * Returns whether this span will be recorded
     */ NoOpSpan.prototype.isRecording = function() {
        return false;
    };
    /**
     * Sets exception as a span event
     * @param exception - the exception the only accepted values are string or Error
     * @param time - the time to set as Span's event time. If not provided,
     *     use the current time.
     */ NoOpSpan.prototype.recordException = function(_exception, _time) {
    /* do nothing */ };
    return NoOpSpan;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jyeeJ":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCache", ()=>getCache);
var _global = require("./global");
// V1 = OpenTelemetry 0.1
// V2 = OpenTelemetry 0.2
// V3 = OpenTelemetry 0.6.1
// V4 = OpenTelemetry 1.0.0-rc.0
var GLOBAL_TRACER_VERSION = 4;
// preview5 shipped with @azure/core-tracing.tracerCache
// and didn't have smart detection for collisions
var GLOBAL_TRACER_SYMBOL = Symbol.for("@azure/core-tracing.tracerCache3");
var cache;
function loadTracerCache() {
    var globalObj = (0, _global.getGlobalObject)();
    var existingCache = globalObj[GLOBAL_TRACER_SYMBOL];
    var setGlobalCache = true;
    if (existingCache) {
        if (existingCache.version === GLOBAL_TRACER_VERSION) cache = existingCache;
        else {
            setGlobalCache = false;
            if (existingCache.tracer) throw new Error("Two incompatible versions of @azure/core-tracing have been loaded.\n          This library is " + GLOBAL_TRACER_VERSION + ", existing is " + existingCache.version + ".");
        }
    }
    if (!cache) cache = {
        tracer: undefined,
        version: GLOBAL_TRACER_VERSION
    };
    if (setGlobalCache) globalObj[GLOBAL_TRACER_SYMBOL] = cache;
}
function getCache() {
    if (!cache) loadTracerCache();
    return cache;
}

},{"./global":"llFtz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"llFtz":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getGlobalObject", ()=>getGlobalObject);
function getGlobalObject() {
    return self;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Lanb":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a function that can be used to create spans using the global tracer.
 *
 * Usage:
 *
 * ```typescript
 * // once
 * const createSpan = createSpanFunction({ packagePrefix: "Azure.Data.AppConfiguration", namespace: "Microsoft.AppConfiguration" });
 *
 * // in each operation
 * const span = createSpan("deleteConfigurationSetting", operationOptions);
 *    // code...
 * span.end();
 * ```
 *
 * @hidden
 * @param args - allows configuration of the prefix for each span as well as the az.namespace field.
 */ parcelHelpers.export(exports, "createSpanFunction", ()=>createSpanFunction);
var _tslib = require("tslib");
var _tracerProxy = require("../src/tracerProxy");
var _interfaces = require("./interfaces");
function createSpanFunction(args) {
    return function(operationName, operationOptions) {
        var tracer = (0, _tracerProxy.getTracer)();
        var tracingOptions = (operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) || {};
        var spanOptions = (0, _tslib.__assign)({
            kind: (0, _interfaces.SpanKind).INTERNAL
        }, tracingOptions.spanOptions);
        var spanName = args.packagePrefix ? args.packagePrefix + "." + operationName : operationName;
        var span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);
        if (args.namespace) span.setAttribute("az.namespace", args.namespace);
        var newSpanOptions = tracingOptions.spanOptions || {};
        if (span.isRecording() && args.namespace) newSpanOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tracingOptions.spanOptions), {
            attributes: (0, _tslib.__assign)((0, _tslib.__assign)({}, spanOptions.attributes), {
                "az.namespace": args.namespace
            })
        });
        var newTracingOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tracingOptions), {
            spanOptions: newSpanOptions,
            tracingContext: (0, _interfaces.setSpan)(tracingOptions.tracingContext || (0, _interfaces.context).active(), span)
        });
        var newOperationOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, operationOptions), {
            tracingOptions: newTracingOptions
        });
        return {
            span: span,
            updatedOptions: newOperationOptions
        };
    };
}

},{"tslib":"iC1Dx","../src/tracerProxy":"gin6v","./interfaces":"9tj0R","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9tj0R":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SpanKind", ()=>SpanKind);
/**
 * Return the span if one exists
 *
 * @param context - context to get span from
 */ parcelHelpers.export(exports, "getSpan", ()=>getSpan);
/**
 * Set the span on a context
 *
 * @param context - context to use as parent
 * @param span - span to set active
 */ parcelHelpers.export(exports, "setSpan", ()=>setSpan);
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context - context to set active span on
 * @param spanContext - span context to be wrapped
 */ parcelHelpers.export(exports, "setSpanContext", ()=>setSpanContext);
/**
 * Get the span context of the span if it exists.
 *
 * @param context - context to get values from
 */ parcelHelpers.export(exports, "getSpanContext", ()=>getSpanContext);
parcelHelpers.export(exports, "context", ()=>context);
parcelHelpers.export(exports, "SpanStatusCode", ()=>SpanStatusCode);
var _api = require("@opentelemetry/api");
var SpanKind;
(function(SpanKind) {
    /** Default value. Indicates that the span is used internally. */ SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */ SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */ SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));
function getSpan(context) {
    return (0, _api.getSpan)(context);
}
function setSpan(context, span) {
    return (0, _api.setSpan)(context, span);
}
function setSpanContext(context, spanContext) {
    return (0, _api.setSpanContext)(context, spanContext);
}
function getSpanContext(context) {
    return (0, _api.getSpanContext)(context);
}
var context = (0, _api.context);
var SpanStatusCode;
(function(SpanStatusCode) {
    /**
     * The default status.
     */ SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */ SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */ SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

},{"@opentelemetry/api":"jFZur","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jFZur":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.diag = exports.propagation = exports.trace = exports.context = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;
__exportStar(require("503d39e613a701b6"), exports);
__exportStar(require("64ab600c977c5f36"), exports);
__exportStar(require("7c4da0f07901cd7"), exports);
__exportStar(require("3a0f7e9f5da234c6"), exports);
__exportStar(require("e7562efa4308b0db"), exports);
__exportStar(require("c2177878e6ae4b7b"), exports);
__exportStar(require("967721ac860f3b6a"), exports);
__exportStar(require("3c9ce6550f42f000"), exports);
__exportStar(require("4aee2a6a26489436"), exports);
__exportStar(require("3359f4c2d56fca81"), exports);
__exportStar(require("78d3cec2c9f3b61"), exports);
__exportStar(require("a92fd319ce182f5a"), exports);
__exportStar(require("ad5a34bc35fee33d"), exports);
__exportStar(require("4a99790c9f6205f8"), exports);
__exportStar(require("918c8d6b59f02a9d"), exports);
__exportStar(require("f3945503a326f840"), exports);
__exportStar(require("ae05f4445a6128c"), exports);
__exportStar(require("50133a604d44db4d"), exports);
__exportStar(require("944c21a267219daa"), exports);
__exportStar(require("b821ab42de2984c8"), exports);
__exportStar(require("793f089d1703c2de"), exports);
__exportStar(require("756fc470590f1694"), exports);
__exportStar(require("196465c9d147b5f"), exports);
__exportStar(require("c776df089baefabe"), exports);
__exportStar(require("fb1ca100acc9b4f"), exports);
__exportStar(require("6d7bb1852351b17b"), exports);
var spancontext_utils_1 = require("8973c42cdce888fc");
Object.defineProperty(exports, "INVALID_SPANID", {
    enumerable: true,
    get: function() {
        return spancontext_utils_1.INVALID_SPANID;
    }
});
Object.defineProperty(exports, "INVALID_TRACEID", {
    enumerable: true,
    get: function() {
        return spancontext_utils_1.INVALID_TRACEID;
    }
});
Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", {
    enumerable: true,
    get: function() {
        return spancontext_utils_1.INVALID_SPAN_CONTEXT;
    }
});
Object.defineProperty(exports, "isSpanContextValid", {
    enumerable: true,
    get: function() {
        return spancontext_utils_1.isSpanContextValid;
    }
});
Object.defineProperty(exports, "isValidTraceId", {
    enumerable: true,
    get: function() {
        return spancontext_utils_1.isValidTraceId;
    }
});
Object.defineProperty(exports, "isValidSpanId", {
    enumerable: true,
    get: function() {
        return spancontext_utils_1.isValidSpanId;
    }
});
__exportStar(require("d04d9bec8b417c4b"), exports);
__exportStar(require("d3d466cf502691a6"), exports);
__exportStar(require("f8a3866946693055"), exports);
var context_1 = require("ef4ab646971b120d");
/** Entrypoint for context API */ exports.context = context_1.ContextAPI.getInstance();
var trace_1 = require("61840bceca855a2b");
/** Entrypoint for trace API */ exports.trace = trace_1.TraceAPI.getInstance();
var propagation_1 = require("2d0e54c4bb08f118");
/** Entrypoint for propagation API */ exports.propagation = propagation_1.PropagationAPI.getInstance();
var diag_1 = require("19493774cf63ec9c");
/**
 * Entrypoint for Diag API.
 * Defines Diagnostic handler used for internal diagnostic logging operations.
 * The default provides a Noop DiagLogger implementation which may be changed via the
 * diag.setLogger(logger: DiagLogger) function.
 */ exports.diag = diag_1.DiagAPI.instance();
exports.default = {
    trace: exports.trace,
    context: exports.context,
    propagation: exports.propagation,
    diag: exports.diag
};

},{"503d39e613a701b6":"dUHbC","64ab600c977c5f36":"dDImf","7c4da0f07901cd7":"6r9Jh","3a0f7e9f5da234c6":"g9gpn","e7562efa4308b0db":"fPcxb","c2177878e6ae4b7b":"2t0eu","967721ac860f3b6a":"5LMae","3c9ce6550f42f000":"fNZoH","4aee2a6a26489436":"eov84","3359f4c2d56fca81":"8GNLi","78d3cec2c9f3b61":"9bKjx","a92fd319ce182f5a":"i2MGp","ad5a34bc35fee33d":"cjSPs","4a99790c9f6205f8":"8yaEb","918c8d6b59f02a9d":"i7n8W","f3945503a326f840":"9hJKu","ae05f4445a6128c":"9FZiw","50133a604d44db4d":"GWVpj","944c21a267219daa":"jEvZW","b821ab42de2984c8":"fcB30","793f089d1703c2de":"awtE7","756fc470590f1694":"bj70a","196465c9d147b5f":"goe8D","c776df089baefabe":"j74Zk","fb1ca100acc9b4f":"iXFra","6d7bb1852351b17b":"ge5UG","8973c42cdce888fc":"63w0n","d04d9bec8b417c4b":"6i9KW","d3d466cf502691a6":"jORR5","f8a3866946693055":"74Pfa","ef4ab646971b120d":"ezRvH","61840bceca855a2b":"f9BmM","2d0e54c4bb08f118":"fpVzO","19493774cf63ec9c":"QMNLR"}],"dUHbC":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.baggageEntryMetadataFromString = exports.createBaggage = void 0;
var baggage_1 = require("7369f4767c4aaec1");
var symbol_1 = require("ea6a5fd385ada564");
__exportStar(require("7f1b41701ace1267"), exports);
__exportStar(require("8dba01039fb74010"), exports);
/**
 * Create a new Baggage with optional entries
 *
 * @param entries An array of baggage entries the new baggage should contain
 */ function createBaggage(entries) {
    if (entries === void 0) entries = {};
    return new baggage_1.BaggageImpl(new Map(Object.entries(entries)));
}
exports.createBaggage = createBaggage;
/**
 * Create a serializable BaggageEntryMetadata object from a string.
 *
 * @param str string metadata. Format is currently not defined by the spec and has no special meaning.
 *
 */ function baggageEntryMetadataFromString(str) {
    if (typeof str !== 'string') // @TODO log diagnostic
    str = '';
    return {
        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
        toString: function() {
            return str;
        }
    };
}
exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;

},{"7369f4767c4aaec1":"8HnMe","ea6a5fd385ada564":"jXtp3","7f1b41701ace1267":"9eD78","8dba01039fb74010":"31jve"}],"8HnMe":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaggageImpl = void 0;
var BaggageImpl = /** @class */ function() {
    function BaggageImpl(entries) {
        this._entries = entries ? new Map(entries) : new Map();
    }
    BaggageImpl.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) return undefined;
        return Object.assign({}, entry);
    };
    BaggageImpl.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
            var k = _a[0], v = _a[1];
            return [
                k,
                v
            ];
        });
    };
    BaggageImpl.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
    };
    BaggageImpl.prototype.removeEntries = function() {
        var keys = [];
        for(var _i = 0; _i < arguments.length; _i++)keys[_i] = arguments[_i];
        var newBaggage = new BaggageImpl(this._entries);
        for(var _a = 0, keys_1 = keys; _a < keys_1.length; _a++){
            var key = keys_1[_a];
            newBaggage._entries.delete(key);
        }
        return newBaggage;
    };
    BaggageImpl.prototype.clear = function() {
        return new BaggageImpl();
    };
    return BaggageImpl;
}();
exports.BaggageImpl = BaggageImpl;

},{}],"jXtp3":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.baggageEntryMetadataSymbol = void 0;
/**
 * Symbol used to make BaggageEntryMetadata an opaque type
 */ exports.baggageEntryMetadataSymbol = Symbol('BaggageEntryMetadata');

},{}],"9eD78":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"31jve":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"dDImf":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"6r9Jh":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"g9gpn":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(require("68e10addd010fbf"), exports);
__exportStar(require("cbbe7bdec5ddd921"), exports);

},{"68e10addd010fbf":"ccjx7","cbbe7bdec5ddd921":"cgZGg"}],"ccjx7":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DiagConsoleLogger = void 0;
var consoleMap = [
    {
        n: 'error',
        c: 'error'
    },
    {
        n: 'warn',
        c: 'warn'
    },
    {
        n: 'info',
        c: 'info'
    },
    {
        n: 'debug',
        c: 'debug'
    },
    {
        n: 'verbose',
        c: 'trace'
    }
];
/**
 * A simple Immutable Console based diagnostic logger which will output any messages to the Console.
 * If you want to limit the amount of logging to a specific level or lower use the
 * {@link createLogLevelDiagLogger}
 */ var DiagConsoleLogger = /** @class */ function() {
    function DiagConsoleLogger() {
        function _consoleFunc(funcName) {
            return function() {
                var orgArguments = arguments;
                if (console) {
                    // Some environments only expose the console when the F12 developer console is open
                    var theFunc = console[funcName];
                    if (typeof theFunc !== 'function') // Not all environments support all functions
                    theFunc = console.log;
                    // One last final check
                    if (typeof theFunc === 'function') return theFunc.apply(console, orgArguments);
                }
            };
        }
        for(var i = 0; i < consoleMap.length; i++)this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
    }
    return DiagConsoleLogger;
}();
exports.DiagConsoleLogger = DiagConsoleLogger;

},{}],"cgZGg":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DiagLogLevel = void 0;
/**
 * Defines the available internal logging levels for the diagnostic logger, the numeric values
 * of the levels are defined to match the original values from the initial LogLevel to avoid
 * compatibility/migration issues for any implementation that assume the numeric ordering.
 */ var DiagLogLevel;
(function(DiagLogLevel) {
    /** Diagnostic Logging level setting to disable all logging (except and forced logs) */ DiagLogLevel[DiagLogLevel["NONE"] = 0] = "NONE";
    /** Identifies an error scenario */ DiagLogLevel[DiagLogLevel["ERROR"] = 30] = "ERROR";
    /** Identifies a warning scenario */ DiagLogLevel[DiagLogLevel["WARN"] = 50] = "WARN";
    /** General informational log message */ DiagLogLevel[DiagLogLevel["INFO"] = 60] = "INFO";
    /** General debug log message */ DiagLogLevel[DiagLogLevel["DEBUG"] = 70] = "DEBUG";
    /**
     * Detailed trace level logging should only be used for development, should only be set
     * in a development environment.
     */ DiagLogLevel[DiagLogLevel["VERBOSE"] = 80] = "VERBOSE";
    /** Used to set the logging level to include all logging */ DiagLogLevel[DiagLogLevel["ALL"] = 9999] = "ALL";
})(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));

},{}],"fPcxb":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_TEXT_MAP_PROPAGATOR = exports.NoopTextMapPropagator = void 0;
/**
 * No-op implementations of {@link TextMapPropagator}.
 */ var NoopTextMapPropagator = /** @class */ function() {
    function NoopTextMapPropagator() {}
    /** Noop inject function does nothing */ NoopTextMapPropagator.prototype.inject = function(_context, _carrier) {};
    /** Noop extract function does nothing and returns the input context */ NoopTextMapPropagator.prototype.extract = function(context, _carrier) {
        return context;
    };
    NoopTextMapPropagator.prototype.fields = function() {
        return [];
    };
    return NoopTextMapPropagator;
}();
exports.NoopTextMapPropagator = NoopTextMapPropagator;
exports.NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();

},{}],"2t0eu":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultTextMapSetter = exports.defaultTextMapGetter = void 0;
exports.defaultTextMapGetter = {
    get: function(carrier, key) {
        if (carrier == null) return undefined;
        return carrier[key];
    },
    keys: function(carrier) {
        if (carrier == null) return [];
        return Object.keys(carrier);
    }
};
exports.defaultTextMapSetter = {
    set: function(carrier, key, value) {
        if (carrier == null) return;
        carrier[key] = value;
    }
};

},{}],"5LMae":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"fNZoH":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"eov84":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"8GNLi":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"9bKjx":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_TRACER = exports.NoopTracer = void 0;
var context_1 = require("92ab88d04b1c6d7");
var NoopSpan_1 = require("da812ec628b25222");
var spancontext_utils_1 = require("d9ebf9dab6d6576");
/**
 * No-op implementations of {@link Tracer}.
 */ var NoopTracer = /** @class */ function() {
    function NoopTracer() {}
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function(name, options, context) {
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) return new NoopSpan_1.NoopSpan();
        var parentFromContext = context && context_1.getSpanContext(context);
        if (isSpanContext(parentFromContext) && spancontext_utils_1.isSpanContextValid(parentFromContext)) return new NoopSpan_1.NoopSpan(parentFromContext);
        else return new NoopSpan_1.NoopSpan();
    };
    return NoopTracer;
}();
exports.NoopTracer = NoopTracer;
function isSpanContext(spanContext) {
    return typeof spanContext === 'object' && typeof spanContext['spanId'] === 'string' && typeof spanContext['traceId'] === 'string' && typeof spanContext['traceFlags'] === 'number';
}
exports.NOOP_TRACER = new NoopTracer();

},{"92ab88d04b1c6d7":"6i9KW","da812ec628b25222":"5oHXh","d9ebf9dab6d6576":"63w0n"}],"6i9KW":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ROOT_CONTEXT = exports.createContextKey = exports.setBaggage = exports.getBaggage = exports.isInstrumentationSuppressed = exports.unsuppressInstrumentation = exports.suppressInstrumentation = exports.getSpanContext = exports.setSpanContext = exports.setSpan = exports.getSpan = void 0;
var NoopSpan_1 = require("557af2479143bc94");
/**
 * span key
 */ var SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');
/**
 * Shared key for indicating if instrumentation should be suppressed beyond
 * this current scope.
 */ var SUPPRESS_INSTRUMENTATION_KEY = createContextKey('OpenTelemetry Context Key SUPPRESS_INSTRUMENTATION');
/**
 * Baggage key
 */ var BAGGAGE_KEY = createContextKey('OpenTelemetry Baggage Key');
/**
 * Return the span if one exists
 *
 * @param context context to get span from
 */ function getSpan(context) {
    return context.getValue(SPAN_KEY) || undefined;
}
exports.getSpan = getSpan;
/**
 * Set the span on a context
 *
 * @param context context to use as parent
 * @param span span to set active
 */ function setSpan(context, span) {
    return context.setValue(SPAN_KEY, span);
}
exports.setSpan = setSpan;
/**
 * Wrap span context in a NoopSpan and set as span in a new
 * context
 *
 * @param context context to set active span on
 * @param spanContext span context to be wrapped
 */ function setSpanContext(context, spanContext) {
    return setSpan(context, new NoopSpan_1.NoopSpan(spanContext));
}
exports.setSpanContext = setSpanContext;
/**
 * Get the span context of the span if it exists.
 *
 * @param context context to get values from
 */ function getSpanContext(context) {
    var _a;
    return (_a = getSpan(context)) === null || _a === void 0 ? void 0 : _a.context();
}
exports.getSpanContext = getSpanContext;
/**
 * Sets value on context to indicate that instrumentation should
 * be suppressed beyond this current scope.
 *
 * @param context context to set the suppress instrumentation value on.
 */ function suppressInstrumentation(context) {
    return context.setValue(SUPPRESS_INSTRUMENTATION_KEY, true);
}
exports.suppressInstrumentation = suppressInstrumentation;
/**
 * Sets value on context to indicate that instrumentation should
 * no-longer be suppressed beyond this current scope.
 *
 * @param context context to set the suppress instrumentation value on.
 */ function unsuppressInstrumentation(context) {
    return context.setValue(SUPPRESS_INSTRUMENTATION_KEY, false);
}
exports.unsuppressInstrumentation = unsuppressInstrumentation;
/**
 * Return current suppress instrumentation value for the given context,
 * if it exists.
 *
 * @param context context check for the suppress instrumentation value.
 */ function isInstrumentationSuppressed(context) {
    return Boolean(context.getValue(SUPPRESS_INSTRUMENTATION_KEY));
}
exports.isInstrumentationSuppressed = isInstrumentationSuppressed;
/**
 * @param {Context} Context that manage all context values
 * @returns {Baggage} Extracted baggage from the context
 */ function getBaggage(context) {
    return context.getValue(BAGGAGE_KEY) || undefined;
}
exports.getBaggage = getBaggage;
/**
 * @param {Context} Context that manage all context values
 * @param {Baggage} baggage that will be set in the actual context
 */ function setBaggage(context, baggage) {
    return context.setValue(BAGGAGE_KEY, baggage);
}
exports.setBaggage = setBaggage;
/** Get a key to uniquely identify a context value */ function createContextKey(description) {
    return Symbol.for(description);
}
exports.createContextKey = createContextKey;
var BaseContext = /** @class */ function() {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */ function BaseContext(parentContext) {
        // for minification
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : new Map();
        self.getValue = function(key) {
            return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.set(key, value);
            return context;
        };
        self.deleteValue = function(key) {
            var context = new BaseContext(self._currentContext);
            context._currentContext.delete(key);
            return context;
        };
    }
    return BaseContext;
}();
/** The root context is used as the default parent context when there is no active context */ exports.ROOT_CONTEXT = new BaseContext();

},{"557af2479143bc94":"5oHXh"}],"5oHXh":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoopSpan = void 0;
var spancontext_utils_1 = require("743a4b6f01a4aee7");
/**
 * The NoopSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */ var NoopSpan = /** @class */ function() {
    function NoopSpan(_spanContext) {
        if (_spanContext === void 0) _spanContext = spancontext_utils_1.INVALID_SPAN_CONTEXT;
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NoopSpan.prototype.context = function() {
        return this._spanContext;
    };
    // By default does nothing
    NoopSpan.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.setAttributes = function(_attributes) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.setStatus = function(_status) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.updateName = function(_name) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.end = function(_endTime) {};
    // isRecording always returns false for noopSpan.
    NoopSpan.prototype.isRecording = function() {
        return false;
    };
    // By default does nothing
    NoopSpan.prototype.recordException = function(_exception, _time) {};
    return NoopSpan;
}();
exports.NoopSpan = NoopSpan;

},{"743a4b6f01a4aee7":"63w0n"}],"63w0n":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;
var trace_flags_1 = require("b269e334bdfacce8");
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
exports.INVALID_SPANID = '0000000000000000';
exports.INVALID_TRACEID = '00000000000000000000000000000000';
exports.INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACEID,
    spanId: exports.INVALID_SPANID,
    traceFlags: trace_flags_1.TraceFlags.NONE
};
function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== exports.INVALID_TRACEID;
}
exports.isValidTraceId = isValidTraceId;
function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== exports.INVALID_SPANID;
}
exports.isValidSpanId = isValidSpanId;
/**
 * Returns true if this {@link SpanContext} is valid.
 * @return true if this {@link SpanContext} is valid.
 */ function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
exports.isSpanContextValid = isSpanContextValid;

},{"b269e334bdfacce8":"goe8D"}],"goe8D":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TraceFlags = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var TraceFlags;
(function(TraceFlags) {
    /** Represents no flag set. */ TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */ TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));

},{}],"i2MGp":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_TRACER_PROVIDER = exports.NoopTracerProvider = void 0;
var NoopTracer_1 = require("c99877aa801ca10d");
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */ var NoopTracerProvider = /** @class */ function() {
    function NoopTracerProvider() {}
    NoopTracerProvider.prototype.getTracer = function(_name, _version) {
        return NoopTracer_1.NOOP_TRACER;
    };
    return NoopTracerProvider;
}();
exports.NoopTracerProvider = NoopTracerProvider;
exports.NOOP_TRACER_PROVIDER = new NoopTracerProvider();

},{"c99877aa801ca10d":"9bKjx"}],"cjSPs":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProxyTracer = void 0;
var NoopTracer_1 = require("a2aea1bb9a263564");
/**
 * Proxy tracer provided by the proxy tracer provider
 */ var ProxyTracer = /** @class */ function() {
    function ProxyTracer(_provider, name, version) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
    }
    ProxyTracer.prototype.startSpan = function(name, options, context) {
        return this._getTracer().startSpan(name, options, context);
    };
    /**
     * Try to get a tracer from the proxy tracer provider.
     * If the proxy tracer provider has no delegate, return a noop tracer.
     */ ProxyTracer.prototype._getTracer = function() {
        if (this._delegate) return this._delegate;
        var tracer = this._provider.getDelegateTracer(this.name, this.version);
        if (!tracer) return NoopTracer_1.NOOP_TRACER;
        this._delegate = tracer;
        return this._delegate;
    };
    return ProxyTracer;
}();
exports.ProxyTracer = ProxyTracer;

},{"a2aea1bb9a263564":"9bKjx"}],"8yaEb":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ProxyTracerProvider = void 0;
var ProxyTracer_1 = require("64efaadb0ee84ec3");
var NoopTracerProvider_1 = require("fb11ed421cdac7e0");
/**
 * Tracer provider which provides {@link ProxyTracer}s.
 *
 * Before a delegate is set, tracers provided are NoOp.
 *   When a delegate is set, traces are provided from the delegate.
 *   When a delegate is set after tracers have already been provided,
 *   all tracers already provided will use the provided delegate implementation.
 */ var ProxyTracerProvider = /** @class */ function() {
    function ProxyTracerProvider() {}
    /**
     * Get a {@link ProxyTracer}
     */ ProxyTracerProvider.prototype.getTracer = function(name, version) {
        var _a;
        return (_a = this.getDelegateTracer(name, version)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version);
    };
    ProxyTracerProvider.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NoopTracerProvider_1.NOOP_TRACER_PROVIDER;
    };
    /**
     * Set the delegate tracer provider
     */ ProxyTracerProvider.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
    };
    ProxyTracerProvider.prototype.getDelegateTracer = function(name, version) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version);
    };
    return ProxyTracerProvider;
}();
exports.ProxyTracerProvider = ProxyTracerProvider;

},{"64efaadb0ee84ec3":"cjSPs","fb11ed421cdac7e0":"i2MGp"}],"i7n8W":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"9hJKu":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SamplingDecision = void 0;
/**
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */ var SamplingDecision;
(function(SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */ SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */ SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */ SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));

},{}],"9FZiw":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"GWVpj":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpanKind = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var SpanKind;
(function(SpanKind) {
    /** Default value. Indicates that the span is used internally. */ SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */ SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */ SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind = exports.SpanKind || (exports.SpanKind = {}));

},{}],"jEvZW":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"fcB30":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"awtE7":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpanStatusCode = void 0;
/**
 * An enumeration of status codes.
 */ var SpanStatusCode;
(function(SpanStatusCode) {
    /**
     * The default status.
     */ SpanStatusCode[SpanStatusCode["UNSET"] = 0] = "UNSET";
    /**
     * The operation has been validated by an Application developer or
     * Operator to have completed successfully.
     */ SpanStatusCode[SpanStatusCode["OK"] = 1] = "OK";
    /**
     * The operation contains an error.
     */ SpanStatusCode[SpanStatusCode["ERROR"] = 2] = "ERROR";
})(SpanStatusCode = exports.SpanStatusCode || (exports.SpanStatusCode = {}));

},{}],"bj70a":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"j74Zk":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"iXFra":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"ge5UG":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"jORR5":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __spreadArrays = this && this.__spreadArrays || function() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoopContextManager = void 0;
var context_1 = require("d3d91a36fdd44be2");
var NoopContextManager = /** @class */ function() {
    function NoopContextManager() {}
    NoopContextManager.prototype.active = function() {
        return context_1.ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
        return fn.call.apply(fn, __spreadArrays([
            thisArg
        ], args));
    };
    NoopContextManager.prototype.bind = function(target, _context) {
        return target;
    };
    NoopContextManager.prototype.enable = function() {
        return this;
    };
    NoopContextManager.prototype.disable = function() {
        return this;
    };
    return NoopContextManager;
}();
exports.NoopContextManager = NoopContextManager;

},{"d3d91a36fdd44be2":"6i9KW"}],"74Pfa":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"ezRvH":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __spreadArrays = this && this.__spreadArrays || function() {
    for(var s = 0, i = 0, il = arguments.length; i < il; i++)s += arguments[i].length;
    for(var r = Array(s), k = 0, i = 0; i < il; i++)for(var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContextAPI = void 0;
var NoopContextManager_1 = require("6099c58ce4f77b04");
var global_utils_1 = require("ef6f2d6ae440f337");
var API_NAME = 'context';
var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */ var ContextAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function ContextAPI() {}
    /** Get the singleton instance of the Context API */ ContextAPI.getInstance = function() {
        if (!this._instance) this._instance = new ContextAPI();
        return this._instance;
    };
    /**
     * Set the current context manager. Returns the initialized context manager
     */ ContextAPI.prototype.setGlobalContextManager = function(contextManager) {
        global_utils_1.registerGlobal(API_NAME, contextManager);
        return contextManager;
    };
    /**
     * Get the currently active context
     */ ContextAPI.prototype.active = function() {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     * @param thisArg optional receiver to be used for calling fn
     * @param args optional arguments forwarded to fn
     */ ContextAPI.prototype.with = function(context, fn, thisArg) {
        var _a;
        var args = [];
        for(var _i = 3; _i < arguments.length; _i++)args[_i - 3] = arguments[_i];
        return (_a = this._getContextManager()).with.apply(_a, __spreadArrays([
            context,
            fn,
            thisArg
        ], args));
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param target function or event emitter to bind
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     */ ContextAPI.prototype.bind = function(target, context) {
        if (context === void 0) context = this.active();
        return this._getContextManager().bind(target, context);
    };
    ContextAPI.prototype._getContextManager = function() {
        return global_utils_1.getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */ ContextAPI.prototype.disable = function() {
        this._getContextManager().disable();
        global_utils_1.unregisterGlobal(API_NAME);
    };
    return ContextAPI;
}();
exports.ContextAPI = ContextAPI;

},{"6099c58ce4f77b04":"jORR5","ef6f2d6ae440f337":"gZlfq"}],"gZlfq":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = void 0;
var __1 = require("31d5bb1265ad66e4");
var platform_1 = require("a9df716980f23419");
var version_1 = require("c72ee8ed96b9986d");
var semver_1 = require("6442a3030fc6a15b");
var major = version_1.VERSION.split('.')[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("io.opentelemetry.js.api." + major);
var _global = platform_1._globalThis;
function registerGlobal(type, instance, allowOverride) {
    var _a;
    if (allowOverride === void 0) allowOverride = false;
    _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: version_1.VERSION
    };
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (!allowOverride && api[type]) {
        // already registered an API of this type
        var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
        __1.diag.error(err.stack || err.message);
        return;
    }
    if (api.version !== version_1.VERSION) {
        // All registered APIs must be of the same version exactly
        var err = new Error('@opentelemetry/api: All API registration versions must match');
        __1.diag.error(err.stack || err.message);
        return;
    }
    api[type] = instance;
}
exports.registerGlobal = registerGlobal;
function getGlobal(type) {
    var _a, _b;
    var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
    if (!globalVersion || !semver_1.isCompatible(globalVersion)) return;
    return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
exports.getGlobal = getGlobal;
function unregisterGlobal(type) {
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) delete api[type];
}
exports.unregisterGlobal = unregisterGlobal;

},{"31d5bb1265ad66e4":"jFZur","a9df716980f23419":"fb4r3","c72ee8ed96b9986d":"iNNkf","6442a3030fc6a15b":"7B6vg"}],"fb4r3":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(require("ac34f459502fe768"), exports);

},{"ac34f459502fe768":"ft7Vh"}],"ft7Vh":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._globalThis = void 0;
/** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
exports._globalThis = typeof globalThis === 'object' ? globalThis : window;

},{}],"iNNkf":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VERSION = void 0;
// this is autogenerated file, see scripts/version-update.js
exports.VERSION = '1.0.0-rc.0';

},{}],"7B6vg":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isCompatible = exports._makeCompatibilityCheck = void 0;
var version_1 = require("5b3d5b84c5b187a8");
var re = /^(\d+)\.(\d+)\.(\d+)(?:-(.*))?$/;
/**
 * Create a function to test an API version to see if it is compatible with the provided ownVersion.
 *
 * The returned function has the following semantics:
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param ownVersion version which should be checked against
 */ function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = new Set([
        ownVersion
    ]);
    var rejectedVersions = new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) // we cannot guarantee compatibility so we always return noop
    return function() {
        return false;
    };
    var ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3]
    };
    function _reject(v) {
        rejectedVersions.add(v);
        return false;
    }
    function _accept(v) {
        acceptedVersions.add(v);
        return true;
    }
    return function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) return true;
        if (rejectedVersions.has(globalVersion)) return false;
        var globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) // cannot parse other version
        // we cannot guarantee compatibility so we always noop
        return _reject(globalVersion);
        var globalVersionParsed = {
            major: +globalVersionMatch[1],
            minor: +globalVersionMatch[2],
            patch: +globalVersionMatch[3]
        };
        // major versions must match
        if (ownVersionParsed.major !== globalVersionParsed.major) return _reject(globalVersion);
        if (ownVersionParsed.major === 0) {
            if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) return _accept(globalVersion);
            return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) return _accept(globalVersion);
        return _reject(globalVersion);
    };
}
exports._makeCompatibilityCheck = _makeCompatibilityCheck;
/**
 * Test an API version to see if it is compatible with this API.
 *
 * - Exact match is always compatible
 * - Major versions must match exactly
 *    - 1.x package cannot use global 2.x package
 *    - 2.x package cannot use global 1.x package
 * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API
 *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects
 *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3
 * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor
 * - Patch and build tag differences are not considered at this time
 *
 * @param version version of the API requesting an instance of the global API
 */ exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);

},{"5b3d5b84c5b187a8":"iNNkf"}],"f9BmM":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TraceAPI = void 0;
var ProxyTracerProvider_1 = require("8f2bf1bb59699871");
var spancontext_utils_1 = require("fde599c23369eb8a");
var global_utils_1 = require("4b8dab2859368d4b");
var API_NAME = 'trace';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */ var TraceAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function TraceAPI() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
    }
    /** Get the singleton instance of the Trace API */ TraceAPI.getInstance = function() {
        if (!this._instance) this._instance = new TraceAPI();
        return this._instance;
    };
    /**
     * Set the current global tracer. Returns the initialized global tracer provider
     */ TraceAPI.prototype.setGlobalTracerProvider = function(provider) {
        this._proxyTracerProvider.setDelegate(provider);
        global_utils_1.registerGlobal(API_NAME, this._proxyTracerProvider);
        return this._proxyTracerProvider;
    };
    /**
     * Returns the global tracer provider.
     */ TraceAPI.prototype.getTracerProvider = function() {
        return global_utils_1.getGlobal(API_NAME) || this._proxyTracerProvider;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */ TraceAPI.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */ TraceAPI.prototype.disable = function() {
        global_utils_1.unregisterGlobal(API_NAME);
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
    };
    return TraceAPI;
}();
exports.TraceAPI = TraceAPI;

},{"8f2bf1bb59699871":"8yaEb","fde599c23369eb8a":"63w0n","4b8dab2859368d4b":"gZlfq"}],"fpVzO":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PropagationAPI = void 0;
var NoopTextMapPropagator_1 = require("e9b48e37be40bcc5");
var TextMapPropagator_1 = require("16f2f028268ef84f");
var global_utils_1 = require("f50837045660fd69");
var API_NAME = 'propagation';
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */ var PropagationAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function PropagationAPI() {}
    /** Get the singleton instance of the Propagator API */ PropagationAPI.getInstance = function() {
        if (!this._instance) this._instance = new PropagationAPI();
        return this._instance;
    };
    /**
     * Set the current propagator. Returns the initialized propagator
     */ PropagationAPI.prototype.setGlobalPropagator = function(propagator) {
        global_utils_1.registerGlobal(API_NAME, propagator);
        return propagator;
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param context Context carrying tracing data to inject
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     */ PropagationAPI.prototype.inject = function(context, carrier, setter) {
        if (setter === void 0) setter = TextMapPropagator_1.defaultTextMapSetter;
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param context Context which the newly created context will inherit from
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     */ PropagationAPI.prototype.extract = function(context, carrier, getter) {
        if (getter === void 0) getter = TextMapPropagator_1.defaultTextMapGetter;
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /**
     * Return a list of all fields which may be used by the propagator.
     */ PropagationAPI.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
    };
    /** Remove the global propagator */ PropagationAPI.prototype.disable = function() {
        global_utils_1.unregisterGlobal(API_NAME);
    };
    PropagationAPI.prototype._getGlobalPropagator = function() {
        return global_utils_1.getGlobal(API_NAME) || NoopTextMapPropagator_1.NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI;
}();
exports.PropagationAPI = PropagationAPI;

},{"e9b48e37be40bcc5":"fPcxb","16f2f028268ef84f":"2t0eu","f50837045660fd69":"gZlfq"}],"QMNLR":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DiagAPI = void 0;
var logLevelLogger_1 = require("136920875750d780");
var types_1 = require("87e90b264591b997");
var global_utils_1 = require("829d02290f100377");
var API_NAME = 'diag';
/**
 * Singleton object which represents the entry point to the OpenTelemetry internal
 * diagnostic API
 */ var DiagAPI = /** @class */ function() {
    /**
     * Private internal constructor
     * @private
     */ function DiagAPI() {
        function _logProxy(funcName) {
            return function() {
                var logger = global_utils_1.getGlobal('diag');
                // shortcut if logger not set
                if (!logger) return;
                return logger[funcName].apply(logger, // work around Function.prototype.apply types
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                arguments);
            };
        }
        // Using self local variable for minification purposes as 'this' cannot be minified
        var self = this;
        // DiagAPI specific functions
        self.setLogger = function(logger, logLevel) {
            var _a;
            if (logLevel === void 0) logLevel = types_1.DiagLogLevel.INFO;
            if (logger === self) {
                // There isn't much we can do here.
                // Logging to the console might break the user application.
                // Try to log to self. If a logger was previously registered it will receive the log.
                var err = new Error('Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation');
                self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
                return;
            }
            global_utils_1.registerGlobal('diag', logLevelLogger_1.createLogLevelDiagLogger(logLevel, logger), true);
        };
        self.disable = function() {
            global_utils_1.unregisterGlobal(API_NAME);
        };
        self.verbose = _logProxy('verbose');
        self.debug = _logProxy('debug');
        self.info = _logProxy('info');
        self.warn = _logProxy('warn');
        self.error = _logProxy('error');
    }
    /** Get the singleton instance of the DiagAPI API */ DiagAPI.instance = function() {
        if (!this._instance) this._instance = new DiagAPI();
        return this._instance;
    };
    return DiagAPI;
}();
exports.DiagAPI = DiagAPI;

},{"136920875750d780":"eJbW0","87e90b264591b997":"cgZGg","829d02290f100377":"gZlfq"}],"eJbW0":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createLogLevelDiagLogger = void 0;
var types_1 = require("30397ab9939ba412");
function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < types_1.DiagLogLevel.NONE) maxLevel = types_1.DiagLogLevel.NONE;
    else if (maxLevel > types_1.DiagLogLevel.ALL) maxLevel = types_1.DiagLogLevel.ALL;
    // In case the logger is null or undefined
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
        var theFunc = logger[funcName];
        if (typeof theFunc === 'function' && maxLevel >= theLevel) return theFunc.bind(logger);
        return function() {};
    }
    return {
        error: _filterFunc('error', types_1.DiagLogLevel.ERROR),
        warn: _filterFunc('warn', types_1.DiagLogLevel.WARN),
        info: _filterFunc('info', types_1.DiagLogLevel.INFO),
        debug: _filterFunc('debug', types_1.DiagLogLevel.DEBUG),
        verbose: _filterFunc('verbose', types_1.DiagLogLevel.VERBOSE)
    };
}
exports.createLogLevelDiagLogger = createLogLevelDiagLogger;

},{"30397ab9939ba412":"cgZGg"}],"cDtfM":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Generates a `SpanContext` given a `traceparent` header value.
 * @param traceParent - Serialized span context data as a `traceparent` header value.
 * @returns The `SpanContext` generated from the `traceparent` value.
 */ parcelHelpers.export(exports, "extractSpanContextFromTraceParentHeader", ()=>extractSpanContextFromTraceParentHeader);
/**
 * Generates a `traceparent` value given a span context.
 * @param spanContext - Contains context for a specific span.
 * @returns The `spanContext` represented as a `traceparent` value.
 */ parcelHelpers.export(exports, "getTraceParentHeader", ()=>getTraceParentHeader);
var VERSION = "00";
function extractSpanContextFromTraceParentHeader(traceParentHeader) {
    var parts = traceParentHeader.split("-");
    if (parts.length !== 4) return;
    var version = parts[0], traceId = parts[1], spanId = parts[2], traceOptions = parts[3];
    if (version !== VERSION) return;
    var traceFlags = parseInt(traceOptions, 16);
    var spanContext = {
        spanId: spanId,
        traceId: traceId,
        traceFlags: traceFlags
    };
    return spanContext;
}
function getTraceParentHeader(spanContext) {
    var missingFields = [];
    if (!spanContext.traceId) missingFields.push("traceId");
    if (!spanContext.spanId) missingFields.push("spanId");
    if (missingFields.length) return;
    var flags = spanContext.traceFlags || 0 /* NONE */ ;
    var hexFlags = flags.toString(16);
    var traceFlags = hexFlags.length === 1 ? "0" + hexFlags : hexFlags;
    // https://www.w3.org/TR/trace-context/#traceparent-header-field-values
    return VERSION + "-" + spanContext.traceId + "-" + spanContext.spanId + "-" + traceFlags;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"o23vK":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * {@link DisableResponseDecompressionPolicy} is not supported in browser and attempting
 * to use it will results in error being thrown.
 */ parcelHelpers.export(exports, "disableResponseDecompressionPolicy", ()=>disableResponseDecompressionPolicy);
parcelHelpers.export(exports, "DisableResponseDecompressionPolicy", ()=>DisableResponseDecompressionPolicy);
var _tslib = require("tslib");
/*
 * NOTE: When moving this file, please update "browser" section in package.json
 */ var _requestPolicy = require("./requestPolicy");
var DisbleResponseDecompressionNotSupportedInBrowser = new Error("DisableResponseDecompressionPolicy is not supported in browser environment");
function disableResponseDecompressionPolicy() {
    return {
        create: function(_nextPolicy, _options) {
            throw DisbleResponseDecompressionNotSupportedInBrowser;
        }
    };
}
var DisableResponseDecompressionPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(DisableResponseDecompressionPolicy, _super);
    function DisableResponseDecompressionPolicy(nextPolicy, options) {
        var _this = _super.call(this, nextPolicy, options) || this;
        throw DisbleResponseDecompressionNotSupportedInBrowser;
    }
    DisableResponseDecompressionPolicy.prototype.sendRequest = function(_request) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            return (0, _tslib.__generator)(this, function(_a) {
                throw DisbleResponseDecompressionNotSupportedInBrowser;
            });
        });
    };
    return DisableResponseDecompressionPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3S1Dv":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ndJsonPolicy", ()=>ndJsonPolicy);
var _tslib = require("tslib");
// BaseRequestPolicy has a protected constructor.
/* eslint-disable @typescript-eslint/no-useless-constructor */ var _requestPolicy = require("./requestPolicy");
function ndJsonPolicy() {
    return {
        create: function(nextPolicy, options) {
            return new NdJsonPolicy(nextPolicy, options);
        }
    };
}
/**
 * NdJsonPolicy that formats a JSON array as newline-delimited JSON
 */ var NdJsonPolicy = /** @class */ function(_super) {
    (0, _tslib.__extends)(NdJsonPolicy, _super);
    /**
     * Creates an instance of KeepAlivePolicy.
     */ function NdJsonPolicy(nextPolicy, options) {
        return _super.call(this, nextPolicy, options) || this;
    }
    /**
     * Sends a request.
     */ NdJsonPolicy.prototype.sendRequest = function(request) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            var body;
            return (0, _tslib.__generator)(this, function(_a) {
                // There currently isn't a good way to bypass the serializer
                if (typeof request.body === "string" && request.body.startsWith("[")) {
                    body = JSON.parse(request.body);
                    if (Array.isArray(body)) request.body = body.map(function(item) {
                        return JSON.stringify(item) + "\n";
                    }).join("");
                }
                return [
                    2 /*return*/ ,
                    this._nextPolicy.sendRequest(request)
                ];
            });
        });
    };
    return NdJsonPolicy;
}((0, _requestPolicy.BaseRequestPolicy));

},{"tslib":"iC1Dx","./requestPolicy":"hwRyd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c3XKl":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCachedDefaultHttpClient", ()=>getCachedDefaultHttpClient);
var _defaultHttpClient = require("./defaultHttpClient");
var cachedHttpClient;
function getCachedDefaultHttpClient() {
    if (!cachedHttpClient) cachedHttpClient = new (0, _defaultHttpClient.DefaultHttpClient)();
    return cachedHttpClient;
}

},{"./defaultHttpClient":"13Xl5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dq5Du":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
// NOTE: we've moved this code into core-tracing but these functions
// were a part of the GA'd library and can't be removed until the next major
// release. They currently get called always, even if tracing is not enabled.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * This function is only here for compatibility. Use createSpanFunction in core-tracing.
 *
 * @deprecated This function is only here for compatibility. Use createSpanFunction in core-tracing.
 * @hidden

 * @param spanConfig - The name of the operation being performed.
 * @param tracingOptions - The options for the underlying http request.
 */ parcelHelpers.export(exports, "createSpanFunction", ()=>createSpanFunction);
var _coreTracing = require("@azure/core-tracing");
function createSpanFunction(args) {
    return (0, _coreTracing.createSpanFunction)(args);
}

},{"@azure/core-tracing":"4r2zW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kw8rI":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Defines the default token refresh buffer duration.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TokenRefreshBufferMs", ()=>TokenRefreshBufferMs);
parcelHelpers.export(exports, "ExpiringAccessTokenCache", ()=>ExpiringAccessTokenCache);
var TokenRefreshBufferMs = 120000; // 2 Minutes
/**
 * Provides an {@link AccessTokenCache} implementation which clears
 * the cached {@link AccessToken}'s after the expiresOnTimestamp has
 * passed.
 *
 * @deprecated No longer used in the bearer authorization policy.
 */ var ExpiringAccessTokenCache = /** @class */ function() {
    /**
     * Constructs an instance of {@link ExpiringAccessTokenCache} with
     * an optional expiration buffer time.
     */ function ExpiringAccessTokenCache(tokenRefreshBufferMs) {
        if (tokenRefreshBufferMs === void 0) tokenRefreshBufferMs = TokenRefreshBufferMs;
        this.cachedToken = undefined;
        this.tokenRefreshBufferMs = tokenRefreshBufferMs;
    }
    ExpiringAccessTokenCache.prototype.setCachedToken = function(accessToken) {
        this.cachedToken = accessToken;
    };
    ExpiringAccessTokenCache.prototype.getCachedToken = function() {
        if (this.cachedToken && Date.now() + this.tokenRefreshBufferMs >= this.cachedToken.expiresOnTimestamp) this.cachedToken = undefined;
        return this.cachedToken;
    };
    return ExpiringAccessTokenCache;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"31VoW":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccessTokenRefresher", ()=>AccessTokenRefresher);
var _tslib = require("tslib");
/**
 * Helps the core-http token authentication policies with requesting a new token if we're not currently waiting for a new token.
 *
 * @deprecated No longer used in the bearer authorization policy.
 */ var AccessTokenRefresher = /** @class */ function() {
    function AccessTokenRefresher(credential, scopes, requiredMillisecondsBeforeNewRefresh) {
        if (requiredMillisecondsBeforeNewRefresh === void 0) requiredMillisecondsBeforeNewRefresh = 30000;
        this.credential = credential;
        this.scopes = scopes;
        this.requiredMillisecondsBeforeNewRefresh = requiredMillisecondsBeforeNewRefresh;
        this.lastCalled = 0;
    }
    /**
     * Returns true if the required milliseconds(defaulted to 30000) have been passed signifying
     * that we are ready for a new refresh.
     */ AccessTokenRefresher.prototype.isReady = function() {
        // We're only ready for a new refresh if the required milliseconds have passed.
        return !this.lastCalled || Date.now() - this.lastCalled > this.requiredMillisecondsBeforeNewRefresh;
    };
    /**
     * Stores the time in which it is called,
     * then requests a new token,
     * then sets this.promise to undefined,
     * then returns the token.
     */ AccessTokenRefresher.prototype.getToken = function(options) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function() {
            var token;
            return (0, _tslib.__generator)(this, function(_a) {
                switch(_a.label){
                    case 0:
                        this.lastCalled = Date.now();
                        return [
                            4 /*yield*/ ,
                            this.credential.getToken(this.scopes, options)
                        ];
                    case 1:
                        token = _a.sent();
                        this.promise = undefined;
                        return [
                            2 /*return*/ ,
                            token || undefined
                        ];
                }
            });
        });
    };
    /**
     * Requests a new token if we're not currently waiting for a new token.
     * Returns null if the required time between each call hasn't been reached.
     */ AccessTokenRefresher.prototype.refresh = function(options) {
        if (!this.promise) this.promise = this.getToken(options);
        return this.promise;
    };
    return AccessTokenRefresher;
}();

},{"tslib":"iC1Dx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gr5Kw":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BasicAuthenticationCredentials", ()=>BasicAuthenticationCredentials);
var _httpHeaders = require("../httpHeaders");
var _base64 = require("../util/base64");
var _constants = require("../util/constants");
var HeaderConstants = (0, _constants.Constants).HeaderConstants;
var DEFAULT_AUTHORIZATION_SCHEME = "Basic";
var BasicAuthenticationCredentials = /** @class */ function() {
    /**
     * Creates a new BasicAuthenticationCredentials object.
     *
     * @param userName - User name.
     * @param password - Password.
     * @param authorizationScheme - The authorization scheme.
     */ function BasicAuthenticationCredentials(userName, password, authorizationScheme) {
        if (authorizationScheme === void 0) authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
        this.authorizationScheme = DEFAULT_AUTHORIZATION_SCHEME;
        if (userName === null || userName === undefined || typeof userName.valueOf() !== "string") throw new Error("userName cannot be null or undefined and must be of type string.");
        if (password === null || password === undefined || typeof password.valueOf() !== "string") throw new Error("password cannot be null or undefined and must be of type string.");
        this.userName = userName;
        this.password = password;
        this.authorizationScheme = authorizationScheme;
    }
    /**
     * Signs a request with the Authentication header.
     *
     * @param webResource - The WebResourceLike to be signed.
     * @returns The signed request object.
     */ BasicAuthenticationCredentials.prototype.signRequest = function(webResource) {
        var credentials = this.userName + ":" + this.password;
        var encodedCredentials = this.authorizationScheme + " " + _base64.encodeString(credentials);
        if (!webResource.headers) webResource.headers = new (0, _httpHeaders.HttpHeaders)();
        webResource.headers.set(HeaderConstants.AUTHORIZATION, encodedCredentials);
        return Promise.resolve(webResource);
    };
    return BasicAuthenticationCredentials;
}();

},{"../httpHeaders":"dFs7b","../util/base64":"4KQ12","../util/constants":"bc7jT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6yXDi":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ApiKeyCredentials", ()=>ApiKeyCredentials);
var _httpHeaders = require("../httpHeaders");
/**
 * Authenticates to a service using an API key.
 */ var ApiKeyCredentials = /** @class */ function() {
    /**
     * @param options - Specifies the options to be provided for auth. Either header or query needs to be provided.
     */ function ApiKeyCredentials(options) {
        if (!options || options && !options.inHeader && !options.inQuery) throw new Error("options cannot be null or undefined. Either \"inHeader\" or \"inQuery\" property of the options object needs to be provided.");
        this.inHeader = options.inHeader;
        this.inQuery = options.inQuery;
    }
    /**
     * Signs a request with the values provided in the inHeader and inQuery parameter.
     *
     * @param webResource - The WebResourceLike to be signed.
     * @returns The signed request object.
     */ ApiKeyCredentials.prototype.signRequest = function(webResource) {
        if (!webResource) return Promise.reject(new Error("webResource cannot be null or undefined and must be of type \"object\"."));
        if (this.inHeader) {
            if (!webResource.headers) webResource.headers = new (0, _httpHeaders.HttpHeaders)();
            for(var headerName in this.inHeader)webResource.headers.set(headerName, this.inHeader[headerName]);
        }
        if (this.inQuery) {
            if (!webResource.url) return Promise.reject(new Error("url cannot be null in the request object."));
            if (webResource.url.indexOf("?") < 0) webResource.url += "?";
            for(var key in this.inQuery){
                if (!webResource.url.endsWith("?")) webResource.url += "&";
                webResource.url += key + "=" + this.inQuery[key];
            }
        }
        return Promise.resolve(webResource);
    };
    return ApiKeyCredentials;
}();

},{"../httpHeaders":"dFs7b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bJw5P":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TopicCredentials", ()=>TopicCredentials);
var _tslib = require("tslib");
var _apiKeyCredentials = require("./apiKeyCredentials");
var TopicCredentials = /** @class */ function(_super) {
    (0, _tslib.__extends)(TopicCredentials, _super);
    /**
     * Creates a new EventGrid TopicCredentials object.
     *
     * @param topicKey - The EventGrid topic key
     */ function TopicCredentials(topicKey) {
        var _this = this;
        if (!topicKey || topicKey && typeof topicKey !== "string") throw new Error("topicKey cannot be null or undefined and must be of type string.");
        var options = {
            inHeader: {
                "aeg-sas-key": topicKey
            }
        };
        _this = _super.call(this, options) || this;
        return _this;
    }
    return TopicCredentials;
}((0, _apiKeyCredentials.ApiKeyCredentials));

},{"tslib":"iC1Dx","./apiKeyCredentials":"6yXDi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gVdPP":[function(require,module,exports,__globalThis) {
"use strict";
if (!Symbol.asyncIterator) Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
 //# sourceMappingURL=index.js.map

},{}],"3sHnq":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var _coreAsynciteratorPolyfill = require("@azure/core-asynciterator-polyfill");

},{"@azure/core-asynciterator-polyfill":"gVdPP"}],"4XvbA":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.propagation = exports.metrics = exports.trace = exports.context = void 0;
__exportStar(require("1c5095b9bc384c95"), exports);
__exportStar(require("fb901bb5b6b2f40c"), exports);
__exportStar(require("3fd3e50583442d81"), exports);
__exportStar(require("5d4a3b6bd2708ee4"), exports);
__exportStar(require("7439bf45e51bc514"), exports);
__exportStar(require("318b665118eb1f06"), exports);
__exportStar(require("3fd1ece9d73a99e1"), exports);
__exportStar(require("9881aca70dbd7b48"), exports);
__exportStar(require("c48f15c996f74efa"), exports);
__exportStar(require("238a1a3ffc438b36"), exports);
__exportStar(require("c372a34fa6141152"), exports);
__exportStar(require("fbe408f38144d964"), exports);
__exportStar(require("b2fb241c49dcd0d4"), exports);
__exportStar(require("ec3519fbe923a8e"), exports);
__exportStar(require("5c5766ec08b00b92"), exports);
__exportStar(require("eeac510694115bcc"), exports);
__exportStar(require("f8fd781cd0108946"), exports);
__exportStar(require("2e38877d74df2798"), exports);
__exportStar(require("6b6efdc149adc171"), exports);
__exportStar(require("54efb93c55cefac0"), exports);
__exportStar(require("1ac77c0e20c96502"), exports);
__exportStar(require("2484fce43ac1090b"), exports);
__exportStar(require("1558f739a84b8546"), exports);
__exportStar(require("94b52610be12a816"), exports);
__exportStar(require("dcbb8ee3f2fb0d5"), exports);
__exportStar(require("23e8a5cd260922a6"), exports);
__exportStar(require("9157010ce488925c"), exports);
__exportStar(require("1645601d00a6dae8"), exports);
__exportStar(require("24e7cbec3870640a"), exports);
__exportStar(require("2f65afb6e2833770"), exports);
__exportStar(require("ee6fb870c02d4e5f"), exports);
__exportStar(require("91077b1a56a6d18a"), exports);
__exportStar(require("ed2cb41eeee95b9f"), exports);
__exportStar(require("af43af67adaf0d68"), exports);
__exportStar(require("7bd03af89cf54cf4"), exports);
__exportStar(require("8aad0c0921e4cdc5"), exports);
__exportStar(require("311d55efcacf39ca"), exports);
var context_base_1 = require("aee2bd5a0a04a4fd");
Object.defineProperty(exports, "Context", {
    enumerable: true,
    get: function() {
        return context_base_1.Context;
    }
});
var context_1 = require("9b95219af1089dea");
/** Entrypoint for context API */ exports.context = context_1.ContextAPI.getInstance();
var trace_1 = require("62b1ef618e7ec56b");
/** Entrypoint for trace API */ exports.trace = trace_1.TraceAPI.getInstance();
var metrics_1 = require("75c7acd41d68cfaf");
/** Entrypoint for metrics API */ exports.metrics = metrics_1.MetricsAPI.getInstance();
var propagation_1 = require("5dc0d046b19de492");
/** Entrypoint for propagation API */ exports.propagation = propagation_1.PropagationAPI.getInstance();
exports.default = {
    trace: exports.trace,
    metrics: exports.metrics,
    context: exports.context,
    propagation: exports.propagation
};

},{"1c5095b9bc384c95":"8G6lx","fb901bb5b6b2f40c":"b5PCP","3fd3e50583442d81":"aFAvd","5d4a3b6bd2708ee4":"fY7Xi","7439bf45e51bc514":"aL3r7","318b665118eb1f06":"fauRI","3fd1ece9d73a99e1":"awEW0","9881aca70dbd7b48":"5AFab","c48f15c996f74efa":"7nsJl","238a1a3ffc438b36":"8oDUw","c372a34fa6141152":"3P5S2","fbe408f38144d964":"b4N7s","b2fb241c49dcd0d4":"aiI6w","ec3519fbe923a8e":"1DIeq","5c5766ec08b00b92":"lt2Il","eeac510694115bcc":"kZYn8","f8fd781cd0108946":"27VU5","2e38877d74df2798":"6XeMW","6b6efdc149adc171":"1dUMl","54efb93c55cefac0":"bPhaJ","1ac77c0e20c96502":"1eRm4","2484fce43ac1090b":"6op3x","1558f739a84b8546":"hxIdu","94b52610be12a816":"9gNTL","dcbb8ee3f2fb0d5":"eAMEl","23e8a5cd260922a6":"3cpMv","9157010ce488925c":"6HrSX","1645601d00a6dae8":"e9jqN","24e7cbec3870640a":"eL1qt","2f65afb6e2833770":"Yhvs6","ee6fb870c02d4e5f":"2sNrV","91077b1a56a6d18a":"8hyQp","ed2cb41eeee95b9f":"5VfAd","af43af67adaf0d68":"jwsFb","7bd03af89cf54cf4":"3KmtT","8aad0c0921e4cdc5":"hWNX9","311d55efcacf39ca":"imjQc","aee2bd5a0a04a4fd":"02XUZ","9b95219af1089dea":"1eZSw","62b1ef618e7ec56b":"bJpYG","75c7acd41d68cfaf":"83uZ7","5dc0d046b19de492":"1VO0Z"}],"8G6lx":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"b5PCP":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"aFAvd":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultGetter = void 0;
/**
 * Default getter which just does a simple property access. Returns
 * undefined if the key is not set.
 *
 * @param carrier
 * @param key
 */ function defaultGetter(carrier, key) {
    return carrier[key];
}
exports.defaultGetter = defaultGetter;

},{}],"fY7Xi":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"aL3r7":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_HTTP_TEXT_PROPAGATOR = exports.NoopHttpTextPropagator = void 0;
/**
 * No-op implementations of {@link HttpTextPropagator}.
 */ var NoopHttpTextPropagator = /** @class */ function() {
    function NoopHttpTextPropagator() {}
    /** Noop inject function does nothing */ NoopHttpTextPropagator.prototype.inject = function(context, carrier, setter) {};
    /** Noop extract function does nothing and returns the input context */ NoopHttpTextPropagator.prototype.extract = function(context, carrier, getter) {
        return context;
    };
    return NoopHttpTextPropagator;
}();
exports.NoopHttpTextPropagator = NoopHttpTextPropagator;
exports.NOOP_HTTP_TEXT_PROPAGATOR = new NoopHttpTextPropagator();

},{}],"fauRI":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.defaultSetter = void 0;
/**
 * Default setter which sets value via direct property access
 *
 * @param carrier
 * @param key
 */ function defaultSetter(carrier, key, value) {
    carrier[key] = value;
}
exports.defaultSetter = defaultSetter;

},{}],"awEW0":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"5AFab":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EntryTtl = void 0;
/**
 * EntryTtl is an integer that represents number of hops an entry can propagate.
 *
 * For now, ONLY special values (0 and -1) are supported.
 */ var EntryTtl;
(function(EntryTtl) {
    /**
     * NO_PROPAGATION is considered to have local context and is used within the
     * process it created.
     */ EntryTtl[EntryTtl["NO_PROPAGATION"] = 0] = "NO_PROPAGATION";
    /** UNLIMITED_PROPAGATION can propagate unlimited hops. */ EntryTtl[EntryTtl["UNLIMITED_PROPAGATION"] = -1] = "UNLIMITED_PROPAGATION";
})(EntryTtl = exports.EntryTtl || (exports.EntryTtl = {}));

},{}],"7nsJl":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"8oDUw":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"3P5S2":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"b4N7s":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"aiI6w":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValueType = void 0;
/** The Type of value. It describes how the data is reported. */ var ValueType;
(function(ValueType) {
    ValueType[ValueType["INT"] = 0] = "INT";
    ValueType[ValueType["DOUBLE"] = 1] = "DOUBLE";
})(ValueType = exports.ValueType || (exports.ValueType = {}));

},{}],"1DIeq":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (b.hasOwnProperty(p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_BATCH_OBSERVER_METRIC = exports.NOOP_SUM_OBSERVER_METRIC = exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = exports.NOOP_VALUE_OBSERVER_METRIC = exports.NOOP_BOUND_BASE_OBSERVER = exports.NOOP_VALUE_RECORDER_METRIC = exports.NOOP_BOUND_VALUE_RECORDER = exports.NOOP_COUNTER_METRIC = exports.NOOP_BOUND_COUNTER = exports.NOOP_METER = exports.NoopBoundBaseObserver = exports.NoopBoundValueRecorder = exports.NoopBoundCounter = exports.NoopBatchObserverMetric = exports.NoopBaseObserverMetric = exports.NoopValueRecorderMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
/**
 * NoopMeter is a noop implementation of the {@link Meter} interface. It reuses
 * constant NoopMetrics for all of its methods.
 */ var NoopMeter = /** @class */ function() {
    function NoopMeter() {}
    /**
     * Returns constant noop value recorder.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */ NoopMeter.prototype.createValueRecorder = function(name, options) {
        return exports.NOOP_VALUE_RECORDER_METRIC;
    };
    /**
     * Returns a constant noop counter.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */ NoopMeter.prototype.createCounter = function(name, options) {
        return exports.NOOP_COUNTER_METRIC;
    };
    /**
     * Returns a constant noop UpDownCounter.
     * @param name the name of the metric.
     * @param [options] the metric options.
     */ NoopMeter.prototype.createUpDownCounter = function(name, options) {
        return exports.NOOP_COUNTER_METRIC;
    };
    /**
     * Returns constant noop value observer.
     * @param name the name of the metric.
     * @param [options] the metric options.
     * @param [callback] the value observer callback
     */ NoopMeter.prototype.createValueObserver = function(name, options, callback) {
        return exports.NOOP_VALUE_OBSERVER_METRIC;
    };
    /**
     * Returns constant noop batch observer.
     * @param name the name of the metric.
     * @param callback the batch observer callback
     */ NoopMeter.prototype.createBatchObserver = function(name, callback) {
        return exports.NOOP_BATCH_OBSERVER_METRIC;
    };
    return NoopMeter;
}();
exports.NoopMeter = NoopMeter;
var NoopMetric = /** @class */ function() {
    function NoopMetric(instrument) {
        this._instrument = instrument;
    }
    /**
     * Returns a Bound Instrument associated with specified Labels.
     * It is recommended to keep a reference to the Bound Instrument instead of
     * always calling this method for every operations.
     * @param labels key-values pairs that are associated with a specific metric
     *     that you want to record.
     */ NoopMetric.prototype.bind = function(labels) {
        return this._instrument;
    };
    /**
     * Removes the Binding from the metric, if it is present.
     * @param labels key-values pairs that are associated with a specific metric.
     */ NoopMetric.prototype.unbind = function(labels) {
        return;
    };
    /**
     * Clears all timeseries from the Metric.
     */ NoopMetric.prototype.clear = function() {
        return;
    };
    return NoopMetric;
}();
exports.NoopMetric = NoopMetric;
var NoopCounterMetric = /** @class */ function(_super) {
    __extends(NoopCounterMetric, _super);
    function NoopCounterMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric.prototype.add = function(value, labels) {
        this.bind(labels).add(value);
    };
    return NoopCounterMetric;
}(NoopMetric);
exports.NoopCounterMetric = NoopCounterMetric;
var NoopValueRecorderMetric = /** @class */ function(_super) {
    __extends(NoopValueRecorderMetric, _super);
    function NoopValueRecorderMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopValueRecorderMetric.prototype.record = function(value, labels, correlationContext, spanContext) {
        if (typeof correlationContext === 'undefined') this.bind(labels).record(value);
        else if (typeof spanContext === 'undefined') this.bind(labels).record(value, correlationContext);
        else this.bind(labels).record(value, correlationContext, spanContext);
    };
    return NoopValueRecorderMetric;
}(NoopMetric);
exports.NoopValueRecorderMetric = NoopValueRecorderMetric;
var NoopBaseObserverMetric = /** @class */ function(_super) {
    __extends(NoopBaseObserverMetric, _super);
    function NoopBaseObserverMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopBaseObserverMetric.prototype.observation = function() {
        return {
            observer: this,
            value: 0
        };
    };
    return NoopBaseObserverMetric;
}(NoopMetric);
exports.NoopBaseObserverMetric = NoopBaseObserverMetric;
var NoopBatchObserverMetric = /** @class */ function(_super) {
    __extends(NoopBatchObserverMetric, _super);
    function NoopBatchObserverMetric() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopBatchObserverMetric;
}(NoopMetric);
exports.NoopBatchObserverMetric = NoopBatchObserverMetric;
var NoopBoundCounter = /** @class */ function() {
    function NoopBoundCounter() {}
    NoopBoundCounter.prototype.add = function(value) {
        return;
    };
    return NoopBoundCounter;
}();
exports.NoopBoundCounter = NoopBoundCounter;
var NoopBoundValueRecorder = /** @class */ function() {
    function NoopBoundValueRecorder() {}
    NoopBoundValueRecorder.prototype.record = function(value, correlationContext, spanContext) {
        return;
    };
    return NoopBoundValueRecorder;
}();
exports.NoopBoundValueRecorder = NoopBoundValueRecorder;
var NoopBoundBaseObserver = /** @class */ function() {
    function NoopBoundBaseObserver() {}
    NoopBoundBaseObserver.prototype.update = function(value) {};
    return NoopBoundBaseObserver;
}();
exports.NoopBoundBaseObserver = NoopBoundBaseObserver;
exports.NOOP_METER = new NoopMeter();
exports.NOOP_BOUND_COUNTER = new NoopBoundCounter();
exports.NOOP_COUNTER_METRIC = new NoopCounterMetric(exports.NOOP_BOUND_COUNTER);
exports.NOOP_BOUND_VALUE_RECORDER = new NoopBoundValueRecorder();
exports.NOOP_VALUE_RECORDER_METRIC = new NoopValueRecorderMetric(exports.NOOP_BOUND_VALUE_RECORDER);
exports.NOOP_BOUND_BASE_OBSERVER = new NoopBoundBaseObserver();
exports.NOOP_VALUE_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
exports.NOOP_UP_DOWN_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
exports.NOOP_SUM_OBSERVER_METRIC = new NoopBaseObserverMetric(exports.NOOP_BOUND_BASE_OBSERVER);
exports.NOOP_BATCH_OBSERVER_METRIC = new NoopBatchObserverMetric();

},{}],"lt2Il":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;
var NoopMeter_1 = require("f5c417495db2fd7b");
/**
 * An implementation of the {@link MeterProvider} which returns an impotent Meter
 * for all calls to `getMeter`
 */ var NoopMeterProvider = /** @class */ function() {
    function NoopMeterProvider() {}
    NoopMeterProvider.prototype.getMeter = function(_name, _version) {
        return NoopMeter_1.NOOP_METER;
    };
    return NoopMeterProvider;
}();
exports.NoopMeterProvider = NoopMeterProvider;
exports.NOOP_METER_PROVIDER = new NoopMeterProvider();

},{"f5c417495db2fd7b":"1DIeq"}],"kZYn8":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"27VU5":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"6XeMW":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"1dUMl":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"bPhaJ":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"1eRm4":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"6op3x":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"hxIdu":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_SPAN = exports.NoopSpan = exports.INVALID_SPAN_ID = exports.INVALID_TRACE_ID = void 0;
var trace_flags_1 = require("9f69a34623201265");
exports.INVALID_TRACE_ID = '0';
exports.INVALID_SPAN_ID = '0';
var INVALID_SPAN_CONTEXT = {
    traceId: exports.INVALID_TRACE_ID,
    spanId: exports.INVALID_SPAN_ID,
    traceFlags: trace_flags_1.TraceFlags.NONE
};
/**
 * The NoopSpan is the default {@link Span} that is used when no Span
 * implementation is available. All operations are no-op including context
 * propagation.
 */ var NoopSpan = /** @class */ function() {
    function NoopSpan(_spanContext) {
        if (_spanContext === void 0) _spanContext = INVALID_SPAN_CONTEXT;
        this._spanContext = _spanContext;
    }
    // Returns a SpanContext.
    NoopSpan.prototype.context = function() {
        return this._spanContext;
    };
    // By default does nothing
    NoopSpan.prototype.setAttribute = function(key, value) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.setAttributes = function(attributes) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.addEvent = function(name, attributes) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.setStatus = function(status) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.updateName = function(name) {
        return this;
    };
    // By default does nothing
    NoopSpan.prototype.end = function(endTime) {};
    // isRecording always returns false for noopSpan.
    NoopSpan.prototype.isRecording = function() {
        return false;
    };
    return NoopSpan;
}();
exports.NoopSpan = NoopSpan;
exports.NOOP_SPAN = new NoopSpan();

},{"9f69a34623201265":"jwsFb"}],"jwsFb":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TraceFlags = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var TraceFlags;
(function(TraceFlags) {
    /** Represents no flag set. */ TraceFlags[TraceFlags["NONE"] = 0] = "NONE";
    /** Bit to represent whether trace is sampled in trace flags. */ TraceFlags[TraceFlags["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags = exports.TraceFlags || (exports.TraceFlags = {}));

},{}],"9gNTL":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_TRACER = exports.NoopTracer = void 0;
var NoopSpan_1 = require("bbbd0cdb2381c72c");
/**
 * No-op implementations of {@link Tracer}.
 */ var NoopTracer = /** @class */ function() {
    function NoopTracer() {}
    NoopTracer.prototype.getCurrentSpan = function() {
        return NoopSpan_1.NOOP_SPAN;
    };
    // startSpan starts a noop span.
    NoopTracer.prototype.startSpan = function(name, options) {
        return NoopSpan_1.NOOP_SPAN;
    };
    NoopTracer.prototype.withSpan = function(span, fn) {
        return fn();
    };
    NoopTracer.prototype.bind = function(target, span) {
        return target;
    };
    return NoopTracer;
}();
exports.NoopTracer = NoopTracer;
exports.NOOP_TRACER = new NoopTracer();

},{"bbbd0cdb2381c72c":"hxIdu"}],"eAMEl":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NOOP_TRACER_PROVIDER = exports.NoopTracerProvider = void 0;
var NoopTracer_1 = require("54b6ae2ccdecbcb3");
/**
 * An implementation of the {@link TracerProvider} which returns an impotent
 * Tracer for all calls to `getTracer`.
 *
 * All operations are no-op.
 */ var NoopTracerProvider = /** @class */ function() {
    function NoopTracerProvider() {}
    NoopTracerProvider.prototype.getTracer = function(_name, _version) {
        return NoopTracer_1.NOOP_TRACER;
    };
    return NoopTracerProvider;
}();
exports.NoopTracerProvider = NoopTracerProvider;
exports.NOOP_TRACER_PROVIDER = new NoopTracerProvider();

},{"54b6ae2ccdecbcb3":"9gNTL"}],"3cpMv":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"6HrSX":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SamplingDecision = void 0;
/**
 * A sampling decision that determines how a {@link Span} will be recorded
 * and collected.
 */ var SamplingDecision;
(function(SamplingDecision) {
    /**
     * `Span.isRecording() === false`, span will not be recorded and all events
     * and attributes will be dropped.
     */ SamplingDecision[SamplingDecision["NOT_RECORD"] = 0] = "NOT_RECORD";
    /**
     * `Span.isRecording() === true`, but `Sampled` flag in {@link TraceFlags}
     * MUST NOT be set.
     */ SamplingDecision[SamplingDecision["RECORD"] = 1] = "RECORD";
    /**
     * `Span.isRecording() === true` AND `Sampled` flag in {@link TraceFlags}
     * MUST be set.
     */ SamplingDecision[SamplingDecision["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));

},{}],"e9jqN":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"eL1qt":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SpanKind = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var SpanKind;
(function(SpanKind) {
    /** Default value. Indicates that the span is used internally. */ SpanKind[SpanKind["INTERNAL"] = 0] = "INTERNAL";
    /**
     * Indicates that the span covers server-side handling of an RPC or other
     * remote request.
     */ SpanKind[SpanKind["SERVER"] = 1] = "SERVER";
    /**
     * Indicates that the span covers the client-side wrapper around an RPC or
     * other remote request.
     */ SpanKind[SpanKind["CLIENT"] = 2] = "CLIENT";
    /**
     * Indicates that the span describes producer sending a message to a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["PRODUCER"] = 3] = "PRODUCER";
    /**
     * Indicates that the span describes consumer receiving a message from a
     * broker. Unlike client and server, there is no direct critical path latency
     * relationship between producer and consumer spans.
     */ SpanKind[SpanKind["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind = exports.SpanKind || (exports.SpanKind = {}));

},{}],"Yhvs6":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"2sNrV":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"8hyQp":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CanonicalCode = void 0;
/**
 * An enumeration of canonical status codes.
 */ var CanonicalCode;
(function(CanonicalCode) {
    /**
     * Not an error; returned on success
     */ CanonicalCode[CanonicalCode["OK"] = 0] = "OK";
    /**
     * The operation was cancelled (typically by the caller).
     */ CanonicalCode[CanonicalCode["CANCELLED"] = 1] = "CANCELLED";
    /**
     * Unknown error.  An example of where this error may be returned is
     * if a status value received from another address space belongs to
     * an error-space that is not known in this address space.  Also
     * errors raised by APIs that do not return enough error information
     * may be converted to this error.
     */ CanonicalCode[CanonicalCode["UNKNOWN"] = 2] = "UNKNOWN";
    /**
     * Client specified an invalid argument.  Note that this differs
     * from FAILED_PRECONDITION.  INVALID_ARGUMENT indicates arguments
     * that are problematic regardless of the state of the system
     * (e.g., a malformed file name).
     */ CanonicalCode[CanonicalCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    /**
     * Deadline expired before operation could complete.  For operations
     * that change the state of the system, this error may be returned
     * even if the operation has completed successfully.  For example, a
     * successful response from a server could have been delayed long
     * enough for the deadline to expire.
     */ CanonicalCode[CanonicalCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    /**
     * Some requested entity (e.g., file or directory) was not found.
     */ CanonicalCode[CanonicalCode["NOT_FOUND"] = 5] = "NOT_FOUND";
    /**
     * Some entity that we attempted to create (e.g., file or directory)
     * already exists.
     */ CanonicalCode[CanonicalCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    /**
     * The caller does not have permission to execute the specified
     * operation.  PERMISSION_DENIED must not be used for rejections
     * caused by exhausting some resource (use RESOURCE_EXHAUSTED
     * instead for those errors).  PERMISSION_DENIED must not be
     * used if the caller can not be identified (use UNAUTHENTICATED
     * instead for those errors).
     */ CanonicalCode[CanonicalCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    /**
     * Some resource has been exhausted, perhaps a per-user quota, or
     * perhaps the entire file system is out of space.
     */ CanonicalCode[CanonicalCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    /**
     * Operation was rejected because the system is not in a state
     * required for the operation's execution.  For example, directory
     * to be deleted may be non-empty, an rmdir operation is applied to
     * a non-directory, etc.
     *
     * A litmus test that may help a service implementor in deciding
     * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
     *
     *  - Use UNAVAILABLE if the client can retry just the failing call.
     *  - Use ABORTED if the client should retry at a higher-level
     *    (e.g., restarting a read-modify-write sequence).
     *  - Use FAILED_PRECONDITION if the client should not retry until
     *    the system state has been explicitly fixed.  E.g., if an "rmdir"
     *    fails because the directory is non-empty, FAILED_PRECONDITION
     *    should be returned since the client should not retry unless
     *    they have first fixed up the directory by deleting files from it.
     *  - Use FAILED_PRECONDITION if the client performs conditional
     *    REST Get/Update/Delete on a resource and the resource on the
     *    server does not match the condition. E.g., conflicting
     *    read-modify-write on the same resource.
     */ CanonicalCode[CanonicalCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    /**
     * The operation was aborted, typically due to a concurrency issue
     * like sequencer check failures, transaction aborts, etc.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */ CanonicalCode[CanonicalCode["ABORTED"] = 10] = "ABORTED";
    /**
     * Operation was attempted past the valid range.  E.g., seeking or
     * reading past end of file.
     *
     * Unlike INVALID_ARGUMENT, this error indicates a problem that may
     * be fixed if the system state changes. For example, a 32-bit file
     * system will generate INVALID_ARGUMENT if asked to read at an
     * offset that is not in the range [0,2^32-1], but it will generate
     * OUT_OF_RANGE if asked to read from an offset past the current
     * file size.
     *
     * There is a fair bit of overlap between FAILED_PRECONDITION and
     * OUT_OF_RANGE.  We recommend using OUT_OF_RANGE (the more specific
     * error) when it applies so that callers who are iterating through
     * a space can easily look for an OUT_OF_RANGE error to detect when
     * they are done.
     */ CanonicalCode[CanonicalCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    /**
     * Operation is not implemented or not supported/enabled in this service.
     */ CanonicalCode[CanonicalCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    /**
     * Internal errors.  Means some invariants expected by underlying
     * system has been broken.  If you see one of these errors,
     * something is very broken.
     */ CanonicalCode[CanonicalCode["INTERNAL"] = 13] = "INTERNAL";
    /**
     * The service is currently unavailable.  This is a most likely a
     * transient condition and may be corrected by retrying with
     * a backoff.
     *
     * See litmus test above for deciding between FAILED_PRECONDITION,
     * ABORTED, and UNAVAILABLE.
     */ CanonicalCode[CanonicalCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    /**
     * Unrecoverable data loss or corruption.
     */ CanonicalCode[CanonicalCode["DATA_LOSS"] = 15] = "DATA_LOSS";
    /**
     * The request does not have valid authentication credentials for the
     * operation.
     */ CanonicalCode[CanonicalCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
})(CanonicalCode = exports.CanonicalCode || (exports.CanonicalCode = {}));

},{}],"5VfAd":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"3KmtT":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"hWNX9":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"imjQc":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"02XUZ":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(require("51127738aef95fdd"), exports);
__exportStar(require("f61f67b53705a19"), exports);
__exportStar(require("92f024a3f5797c68"), exports);

},{"51127738aef95fdd":"iQTJ5","f61f67b53705a19":"hB9Cp","92f024a3f5797c68":"f3Wrc"}],"iQTJ5":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});

},{}],"hB9Cp":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Context = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var Context = /** @class */ function() {
    /**
     * Construct a new context which inherits values from an optional parent context.
     *
     * @param parentContext a context from which to inherit values
     */ function Context(parentContext) {
        this._currentContext = parentContext ? new Map(parentContext) : new Map();
    }
    /** Get a key to uniquely identify a context value */ Context.createKey = function(description) {
        return Symbol(description);
    };
    /**
     * Get a value from the context.
     *
     * @param key key which identifies a context value
     */ Context.prototype.getValue = function(key) {
        return this._currentContext.get(key);
    };
    /**
     * Create a new context which inherits from this context and has
     * the given key set to the given value.
     *
     * @param key context key for which to set the value
     * @param value value to set for the given key
     */ Context.prototype.setValue = function(key, value) {
        var context = new Context(this._currentContext);
        context._currentContext.set(key, value);
        return context;
    };
    /**
     * Return a new context which inherits from this context but does
     * not contain a value for the given key.
     *
     * @param key context key for which to clear a value
     */ Context.prototype.deleteValue = function(key) {
        var context = new Context(this._currentContext);
        context._currentContext.delete(key);
        return context;
    };
    /** The root context is used as the default parent context when there is no active context */ Context.ROOT_CONTEXT = new Context();
    /**
     * This is another identifier to the root context which allows developers to easily search the
     * codebase for direct uses of context which need to be removed in later PRs.
     *
     * It's existence is temporary and it should be removed when all references are fixed.
     */ Context.TODO = Context.ROOT_CONTEXT;
    return Context;
}();
exports.Context = Context;

},{}],"f3Wrc":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NoopContextManager = void 0;
var context_1 = require("7bc58cc1e439d501");
var NoopContextManager = /** @class */ function() {
    function NoopContextManager() {}
    NoopContextManager.prototype.active = function() {
        return context_1.Context.ROOT_CONTEXT;
    };
    NoopContextManager.prototype.with = function(context, fn) {
        return fn();
    };
    NoopContextManager.prototype.bind = function(target, context) {
        return target;
    };
    NoopContextManager.prototype.enable = function() {
        return this;
    };
    NoopContextManager.prototype.disable = function() {
        return this;
    };
    return NoopContextManager;
}();
exports.NoopContextManager = NoopContextManager;

},{"7bc58cc1e439d501":"hB9Cp"}],"1eZSw":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ContextAPI = void 0;
var context_base_1 = require("9986b39e34098bfc");
var global_utils_1 = require("ec142083e6485f62");
var NOOP_CONTEXT_MANAGER = new context_base_1.NoopContextManager();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Context API
 */ var ContextAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function ContextAPI() {}
    /** Get the singleton instance of the Context API */ ContextAPI.getInstance = function() {
        if (!this._instance) this._instance = new ContextAPI();
        return this._instance;
    };
    /**
     * Set the current context manager. Returns the initialized context manager
     */ ContextAPI.prototype.setGlobalContextManager = function(contextManager) {
        if (global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY]) // global context manager has already been set
        return this._getContextManager();
        global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, contextManager, NOOP_CONTEXT_MANAGER);
        return contextManager;
    };
    /**
     * Get the currently active context
     */ ContextAPI.prototype.active = function() {
        return this._getContextManager().active();
    };
    /**
     * Execute a function with an active context
     *
     * @param context context to be active during function execution
     * @param fn function to execute in a context
     */ ContextAPI.prototype.with = function(context, fn) {
        return this._getContextManager().with(context, fn);
    };
    /**
     * Bind a context to a target function or event emitter
     *
     * @param target function or event emitter to bind
     * @param context context to bind to the event emitter or function. Defaults to the currently active context
     */ ContextAPI.prototype.bind = function(target, context) {
        if (context === void 0) context = this.active();
        return this._getContextManager().bind(target, context);
    };
    ContextAPI.prototype._getContextManager = function() {
        var _a, _b;
        return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NOOP_CONTEXT_MANAGER;
    };
    /** Disable and remove the global context manager */ ContextAPI.prototype.disable = function() {
        this._getContextManager().disable();
        delete global_utils_1._global[global_utils_1.GLOBAL_CONTEXT_MANAGER_API_KEY];
    };
    return ContextAPI;
}();
exports.ContextAPI = ContextAPI;

},{"9986b39e34098bfc":"02XUZ","ec142083e6485f62":"6ojaE"}],"6ojaE":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.API_BACKWARDS_COMPATIBILITY_VERSION = exports.makeGetter = exports._global = exports.GLOBAL_TRACE_API_KEY = exports.GLOBAL_PROPAGATION_API_KEY = exports.GLOBAL_METRICS_API_KEY = exports.GLOBAL_CONTEXT_MANAGER_API_KEY = void 0;
var platform_1 = require("7b9c1822e4d616b7");
exports.GLOBAL_CONTEXT_MANAGER_API_KEY = Symbol.for('io.opentelemetry.js.api.context');
exports.GLOBAL_METRICS_API_KEY = Symbol.for('io.opentelemetry.js.api.metrics');
exports.GLOBAL_PROPAGATION_API_KEY = Symbol.for('io.opentelemetry.js.api.propagation');
exports.GLOBAL_TRACE_API_KEY = Symbol.for('io.opentelemetry.js.api.trace');
exports._global = platform_1._globalThis;
/**
 * Make a function which accepts a version integer and returns the instance of an API if the version
 * is compatible, or a fallback version (usually NOOP) if it is not.
 *
 * @param requiredVersion Backwards compatibility version which is required to return the instance
 * @param instance Instance which should be returned if the required version is compatible
 * @param fallback Fallback instance, usually NOOP, which will be returned if the required version is not compatible
 */ function makeGetter(requiredVersion, instance, fallback) {
    return function(version) {
        return version === requiredVersion ? instance : fallback;
    };
}
exports.makeGetter = makeGetter;
/**
 * A number which should be incremented each time a backwards incompatible
 * change is made to the API. This number is used when an API package
 * attempts to access the global API to ensure it is getting a compatible
 * version. If the global API is not compatible with the API package
 * attempting to get it, a NOOP API implementation will be returned.
 */ exports.API_BACKWARDS_COMPATIBILITY_VERSION = 0;

},{"7b9c1822e4d616b7":"jNFpO"}],"jNFpO":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !exports1.hasOwnProperty(p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(require("337dbc89a08df3fd"), exports);

},{"337dbc89a08df3fd":"bJh3b"}],"bJh3b":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports._globalThis = void 0;
/** only globals that common to node and browsers are allowed */ // eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef
exports._globalThis = typeof globalThis === 'object' ? globalThis : window;

},{}],"bJpYG":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TraceAPI = void 0;
var NoopTracerProvider_1 = require("df18836a302365d3");
var global_utils_1 = require("73bcf83a521366cb");
/**
 * Singleton object which represents the entry point to the OpenTelemetry Tracing API
 */ var TraceAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function TraceAPI() {}
    /** Get the singleton instance of the Trace API */ TraceAPI.getInstance = function() {
        if (!this._instance) this._instance = new TraceAPI();
        return this._instance;
    };
    /**
     * Set the current global tracer. Returns the initialized global tracer provider
     */ TraceAPI.prototype.setGlobalTracerProvider = function(provider) {
        if (global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY]) // global tracer provider has already been set
        return this.getTracerProvider();
        global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopTracerProvider_1.NOOP_TRACER_PROVIDER);
        return this.getTracerProvider();
    };
    /**
     * Returns the global tracer provider.
     */ TraceAPI.prototype.getTracerProvider = function() {
        var _a, _b;
        return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopTracerProvider_1.NOOP_TRACER_PROVIDER;
    };
    /**
     * Returns a tracer from the global tracer provider.
     */ TraceAPI.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
    };
    /** Remove the global tracer provider */ TraceAPI.prototype.disable = function() {
        delete global_utils_1._global[global_utils_1.GLOBAL_TRACE_API_KEY];
    };
    return TraceAPI;
}();
exports.TraceAPI = TraceAPI;

},{"df18836a302365d3":"eAMEl","73bcf83a521366cb":"6ojaE"}],"83uZ7":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MetricsAPI = void 0;
var NoopMeterProvider_1 = require("bb44cc22894a7def");
var global_utils_1 = require("4875b920903bcff3");
/**
 * Singleton object which represents the entry point to the OpenTelemetry Metrics API
 */ var MetricsAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function MetricsAPI() {}
    /** Get the singleton instance of the Metrics API */ MetricsAPI.getInstance = function() {
        if (!this._instance) this._instance = new MetricsAPI();
        return this._instance;
    };
    /**
     * Set the current global meter. Returns the initialized global meter provider.
     */ MetricsAPI.prototype.setGlobalMeterProvider = function(provider) {
        if (global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY]) // global meter provider has already been set
        return this.getMeterProvider();
        global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopMeterProvider_1.NOOP_METER_PROVIDER);
        return provider;
    };
    /**
     * Returns the global meter provider.
     */ MetricsAPI.prototype.getMeterProvider = function() {
        var _a, _b;
        return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopMeterProvider_1.NOOP_METER_PROVIDER;
    };
    /**
     * Returns a meter from the global meter provider.
     */ MetricsAPI.prototype.getMeter = function(name, version) {
        return this.getMeterProvider().getMeter(name, version);
    };
    /** Remove the global meter provider */ MetricsAPI.prototype.disable = function() {
        delete global_utils_1._global[global_utils_1.GLOBAL_METRICS_API_KEY];
    };
    return MetricsAPI;
}();
exports.MetricsAPI = MetricsAPI;

},{"bb44cc22894a7def":"lt2Il","4875b920903bcff3":"6ojaE"}],"1VO0Z":[function(require,module,exports,__globalThis) {
"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PropagationAPI = void 0;
var getter_1 = require("3679781dc94f20aa");
var NoopHttpTextPropagator_1 = require("62b6859195cff5a2");
var setter_1 = require("643382565b7ae12c");
var context_1 = require("66fe0a9094283814");
var global_utils_1 = require("9caa4c55b116d863");
var contextApi = context_1.ContextAPI.getInstance();
/**
 * Singleton object which represents the entry point to the OpenTelemetry Propagation API
 */ var PropagationAPI = /** @class */ function() {
    /** Empty private constructor prevents end users from constructing a new instance of the API */ function PropagationAPI() {}
    /** Get the singleton instance of the Propagator API */ PropagationAPI.getInstance = function() {
        if (!this._instance) this._instance = new PropagationAPI();
        return this._instance;
    };
    /**
     * Set the current propagator. Returns the initialized propagator
     */ PropagationAPI.prototype.setGlobalPropagator = function(propagator) {
        if (global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY]) // global propagator has already been set
        return this._getGlobalPropagator();
        global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY] = global_utils_1.makeGetter(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, propagator, NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR);
        return propagator;
    };
    /**
     * Inject context into a carrier to be propagated inter-process
     *
     * @param carrier carrier to inject context into
     * @param setter Function used to set values on the carrier
     * @param context Context carrying tracing data to inject. Defaults to the currently active context.
     */ PropagationAPI.prototype.inject = function(carrier, setter, context) {
        if (setter === void 0) setter = setter_1.defaultSetter;
        if (context === void 0) context = contextApi.active();
        return this._getGlobalPropagator().inject(context, carrier, setter);
    };
    /**
     * Extract context from a carrier
     *
     * @param carrier Carrier to extract context from
     * @param getter Function used to extract keys from a carrier
     * @param context Context which the newly created context will inherit from. Defaults to the currently active context.
     */ PropagationAPI.prototype.extract = function(carrier, getter, context) {
        if (getter === void 0) getter = getter_1.defaultGetter;
        if (context === void 0) context = contextApi.active();
        return this._getGlobalPropagator().extract(context, carrier, getter);
    };
    /** Remove the global propagator */ PropagationAPI.prototype.disable = function() {
        delete global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY];
    };
    PropagationAPI.prototype._getGlobalPropagator = function() {
        var _a, _b;
        return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_PROPAGATION_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : NoopHttpTextPropagator_1.NOOP_HTTP_TEXT_PROPAGATOR;
    };
    return PropagationAPI;
}();
exports.PropagationAPI = PropagationAPI;

},{"3679781dc94f20aa":"aFAvd","62b6859195cff5a2":"aL3r7","643382565b7ae12c":"fauRI","66fe0a9094283814":"1eZSw","9caa4c55b116d863":"6ojaE"}],"LBQN1":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createSpan", ()=>createSpan);
var _coreTracing = require("@azure/core-tracing");
const createSpan = (0, _coreTracing.createSpanFunction)({
    packagePrefix: "Azure.Communication",
    namespace: "Microsoft.Communication"
});

},{"@azure/core-tracing":"gxPwz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gxPwz":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTracer", ()=>(0, _tracerProxy.getTracer));
parcelHelpers.export(exports, "setTracer", ()=>(0, _tracerProxy.setTracer));
// Tracers and wrappers
parcelHelpers.export(exports, "NoOpSpan", ()=>(0, _noOpSpan.NoOpSpan));
parcelHelpers.export(exports, "NoOpTracer", ()=>(0, _noOpTracer.NoOpTracer));
parcelHelpers.export(exports, "OpenCensusSpanWrapper", ()=>(0, _openCensusSpanWrapper.OpenCensusSpanWrapper));
parcelHelpers.export(exports, "OpenCensusTracerWrapper", ()=>(0, _openCensusTracerWrapper.OpenCensusTracerWrapper));
parcelHelpers.export(exports, "TestTracer", ()=>(0, _testTracer.TestTracer));
parcelHelpers.export(exports, "TestSpan", ()=>(0, _testSpan.TestSpan));
parcelHelpers.export(exports, "createSpanFunction", ()=>(0, _createSpan.createSpanFunction));
// Utilities
parcelHelpers.export(exports, "extractSpanContextFromTraceParentHeader", ()=>(0, _traceParentHeader.extractSpanContextFromTraceParentHeader));
parcelHelpers.export(exports, "getTraceParentHeader", ()=>(0, _traceParentHeader.getTraceParentHeader));
var _tracerProxy = require("./tracerProxy");
var _noOpSpan = require("./tracers/noop/noOpSpan");
var _noOpTracer = require("./tracers/noop/noOpTracer");
var _openCensusSpanWrapper = require("./tracers/opencensus/openCensusSpanWrapper");
var _openCensusTracerWrapper = require("./tracers/opencensus/openCensusTracerWrapper");
var _testTracer = require("./tracers/test/testTracer");
var _testSpan = require("./tracers/test/testSpan");
var _createSpan = require("./createSpan");
var _traceParentHeader = require("./utils/traceParentHeader");

},{"./tracerProxy":false,"./tracers/noop/noOpSpan":false,"./tracers/noop/noOpTracer":false,"./tracers/opencensus/openCensusSpanWrapper":false,"./tracers/opencensus/openCensusTracerWrapper":false,"./tracers/test/testTracer":false,"./tracers/test/testSpan":false,"./createSpan":"XSpHS","./utils/traceParentHeader":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hzrAI":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sets the global tracer, enabling tracing for the Azure SDK.
 * @param tracer - An OpenTelemetry Tracer instance.
 */ parcelHelpers.export(exports, "setTracer", ()=>setTracer);
/**
 * Retrieves the active tracer, or returns a
 * no-op implementation if one is not set.
 */ parcelHelpers.export(exports, "getTracer", ()=>getTracer);
var _noOpTracer = require("./tracers/noop/noOpTracer");
var _cache = require("./utils/cache");
var defaultTracer;
function getDefaultTracer() {
    if (!defaultTracer) defaultTracer = new (0, _noOpTracer.NoOpTracer)();
    return defaultTracer;
}
function setTracer(tracer) {
    var cache = (0, _cache.getCache)();
    cache.tracer = tracer;
}
function getTracer() {
    var cache = (0, _cache.getCache)();
    if (!cache.tracer) return getDefaultTracer();
    return cache.tracer;
}

},{"./tracers/noop/noOpTracer":"gdiVM","./utils/cache":"dwRTv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gdiVM":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoOpTracer", ()=>NoOpTracer);
var _noOpSpan = require("./noOpSpan");
/**
 * A no-op implementation of Tracer that can be used when tracing
 * is disabled.
 */ var NoOpTracer = /** @class */ function() {
    function NoOpTracer() {}
    /**
     * Starts a new Span.
     * @param _name - The name of the span.
     * @param _options - The SpanOptions used during Span creation.
     */ NoOpTracer.prototype.startSpan = function(_name, _options) {
        return new (0, _noOpSpan.NoOpSpan)();
    };
    /**
     * Returns the current Span from the current context, if available.
     */ NoOpTracer.prototype.getCurrentSpan = function() {
        return new (0, _noOpSpan.NoOpSpan)();
    };
    /**
     * Executes the given function within the context provided by a Span.
     * @param _span - The span that provides the context.
     * @param fn - The function to be executed.
     */ NoOpTracer.prototype.withSpan = function(_span, fn) {
        return fn();
    };
    /**
     * Bind a Span as the target's scope
     * @param target - An object to bind the scope.
     * @param _span - A specific Span to use. Otherwise, use the current one.
     */ NoOpTracer.prototype.bind = function(target, _span) {
        return target;
    };
    return NoOpTracer;
}();

},{"./noOpSpan":"cvJrZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cvJrZ":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NoOpSpan", ()=>NoOpSpan);
var _api = require("@opentelemetry/api");
/**
 * A no-op implementation of Span that can safely be used without side-effects.
 */ var NoOpSpan = /** @class */ function() {
    function NoOpSpan() {}
    /**
     * Returns the SpanContext associated with this Span.
     */ NoOpSpan.prototype.context = function() {
        return {
            spanId: "",
            traceId: "",
            traceFlags: (0, _api.TraceFlags).NONE
        };
    };
    /**
     * Marks the end of Span execution.
     * @param _endTime - The time to use as the Span's end time. Defaults to
     * the current time.
     */ NoOpSpan.prototype.end = function(_endTime) {
    /* Noop */ };
    /**
     * Sets an attribute on the Span
     * @param _key - The attribute key
     * @param _value - The attribute value
     */ NoOpSpan.prototype.setAttribute = function(_key, _value) {
        return this;
    };
    /**
     * Sets attributes on the Span
     * @param _attributes - The attributes to add
     */ NoOpSpan.prototype.setAttributes = function(_attributes) {
        return this;
    };
    /**
     * Adds an event to the Span
     * @param _name - The name of the event
     * @param _attributes - The associated attributes to add for this event
     */ NoOpSpan.prototype.addEvent = function(_name, _attributes) {
        return this;
    };
    /**
     * Sets a status on the span. Overrides the default of CanonicalCode.OK.
     * @param _status - The status to set.
     */ NoOpSpan.prototype.setStatus = function(_status) {
        return this;
    };
    /**
     * Updates the name of the Span
     * @param _name - the new Span name
     */ NoOpSpan.prototype.updateName = function(_name) {
        return this;
    };
    /**
     * Returns whether this span will be recorded
     */ NoOpSpan.prototype.isRecording = function() {
        return false;
    };
    return NoOpSpan;
}();

},{"@opentelemetry/api":"4XvbA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dwRTv":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCache", ()=>getCache);
var _global = require("./global");
// V1 = OpenTelemetry 0.1
// V2 = OpenTelemetry 0.2
// V3 = OpenTelemetry 0.6.1
var GLOBAL_TRACER_VERSION = 3;
// preview5 shipped with @azure/core-tracing.tracerCache
// and didn't have smart detection for collisions
var GLOBAL_TRACER_SYMBOL = Symbol.for("@azure/core-tracing.tracerCache2");
var cache;
function loadTracerCache() {
    var globalObj = (0, _global.getGlobalObject)();
    var existingCache = globalObj[GLOBAL_TRACER_SYMBOL];
    var setGlobalCache = true;
    if (existingCache) {
        if (existingCache.version === GLOBAL_TRACER_VERSION) cache = existingCache;
        else {
            setGlobalCache = false;
            if (existingCache.tracer) throw new Error("Two incompatible versions of @azure/core-tracing have been loaded.\n          This library is " + GLOBAL_TRACER_VERSION + ", existing is " + existingCache.version + ".");
        }
    }
    if (!cache) cache = {
        tracer: undefined,
        version: GLOBAL_TRACER_VERSION
    };
    if (setGlobalCache) globalObj[GLOBAL_TRACER_SYMBOL] = cache;
}
function getCache() {
    if (!cache) loadTracerCache();
    return cache;
}

},{"./global":"kayXd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kayXd":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getGlobalObject", ()=>getGlobalObject);
function getGlobalObject() {
    return self;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"XSpHS":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a function that can be used to create spans using the global tracer.
 *
 * Usage:
 *
 * ```typescript
 * // once
 * const createSpan = createSpanFunction({ packagePrefix: "Azure.Data.AppConfiguration", namespace: "Microsoft.AppConfiguration" });
 *
 * // in each operation
 * const span = createSpan("deleteConfigurationSetting", operationOptions);
 *    // code...
 * span.end();
 * ```
 *
 * @hidden
 * @param args - allows configuration of the prefix for each span as well as the az.namespace field.
 */ parcelHelpers.export(exports, "createSpanFunction", ()=>createSpanFunction);
var _tslib = require("tslib");
var _api = require("@opentelemetry/api");
var _tracerProxy = require("../src/tracerProxy");
function createSpanFunction(args) {
    return function(operationName, operationOptions) {
        var tracer = (0, _tracerProxy.getTracer)();
        var tracingOptions = (operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) || {};
        var spanOptions = (0, _tslib.__assign)({
            kind: (0, _api.SpanKind).INTERNAL
        }, tracingOptions.spanOptions);
        var spanName = args.packagePrefix ? args.packagePrefix + "." + operationName : operationName;
        var span = tracer.startSpan(spanName, spanOptions);
        if (args.namespace) span.setAttribute("az.namespace", args.namespace);
        var newSpanOptions = tracingOptions.spanOptions || {};
        if (span.isRecording() && args.namespace) newSpanOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tracingOptions.spanOptions), {
            parent: span.context(),
            attributes: (0, _tslib.__assign)((0, _tslib.__assign)({}, spanOptions.attributes), {
                "az.namespace": args.namespace
            })
        });
        var newTracingOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, tracingOptions), {
            spanOptions: newSpanOptions
        });
        var newOperationOptions = (0, _tslib.__assign)((0, _tslib.__assign)({}, operationOptions), {
            tracingOptions: newTracingOptions
        });
        return {
            span: span,
            updatedOptions: newOperationOptions
        };
    };
}

},{"tslib":"iC1Dx","@opentelemetry/api":"4XvbA","../src/tracerProxy":"hzrAI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h5T6K":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The client to do chat operations
 */ parcelHelpers.export(exports, "ChatThreadClient", ()=>ChatThreadClient);
var _tslib = require("tslib");
var _logger = require("./models/logger");
var _constants = require("./constants");
var _communicationCommon = require("@azure/communication-common");
var _coreHttp = require("@azure/core-http");
var _api = require("@opentelemetry/api");
var _tracing = require("./tracing");
var _mappers = require("./models/mappers");
var _src = require("./generated/src");
var _communicationTokenCredentialPolicy = require("./credential/communicationTokenCredentialPolicy");
const minimumTypingIntervalInMilliSeconds = 8000;
class ChatThreadClient {
    /**
     * Gets a chat thread.
     * Returns the chat thread.
     * @param options -  Operation options.
     */ getProperties(options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatClient-GetProperties", options);
            try {
                const _a = yield this.client.chatThread.getChatThreadProperties(this.threadId, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions)), { _response } = _a, result = (0, _tslib.__rest)(_a, [
                    "_response"
                ]);
                return (0, _mappers.mapToChatThreadPropertiesSdkModel)(result);
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Updates a thread's topic.
     * @param topic - The topic needs to be updated to.
     * @param options - Operation options.
     */ updateTopic(topic, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-UpdateTopic", options);
            try {
                yield this.client.chatThread.updateChatThreadProperties(this.threadId, {
                    topic: topic
                }, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions));
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Sends a chat message to a thread identified by threadId.
     * Returns the id of the created message.
     * @param request - Request for sending a message.
     * @param options - Operation options.
     */ sendMessage(request, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-SendMessage", options);
            try {
                // reset typing notification clock
                this.timeOfLastTypingRequest = undefined;
                const _a = yield this.client.chatThread.sendChatMessage(this.threadId, Object.assign(Object.assign({}, request), options), (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions)), { _response } = _a, result = (0, _tslib.__rest)(_a, [
                    "_response"
                ]);
                return result;
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Gets a chat message identified by messageId.
     * Returns the specific message.
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */ getMessage(messageId, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-GetMessage", options);
            try {
                const _a = yield this.client.chatThread.getChatMessage(this.threadId, messageId, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions)), { _response } = _a, result = (0, _tslib.__rest)(_a, [
                    "_response"
                ]);
                return (0, _mappers.mapToChatMessageSdkModel)(result);
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    listMessagesPage(pageSettings, options = {}) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listMessagesPage_1() {
            const requestOptions = (0, _coreHttp.operationOptionsToRequestOptionsBase)(options);
            if (!pageSettings.continuationToken) {
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chatThread.listChatMessages(this.threadId, requestOptions));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value.map((0, _mappers.mapToChatMessageSdkModel), this));
            }
            while(pageSettings.continuationToken){
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chatThread.listChatMessagesNext(this.threadId, pageSettings.continuationToken, requestOptions));
                pageSettings.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value.map((0, _mappers.mapToChatMessageSdkModel), this));
                else break;
            }
        });
    }
    listMessagesAll(options) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listMessagesAll_1() {
            var e_1, _a;
            try {
                for(var _b = (0, _tslib.__asyncValues)(this.listMessagesPage({}, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;){
                    const page = _c.value;
                    yield (0, _tslib.__await)((yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(page))));
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        });
    }
    /**
     * Gets a list of message from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */ listMessages(options = {}) {
        const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-ListMessages", options);
        try {
            const iter = this.listMessagesAll(updatedOptions);
            return {
                next () {
                    return iter.next();
                },
                [Symbol.asyncIterator] () {
                    return this;
                },
                byPage: (settings = {})=>{
                    return this.listMessagesPage(settings, updatedOptions);
                }
            };
        } catch (e) {
            span.setStatus({
                code: (0, _api.CanonicalCode).UNKNOWN,
                message: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Deletes a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */ deleteMessage(messageId, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-DeleteMessage", options);
            try {
                yield this.client.chatThread.deleteChatMessage(this.threadId, messageId, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions));
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Updates a message identified by threadId and messageId
     * @param messageId - The message id of the message.
     * @param options - Operation options.
     */ updateMessage(messageId, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-UpdateMessage", options);
            try {
                yield this.client.chatThread.updateChatMessage(this.threadId, messageId, options, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions));
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Adds the details of chat participants belonging to the thread identified by threadId.
     * @param request - Thread participants' details to add in the thread roster
     * @param options - Operation options.
     */ addParticipants(request, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-AddParticipants", options);
            try {
                const _a = yield this.client.chatThread.addChatParticipants(this.threadId, (0, _mappers.mapToAddChatParticipantsRequestRestModel)(request), (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions)), { _response } = _a, result = (0, _tslib.__rest)(_a, [
                    "_response"
                ]);
                return result;
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    listParticipantsPage(continuationState, options = {}) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listParticipantsPage_1() {
            const requestOptions = (0, _coreHttp.operationOptionsToRequestOptionsBase)(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chatThread.listChatParticipants(this.threadId, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value.map((0, _mappers.mapToChatParticipantSdkModel), this));
            }
            while(continuationState.continuationToken){
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chatThread.listChatParticipantsNext(this.threadId, continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value.map((0, _mappers.mapToChatParticipantSdkModel), this));
                else break;
            }
        });
    }
    listParticipantsAll(options) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listParticipantsAll_1() {
            var e_2, _a;
            try {
                for(var _b = (0, _tslib.__asyncValues)(this.listParticipantsPage({}, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;){
                    const page = _c.value;
                    yield (0, _tslib.__await)((yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(page))));
                }
            } catch (e_2_1) {
                e_2 = {
                    error: e_2_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
                } finally{
                    if (e_2) throw e_2.error;
                }
            }
        });
    }
    /**
     * Gets the participants of the thread identified by threadId.
     * Returns the lists of the participants.
     * @param options - Operation options.
     */ listParticipants(options = {}) {
        const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-ListParticipants", options);
        try {
            const iter = this.listParticipantsAll(updatedOptions);
            return {
                next () {
                    return iter.next();
                },
                [Symbol.asyncIterator] () {
                    return this;
                },
                byPage: (settings = {})=>{
                    return this.listParticipantsPage(settings, updatedOptions);
                }
            };
        } catch (e) {
            span.setStatus({
                code: (0, _api.CanonicalCode).UNKNOWN,
                message: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    /**
     * Removes participant from the thread identified by threadId.
     * @param participant - Thread participant to remove from the thread roster
     * @param options - Operation options.
     */ removeParticipant(participant, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-RemoveParticipant", options);
            try {
                yield this.client.chatThread.removeChatParticipant(this.threadId, (0, _communicationCommon.serializeCommunicationIdentifier)(participant), (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions));
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Sends a typing notification to the thread.
     * Doesn't attempt to send if the time since last notification is smaller than the minimum typing interval
     * @param options - - Operation options
     * @returns True if the typing message notification could be sent, otherwise false.
     */ sendTypingNotification(options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-SendTypingNotification", options);
            try {
                const dateNow = new Date();
                if (this.canPostTypingNotification(dateNow)) {
                    yield this.client.chatThread.sendTypingNotification(this.threadId, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions));
                    this.timeOfLastTypingRequest = dateNow;
                    return true;
                }
                (0, _logger.logger).info(`Typing Notification NOT Send. [thread_id=${this.threadId}]`);
                return false;
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    /**
     * Sends a read receipt to the thread identified by threadId.
     * @param messageId - The message id of the message that user latest read.
     * @param request - Request for sending a read receipt
     * @param options - Operation options.
     */ sendReadReceipt(request, options = {}) {
        return (0, _tslib.__awaiter)(this, void 0, void 0, function*() {
            const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-SendReadReceipt", options);
            try {
                yield this.client.chatThread.sendChatReadReceipt(this.threadId, request, (0, _coreHttp.operationOptionsToRequestOptionsBase)(updatedOptions));
            } catch (e) {
                span.setStatus({
                    code: (0, _api.CanonicalCode).UNKNOWN,
                    message: e.message
                });
                throw e;
            } finally{
                span.end();
            }
        });
    }
    listReadReceiptsPage(continuationState, options = {}) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listReadReceiptsPage_1() {
            const requestOptions = (0, _coreHttp.operationOptionsToRequestOptionsBase)(options);
            if (!continuationState.continuationToken) {
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chatThread.listChatReadReceipts(this.threadId, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value.map((0, _mappers.mapToReadReceiptSdkModel), this));
            }
            while(continuationState.continuationToken){
                const currentSetResponse = yield (0, _tslib.__await)(this.client.chatThread.listChatReadReceiptsNext(this.threadId, continuationState.continuationToken, requestOptions));
                continuationState.continuationToken = currentSetResponse.nextLink;
                if (currentSetResponse.value) yield yield (0, _tslib.__await)(currentSetResponse.value.map((0, _mappers.mapToReadReceiptSdkModel), this));
                else break;
            }
        });
    }
    listReadReceiptsAll(options) {
        return (0, _tslib.__asyncGenerator)(this, arguments, function* listReadReceiptsAll_1() {
            var e_3, _a;
            try {
                for(var _b = (0, _tslib.__asyncValues)(this.listReadReceiptsPage({}, options)), _c; _c = yield (0, _tslib.__await)(_b.next()), !_c.done;){
                    const page = _c.value;
                    yield (0, _tslib.__await)((yield* (0, _tslib.__asyncDelegator)((0, _tslib.__asyncValues)(page))));
                }
            } catch (e_3_1) {
                e_3 = {
                    error: e_3_1
                };
            } finally{
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield (0, _tslib.__await)(_a.call(_b));
                } finally{
                    if (e_3) throw e_3.error;
                }
            }
        });
    }
    /**
     * Gets a list of read receipt from a thread identified by threadId.
     * Returns the list of the messages.
     * @param options - Get messages options.
     */ listReadReceipts(options = {}) {
        const { span, updatedOptions } = (0, _tracing.createSpan)("ChatThreadClient-ListChatReadReceipts", options);
        try {
            const iter = this.listReadReceiptsAll(updatedOptions);
            return {
                next () {
                    return iter.next();
                },
                [Symbol.asyncIterator] () {
                    return this;
                },
                byPage: (settings = {})=>{
                    return this.listReadReceiptsPage(settings, updatedOptions);
                }
            };
        } catch (e) {
            span.setStatus({
                code: (0, _api.CanonicalCode).UNKNOWN,
                message: e.message
            });
            throw e;
        } finally{
            span.end();
        }
    }
    canPostTypingNotification(dateNow) {
        if (this.timeOfLastTypingRequest) {
            const timeSinceLastRequestInMilliSeconds = dateNow.getTime() - this.timeOfLastTypingRequest.getTime();
            if (timeSinceLastRequestInMilliSeconds < minimumTypingIntervalInMilliSeconds) {
                (0, _logger.logger).info(`Typing interval check failed. [last_request=${this.timeOfLastTypingRequest}]`);
                return false;
            }
        }
        return true;
    }
    constructor(endpoint, threadId, credential, options = {}){
        this.endpoint = endpoint;
        this.timeOfLastTypingRequest = undefined;
        this.threadId = threadId;
        this.tokenCredential = credential;
        const libInfo = `azsdk-js-communication-chat/${(0, _constants.SDK_VERSION)}`;
        if (!options.userAgentOptions) options.userAgentOptions = {};
        const userAgentOptions = Object.assign({}, options.userAgentOptions);
        if (options.userAgentOptions.userAgentPrefix) userAgentOptions.userAgentPrefix = `${options.userAgentOptions.userAgentPrefix} ${libInfo}`;
        else userAgentOptions.userAgentPrefix = libInfo;
        const internalPipelineOptions = Object.assign(Object.assign({}, Object.assign(Object.assign({}, options), {
            userAgentOptions
        })), {
            loggingOptions: {
                logger: (0, _logger.logger).info
            }
        });
        const authPolicy = (0, _communicationTokenCredentialPolicy.createCommunicationTokenCredentialPolicy)(this.tokenCredential);
        const pipeline = (0, _coreHttp.createPipelineFromOptions)(internalPipelineOptions, authPolicy);
        this.client = new (0, _src.ChatApiClient)(this.endpoint, pipeline);
    }
}

},{"tslib":"iC1Dx","./models/logger":"1SM0N","./constants":"k8iSE","@azure/communication-common":"cyhBF","@azure/core-http":"1W9s4","@opentelemetry/api":"4XvbA","./tracing":"LBQN1","./models/mappers":"g0ug2","./generated/src":"hBs8j","./credential/communicationTokenCredentialPolicy":"elp2u","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cyhBF":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AzureCommunicationTokenCredential", ()=>(0, _communicationTokenCredential.AzureCommunicationTokenCredential));
var _communicationTokenCredential = require("./communicationTokenCredential");
var _credential = require("./credential");
parcelHelpers.exportAll(_credential, exports);
parcelHelpers.exportAll(_credential, exports);
var _identifierModels = require("./identifierModels");
parcelHelpers.exportAll(_identifierModels, exports);
var _identifierModelSerializer = require("./identifierModelSerializer");
parcelHelpers.exportAll(_identifierModelSerializer, exports);

},{"./communicationTokenCredential":"n2nW1","./credential":false,"./identifierModels":false,"./identifierModelSerializer":"9o92d","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"n2nW1":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * The CommunicationTokenCredential implementation with support for proactive token refresh.
 */ parcelHelpers.export(exports, "AzureCommunicationTokenCredential", ()=>AzureCommunicationTokenCredential);
var _tokenParser = require("./tokenParser");
var _staticTokenCredential = require("./staticTokenCredential");
var _autoRefreshTokenCredential = require("./autoRefreshTokenCredential");
class AzureCommunicationTokenCredential {
    /**
     * Gets an `AccessToken` for the user. Throws if already disposed.
     * @param abortSignal - An implementation of `AbortSignalLike` to cancel the operation.
     */ async getToken(options) {
        this.throwIfDisposed();
        const token = await this.tokenCredential.getToken(options);
        this.throwIfDisposed();
        return token;
    }
    /**
     * Disposes the CommunicationTokenCredential and cancels any internal auto-refresh operation.
     */ dispose() {
        this.disposed = true;
        this.tokenCredential.dispose();
    }
    throwIfDisposed() {
        if (this.disposed) throw new Error("User credential is disposed");
    }
    constructor(tokenOrRefreshOptions){
        this.disposed = false;
        if (typeof tokenOrRefreshOptions === "string") this.tokenCredential = new (0, _staticTokenCredential.StaticTokenCredential)((0, _tokenParser.parseToken)(tokenOrRefreshOptions));
        else this.tokenCredential = new (0, _autoRefreshTokenCredential.AutoRefreshTokenCredential)(tokenOrRefreshOptions);
    }
}

},{"./tokenParser":"4pIMY","./staticTokenCredential":"i7MOt","./autoRefreshTokenCredential":"5Sh2K","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4pIMY":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseToken", ()=>parseToken);
var _jwtDecode = require("jwt-decode");
var _jwtDecodeDefault = parcelHelpers.interopDefault(_jwtDecode);
const parseToken = (token)=>{
    const { exp } = (0, _jwtDecodeDefault.default)(token);
    return {
        token,
        expiresOnTimestamp: exp * 1000
    };
};

},{"jwt-decode":"6VWWU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6VWWU":[function(require,module,exports,__globalThis) {
'use strict';
var base64_url_decode = require("1025c643d5f2e19d");
function InvalidTokenError(message) {
    this.message = message;
}
InvalidTokenError.prototype = new Error();
InvalidTokenError.prototype.name = 'InvalidTokenError';
module.exports = function(token, options) {
    if (typeof token !== 'string') throw new InvalidTokenError('Invalid token specified');
    options = options || {};
    var pos = options.header === true ? 0 : 1;
    try {
        return JSON.parse(base64_url_decode(token.split('.')[pos]));
    } catch (e) {
        throw new InvalidTokenError('Invalid token specified: ' + e.message);
    }
};
module.exports.InvalidTokenError = InvalidTokenError;

},{"1025c643d5f2e19d":"5566u"}],"5566u":[function(require,module,exports,__globalThis) {
var atob = require("4a391c007233120");
function b64DecodeUnicode(str) {
    return decodeURIComponent(atob(str).replace(/(.)/g, function(m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) code = '0' + code;
        return '%' + code;
    }));
}
module.exports = function(str) {
    var output = str.replace(/-/g, "+").replace(/_/g, "/");
    switch(output.length % 4){
        case 0:
            break;
        case 2:
            output += "==";
            break;
        case 3:
            output += "=";
            break;
        default:
            throw "Illegal base64url string!";
    }
    try {
        return b64DecodeUnicode(output);
    } catch (err) {
        return atob(output);
    }
};

},{"4a391c007233120":"50E0T"}],"50E0T":[function(require,module,exports,__globalThis) {
/**
 * The code was extracted from:
 * https://github.com/davidchambers/Base64.js
 */ var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
function InvalidCharacterError(message) {
    this.message = message;
}
InvalidCharacterError.prototype = new Error();
InvalidCharacterError.prototype.name = 'InvalidCharacterError';
function polyfill(input) {
    var str = String(input).replace(/=+$/, '');
    if (str.length % 4 == 1) throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    for(// initialize result and counters
    var bc = 0, bs, buffer, idx = 0, output = ''; // get next character
    buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;
    ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,
    // convert the first 8 bits to one ascii character
    bc++ % 4) && (output += String.fromCharCode(255 & bs >> (-2 * bc & 6))))// try to find character in table (0-63, not found => -1)
    buffer = chars.indexOf(buffer);
    return output;
}
module.exports = typeof window !== 'undefined' && window.atob && window.atob.bind(window) || polyfill;

},{}],"i7MOt":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * StaticTokenCredential
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StaticTokenCredential", ()=>StaticTokenCredential);
class StaticTokenCredential {
    async getToken() {
        return this.token;
    }
    dispose() {
    /* intentionally empty */ }
    constructor(token){
        this.token = token;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Sh2K":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AutoRefreshTokenCredential", ()=>AutoRefreshTokenCredential);
var _tokenParser = require("./tokenParser");
const expiredToken = {
    token: "",
    expiresOnTimestamp: -10
};
const minutesToMs = (minutes)=>minutes * 60000;
const defaultRefreshingInterval = minutesToMs(10);
class AutoRefreshTokenCredential {
    async getToken(options) {
        if (!this.isCurrentTokenExpiringSoon) return this.currentToken;
        const updatePromise = this.updateTokenAndReschedule(options === null || options === void 0 ? void 0 : options.abortSignal);
        if (!this.isCurrentTokenValid) await updatePromise;
        return this.currentToken;
    }
    dispose() {
        this.disposed = true;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.currentToken = expiredToken;
        if (this.activeTimeout) clearTimeout(this.activeTimeout);
    }
    async updateTokenAndReschedule(abortSignal) {
        if (this.activeTokenUpdating) return this.activeTokenUpdating;
        this.activeTokenUpdating = this.refreshTokenAndReschedule(abortSignal);
        try {
            await this.activeTokenUpdating;
        } finally{
            this.activeTokenUpdating = null;
        }
    }
    async refreshTokenAndReschedule(abortSignal) {
        this.currentToken = await this.refreshToken(abortSignal);
        if (this.refreshProactively) this.scheduleRefresh();
    }
    async refreshToken(abortSignal) {
        try {
            if (!this.activeTokenFetching) this.activeTokenFetching = this.refresh(abortSignal);
            return (0, _tokenParser.parseToken)(await this.activeTokenFetching);
        } finally{
            this.activeTokenFetching = null;
        }
    }
    scheduleRefresh() {
        if (this.disposed) return;
        if (this.activeTimeout) clearTimeout(this.activeTimeout);
        const timespanInMs = this.currentToken.expiresOnTimestamp - Date.now() - this.refreshingIntervalInMs;
        this.activeTimeout = setTimeout(()=>this.updateTokenAndReschedule(), timespanInMs);
    }
    get isCurrentTokenValid() {
        return this.currentToken && Date.now() < this.currentToken.expiresOnTimestamp;
    }
    get isCurrentTokenExpiringSoon() {
        return !this.currentToken || Date.now() >= this.currentToken.expiresOnTimestamp - this.refreshingIntervalInMs;
    }
    constructor(refreshArgs){
        this.refreshingIntervalInMs = defaultRefreshingInterval;
        this.activeTokenFetching = null;
        this.activeTokenUpdating = null;
        this.disposed = false;
        const { tokenRefresher, token, refreshProactively } = refreshArgs;
        this.refresh = tokenRefresher;
        this.currentToken = token ? (0, _tokenParser.parseToken)(token) : expiredToken;
        this.refreshProactively = refreshProactively !== null && refreshProactively !== void 0 ? refreshProactively : false;
        if (this.refreshProactively) this.scheduleRefresh();
    }
}

},{"./tokenParser":"4pIMY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cCU9X":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Tests an Identifier to determine whether it implements CommunicationUserIdentifier.
 *
 * @param identifier - The assumed CommunicationUserIdentifier to be tested.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isCommunicationUserIdentifier", ()=>isCommunicationUserIdentifier);
parcelHelpers.export(exports, "isPhoneNumberIdentifier", ()=>isPhoneNumberIdentifier);
parcelHelpers.export(exports, "isMicrosoftTeamsUserIdentifier", ()=>isMicrosoftTeamsUserIdentifier);
parcelHelpers.export(exports, "isUnknownIdentifier", ()=>isUnknownIdentifier);
parcelHelpers.export(exports, "getIdentifierKind", ()=>getIdentifierKind);
const isCommunicationUserIdentifier = (identifier)=>{
    return typeof identifier.communicationUserId === "string";
};
const isPhoneNumberIdentifier = (identifier)=>{
    return typeof identifier.phoneNumber === "string";
};
const isMicrosoftTeamsUserIdentifier = (identifier)=>{
    return typeof identifier.microsoftTeamsUserId === "string";
};
const isUnknownIdentifier = (identifier)=>{
    return typeof identifier.id === "string";
};
const getIdentifierKind = (identifier)=>{
    if (isCommunicationUserIdentifier(identifier)) return Object.assign(Object.assign({}, identifier), {
        kind: "communicationUser"
    });
    if (isPhoneNumberIdentifier(identifier)) return Object.assign(Object.assign({}, identifier), {
        kind: "phoneNumber"
    });
    if (isMicrosoftTeamsUserIdentifier(identifier)) return Object.assign(Object.assign({}, identifier), {
        kind: "microsoftTeamsUser"
    });
    return Object.assign(Object.assign({}, identifier), {
        kind: "unknown"
    });
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9o92d":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeCommunicationIdentifier", ()=>serializeCommunicationIdentifier);
parcelHelpers.export(exports, "deserializeCommunicationIdentifier", ()=>deserializeCommunicationIdentifier);
var _tslib = require("tslib");
var _identifierModels = require("./identifierModels");
const addRawIdIfExisting = (identifier, rawId)=>{
    return rawId === undefined ? identifier : Object.assign(Object.assign({}, identifier), {
        rawId: rawId
    });
};
const assertNotNullOrUndefined = (obj, prop)=>{
    const subObjName = Object.keys(obj)[0];
    const subObj = obj[subObjName];
    if (prop in subObj) return subObj[prop];
    throw new Error(`Property ${prop} is required for identifier of type ${subObjName}.`);
};
const assertMaximumOneNestedModel = (identifier)=>{
    const { rawId: _rawId } = identifier, props = (0, _tslib.__rest)(identifier, [
        "rawId"
    ]);
    const keys = Object.keys(props);
    if (keys.length > 1) throw new Error(`Only one of the properties in ${JSON.stringify(keys)} should be present.`);
};
const serializeCommunicationIdentifier = (identifier)=>{
    var _a, _b;
    const identifierKind = (0, _identifierModels.getIdentifierKind)(identifier);
    switch(identifierKind.kind){
        case "communicationUser":
            return {
                communicationUser: {
                    id: identifierKind.communicationUserId
                }
            };
        case "phoneNumber":
            return addRawIdIfExisting({
                phoneNumber: {
                    value: identifierKind.phoneNumber
                }
            }, identifierKind.rawId);
        case "microsoftTeamsUser":
            return addRawIdIfExisting({
                microsoftTeamsUser: {
                    userId: identifierKind.microsoftTeamsUserId,
                    isAnonymous: (_a = identifierKind.isAnonymous) !== null && _a !== void 0 ? _a : false,
                    cloud: (_b = identifierKind.cloud) !== null && _b !== void 0 ? _b : "public"
                }
            }, identifierKind.rawId);
        case "unknown":
            return {
                rawId: identifierKind.id
            };
        default:
            throw new Error(`Can't serialize an identifier with kind ${identifierKind.kind}`);
    }
};
const deserializeCommunicationIdentifier = (serializedIdentifier)=>{
    assertMaximumOneNestedModel(serializedIdentifier);
    const { communicationUser, microsoftTeamsUser, phoneNumber } = serializedIdentifier;
    if (communicationUser) return {
        kind: "communicationUser",
        communicationUserId: assertNotNullOrUndefined({
            communicationUser
        }, "id")
    };
    if (phoneNumber) return {
        kind: "phoneNumber",
        phoneNumber: assertNotNullOrUndefined({
            phoneNumber
        }, "value"),
        rawId: assertNotNullOrUndefined({
            phoneNumber: serializedIdentifier
        }, "rawId")
    };
    if (microsoftTeamsUser) return {
        kind: "microsoftTeamsUser",
        microsoftTeamsUserId: assertNotNullOrUndefined({
            microsoftTeamsUser
        }, "userId"),
        isAnonymous: assertNotNullOrUndefined({
            microsoftTeamsUser
        }, "isAnonymous"),
        cloud: assertNotNullOrUndefined({
            microsoftTeamsUser
        }, "cloud"),
        rawId: assertNotNullOrUndefined({
            microsoftTeamsUser: serializedIdentifier
        }, "rawId")
    };
    return {
        kind: "unknown",
        id: assertNotNullOrUndefined({
            unknown: serializedIdentifier
        }, "rawId")
    };
};

},{"tslib":"iC1Dx","./identifierModels":"cCU9X","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g0ug2":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapToCreateChatThreadOptionsRestModel", ()=>mapToCreateChatThreadOptionsRestModel);
parcelHelpers.export(exports, "mapToChatParticipantRestModel", ()=>mapToChatParticipantRestModel);
parcelHelpers.export(exports, "mapToAddChatParticipantsRequestRestModel", ()=>mapToAddChatParticipantsRequestRestModel);
parcelHelpers.export(exports, "mapToChatContentSdkModel", ()=>mapToChatContentSdkModel);
parcelHelpers.export(exports, "mapToChatMessageSdkModel", ()=>mapToChatMessageSdkModel);
parcelHelpers.export(exports, "mapToChatMessagesSdkModelArray", ()=>mapToChatMessagesSdkModelArray);
parcelHelpers.export(exports, "mapToChatParticipantSdkModel", ()=>mapToChatParticipantSdkModel);
parcelHelpers.export(exports, "mapToChatThreadPropertiesSdkModel", ()=>mapToChatThreadPropertiesSdkModel);
parcelHelpers.export(exports, "mapToCreateChatThreadResultSdkModel", ()=>mapToCreateChatThreadResultSdkModel);
parcelHelpers.export(exports, "mapToReadReceiptSdkModel", ()=>mapToReadReceiptSdkModel);
var _tslib = require("tslib");
var _communicationCommon = require("@azure/communication-common");
const mapToCreateChatThreadOptionsRestModel = (options)=>{
    const { participants, idempotencyToken } = options, rest = (0, _tslib.__rest)(options, [
        "participants",
        "idempotencyToken"
    ]);
    return Object.assign({
        repeatabilityRequestId: idempotencyToken
    }, rest);
};
const mapToChatParticipantRestModel = (chatParticipant)=>{
    const { id } = chatParticipant, rest = (0, _tslib.__rest)(chatParticipant, [
        "id"
    ]);
    return Object.assign(Object.assign({}, rest), {
        communicationIdentifier: (0, _communicationCommon.serializeCommunicationIdentifier)(id)
    });
};
const mapToAddChatParticipantsRequestRestModel = (addParticipantsRequest)=>{
    var _a;
    return {
        participants: (_a = addParticipantsRequest.participants) === null || _a === void 0 ? void 0 : _a.map((participant)=>mapToChatParticipantRestModel(participant))
    };
};
const mapToChatContentSdkModel = (content)=>{
    const { participants, initiatorCommunicationIdentifier } = content, otherChatContents = (0, _tslib.__rest)(content, [
        "participants",
        "initiatorCommunicationIdentifier"
    ]);
    let result = Object.assign({}, otherChatContents);
    if (initiatorCommunicationIdentifier) {
        const initiator = (0, _communicationCommon.deserializeCommunicationIdentifier)(initiatorCommunicationIdentifier);
        result = Object.assign(Object.assign({}, result), {
            initiator
        });
    }
    if (participants) result = Object.assign(Object.assign({}, result), {
        participants: participants === null || participants === void 0 ? void 0 : participants.map((participant)=>mapToChatParticipantSdkModel(participant))
    });
    return result;
};
const mapToChatMessageSdkModel = (chatMessage)=>{
    const { content, senderCommunicationIdentifier } = chatMessage, otherChatMessage = (0, _tslib.__rest)(chatMessage, [
        "content",
        "senderCommunicationIdentifier"
    ]);
    const contentSdkModel = content ? mapToChatContentSdkModel(content) : undefined;
    if (senderCommunicationIdentifier) return Object.assign({
        sender: (0, _communicationCommon.deserializeCommunicationIdentifier)(senderCommunicationIdentifier),
        content: contentSdkModel
    }, otherChatMessage);
    else return Object.assign({
        content: contentSdkModel
    }, otherChatMessage);
};
const mapToChatMessagesSdkModelArray = (chatMessagesCollection)=>{
    var _a;
    return (_a = chatMessagesCollection.value) === null || _a === void 0 ? void 0 : _a.map((chatMessage)=>mapToChatMessageSdkModel(chatMessage));
};
const mapToChatParticipantSdkModel = (chatParticipant)=>{
    const { communicationIdentifier } = chatParticipant, rest = (0, _tslib.__rest)(chatParticipant, [
        "communicationIdentifier"
    ]);
    return Object.assign(Object.assign({}, rest), {
        id: (0, _communicationCommon.deserializeCommunicationIdentifier)(communicationIdentifier)
    });
};
const mapToChatThreadPropertiesSdkModel = (chatThread)=>{
    const { createdByCommunicationIdentifier } = chatThread, rest = (0, _tslib.__rest)(chatThread, [
        "createdByCommunicationIdentifier"
    ]);
    if (createdByCommunicationIdentifier) return Object.assign(Object.assign({}, rest), {
        createdBy: (0, _communicationCommon.deserializeCommunicationIdentifier)(createdByCommunicationIdentifier)
    });
    else return Object.assign({}, rest);
};
const mapToCreateChatThreadResultSdkModel = (result)=>{
    const { chatThread } = result, rest = (0, _tslib.__rest)(result, [
        "chatThread"
    ]);
    if (chatThread) return Object.assign(Object.assign({}, rest), {
        chatThread: mapToChatThreadPropertiesSdkModel(chatThread)
    });
    else return Object.assign({}, rest);
};
const mapToReadReceiptSdkModel = (readReceipt)=>{
    const { senderCommunicationIdentifier } = readReceipt, rest = (0, _tslib.__rest)(readReceipt, [
        "senderCommunicationIdentifier"
    ]);
    return Object.assign(Object.assign({}, rest), {
        sender: (0, _communicationCommon.deserializeCommunicationIdentifier)(senderCommunicationIdentifier)
    });
};

},{"tslib":"iC1Dx","@azure/communication-common":"cyhBF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hBs8j":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChatApiClient", ()=>(0, _chatApiClient.ChatApiClient));
parcelHelpers.export(exports, "ChatApiClientContext", ()=>(0, _chatApiClientContext.ChatApiClientContext));
var _models = require("./models");
parcelHelpers.exportAll(_models, exports);
var _chatApiClient = require("./chatApiClient");
var _chatApiClientContext = require("./chatApiClientContext");

},{"./models":false,"./chatApiClient":"eWFch","./chatApiClientContext":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eWFch":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChatApiClient", ()=>ChatApiClient);
var _operations = require("./operations");
var _chatApiClientContext = require("./chatApiClientContext");
class ChatApiClient extends (0, _chatApiClientContext.ChatApiClientContext) {
    /**
     * Initializes a new instance of the ChatApiClient class.
     * @param endpoint The endpoint of the Azure Communication resource.
     * @param options The parameter options
     */ constructor(endpoint, options){
        super(endpoint, options);
        this.chatThread = new (0, _operations.ChatThread)(this);
        this.chat = new (0, _operations.Chat)(this);
    }
}

},{"./operations":"k38wy","./chatApiClientContext":"7Wo7X","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k38wy":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _chatThread = require("./chatThread");
parcelHelpers.exportAll(_chatThread, exports);
var _chat = require("./chat");
parcelHelpers.exportAll(_chat, exports);

},{"./chatThread":"dGk3h","./chat":"bQEJ5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dGk3h":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Class representing a ChatThread. */ parcelHelpers.export(exports, "ChatThread", ()=>ChatThread);
var _coreHttp = require("@azure/core-http");
var _mappers = require("../models/mappers");
var _parameters = require("../models/parameters");
class ChatThread {
    /**
     * Gets chat message read receipts for a thread.
     * @param chatThreadId Thread id to get the chat message read receipts for.
     * @param options The options parameters.
     */ listChatReadReceipts(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatReadReceiptsOperationSpec);
    }
    /**
     * Sends a read receipt event to a thread, on behalf of a user.
     * @param chatThreadId Thread id to send the read receipt event to.
     * @param sendReadReceiptRequest Read receipt details.
     * @param options The options parameters.
     */ sendChatReadReceipt(chatThreadId, sendReadReceiptRequest, options) {
        const operationArguments = {
            chatThreadId,
            sendReadReceiptRequest,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, sendChatReadReceiptOperationSpec);
    }
    /**
     * Sends a message to a thread.
     * @param chatThreadId The thread id to send the message to.
     * @param sendChatMessageRequest Details of the message to send.
     * @param options The options parameters.
     */ sendChatMessage(chatThreadId, sendChatMessageRequest, options) {
        const operationArguments = {
            chatThreadId,
            sendChatMessageRequest,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, sendChatMessageOperationSpec);
    }
    /**
     * Gets a list of messages from a thread.
     * @param chatThreadId The thread id of the message.
     * @param options The options parameters.
     */ listChatMessages(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatMessagesOperationSpec);
    }
    /**
     * Gets a message by id.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param options The options parameters.
     */ getChatMessage(chatThreadId, chatMessageId, options) {
        const operationArguments = {
            chatThreadId,
            chatMessageId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getChatMessageOperationSpec);
    }
    /**
     * Updates a message.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param updateChatMessageRequest Details of the request to update the message.
     * @param options The options parameters.
     */ updateChatMessage(chatThreadId, chatMessageId, updateChatMessageRequest, options) {
        const operationArguments = {
            chatThreadId,
            chatMessageId,
            updateChatMessageRequest,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, updateChatMessageOperationSpec);
    }
    /**
     * Deletes a message.
     * @param chatThreadId The thread id to which the message was sent.
     * @param chatMessageId The message id.
     * @param options The options parameters.
     */ deleteChatMessage(chatThreadId, chatMessageId, options) {
        const operationArguments = {
            chatThreadId,
            chatMessageId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteChatMessageOperationSpec);
    }
    /**
     * Posts a typing event to a thread, on behalf of a user.
     * @param chatThreadId Id of the thread.
     * @param options The options parameters.
     */ sendTypingNotification(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, sendTypingNotificationOperationSpec);
    }
    /**
     * Gets the participants of a thread.
     * @param chatThreadId Thread id to get participants for.
     * @param options The options parameters.
     */ listChatParticipants(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatParticipantsOperationSpec);
    }
    /**
     * Remove a participant from a thread.
     * @param chatThreadId Thread id to remove the participant from.
     * @param participantCommunicationIdentifier Id of the thread participant to remove from the thread.
     * @param options The options parameters.
     */ removeChatParticipant(chatThreadId, participantCommunicationIdentifier, options) {
        const operationArguments = {
            chatThreadId,
            participantCommunicationIdentifier,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, removeChatParticipantOperationSpec);
    }
    /**
     * Adds thread participants to a thread. If participants already exist, no change occurs.
     * @param chatThreadId Id of the thread to add participants to.
     * @param addChatParticipantsRequest Thread participants to be added to the thread.
     * @param options The options parameters.
     */ addChatParticipants(chatThreadId, addChatParticipantsRequest, options) {
        const operationArguments = {
            chatThreadId,
            addChatParticipantsRequest,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, addChatParticipantsOperationSpec);
    }
    /**
     * Updates a thread's properties.
     * @param chatThreadId The id of the thread to update.
     * @param updateChatThreadRequest Request payload for updating a chat thread.
     * @param options The options parameters.
     */ updateChatThreadProperties(chatThreadId, updateChatThreadRequest, options) {
        const operationArguments = {
            chatThreadId,
            updateChatThreadRequest,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, updateChatThreadPropertiesOperationSpec);
    }
    /**
     * Gets a chat thread's properties.
     * @param chatThreadId Id of the thread.
     * @param options The options parameters.
     */ getChatThreadProperties(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, getChatThreadPropertiesOperationSpec);
    }
    /**
     * ListChatReadReceiptsNext
     * @param chatThreadId Thread id to get the chat message read receipts for.
     * @param nextLink The nextLink from the previous successful call to the ListChatReadReceipts method.
     * @param options The options parameters.
     */ listChatReadReceiptsNext(chatThreadId, nextLink, options) {
        const operationArguments = {
            chatThreadId,
            nextLink,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatReadReceiptsNextOperationSpec);
    }
    /**
     * ListChatMessagesNext
     * @param chatThreadId The thread id of the message.
     * @param nextLink The nextLink from the previous successful call to the ListChatMessages method.
     * @param options The options parameters.
     */ listChatMessagesNext(chatThreadId, nextLink, options) {
        const operationArguments = {
            chatThreadId,
            nextLink,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatMessagesNextOperationSpec);
    }
    /**
     * ListChatParticipantsNext
     * @param chatThreadId Thread id to get participants for.
     * @param nextLink The nextLink from the previous successful call to the ListChatParticipants method.
     * @param options The options parameters.
     */ listChatParticipantsNext(chatThreadId, nextLink, options) {
        const operationArguments = {
            chatThreadId,
            nextLink,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatParticipantsNextOperationSpec);
    }
    /**
     * Initialize a new instance of the class ChatThread class.
     * @param client Reference to the service client
     */ constructor(client){
        this.client = client;
    }
}
// Operation Specifications
const serializer = new _coreHttp.Serializer(_mappers, /* isXml */ false);
const listChatReadReceiptsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/readReceipts",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatMessageReadReceiptsCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.skip,
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const sendChatReadReceiptOperationSpec = {
    path: "/chat/threads/{chatThreadId}/readReceipts",
    httpMethod: "POST",
    responses: {
        200: {},
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: _parameters.sendReadReceiptRequest,
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept,
        _parameters.contentType
    ],
    mediaType: "json",
    serializer
};
const sendChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: _mappers.SendChatMessageResult
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: _parameters.sendChatMessageRequest,
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept,
        _parameters.contentType
    ],
    mediaType: "json",
    serializer
};
const listChatMessagesOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatMessagesCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.apiVersion,
        _parameters.startTime
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const getChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatMessage
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId,
        _parameters.chatMessageId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const updateChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "PATCH",
    responses: {
        204: {},
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: _parameters.updateChatMessageRequest,
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId,
        _parameters.chatMessageId
    ],
    headerParameters: [
        _parameters.accept,
        _parameters.contentType1
    ],
    mediaType: "json",
    serializer
};
const deleteChatMessageOperationSpec = {
    path: "/chat/threads/{chatThreadId}/messages/{chatMessageId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId,
        _parameters.chatMessageId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const sendTypingNotificationOperationSpec = {
    path: "/chat/threads/{chatThreadId}/typing",
    httpMethod: "POST",
    responses: {
        200: {},
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const listChatParticipantsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatParticipantsCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.skip,
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const removeChatParticipantOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants/:remove",
    httpMethod: "POST",
    responses: {
        204: {},
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: _parameters.participantCommunicationIdentifier,
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept,
        _parameters.contentType
    ],
    mediaType: "json",
    serializer
};
const addChatParticipantsOperationSpec = {
    path: "/chat/threads/{chatThreadId}/participants/:add",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: _mappers.AddChatParticipantsResult
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: _parameters.addChatParticipantsRequest,
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept,
        _parameters.contentType
    ],
    mediaType: "json",
    serializer
};
const updateChatThreadPropertiesOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "PATCH",
    responses: {
        204: {},
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: _parameters.updateChatThreadRequest,
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept,
        _parameters.contentType1
    ],
    mediaType: "json",
    serializer
};
const getChatThreadPropertiesOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatThreadProperties
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const listChatReadReceiptsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatMessageReadReceiptsCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.skip,
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId,
        _parameters.nextLink
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const listChatMessagesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatMessagesCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.apiVersion,
        _parameters.startTime
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId,
        _parameters.nextLink
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const listChatParticipantsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatParticipantsCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.skip,
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId,
        _parameters.nextLink
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};

},{"@azure/core-http":"1W9s4","../models/mappers":"9jD9F","../models/parameters":"05esf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9jD9F":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChatMessageReadReceiptsCollection", ()=>ChatMessageReadReceiptsCollection);
parcelHelpers.export(exports, "ChatMessageReadReceipt", ()=>ChatMessageReadReceipt);
parcelHelpers.export(exports, "CommunicationIdentifierModel", ()=>CommunicationIdentifierModel);
parcelHelpers.export(exports, "CommunicationUserIdentifierModel", ()=>CommunicationUserIdentifierModel);
parcelHelpers.export(exports, "PhoneNumberIdentifierModel", ()=>PhoneNumberIdentifierModel);
parcelHelpers.export(exports, "MicrosoftTeamsUserIdentifierModel", ()=>MicrosoftTeamsUserIdentifierModel);
parcelHelpers.export(exports, "CommunicationErrorResponse", ()=>CommunicationErrorResponse);
parcelHelpers.export(exports, "ChatError", ()=>ChatError);
parcelHelpers.export(exports, "SendReadReceiptRequest", ()=>SendReadReceiptRequest);
parcelHelpers.export(exports, "SendChatMessageRequest", ()=>SendChatMessageRequest);
parcelHelpers.export(exports, "SendChatMessageResult", ()=>SendChatMessageResult);
parcelHelpers.export(exports, "ChatMessagesCollection", ()=>ChatMessagesCollection);
parcelHelpers.export(exports, "ChatMessage", ()=>ChatMessage);
parcelHelpers.export(exports, "ChatMessageContent", ()=>ChatMessageContent);
parcelHelpers.export(exports, "ChatParticipant", ()=>ChatParticipant);
parcelHelpers.export(exports, "UpdateChatMessageRequest", ()=>UpdateChatMessageRequest);
parcelHelpers.export(exports, "ChatParticipantsCollection", ()=>ChatParticipantsCollection);
parcelHelpers.export(exports, "AddChatParticipantsRequest", ()=>AddChatParticipantsRequest);
parcelHelpers.export(exports, "AddChatParticipantsResult", ()=>AddChatParticipantsResult);
parcelHelpers.export(exports, "CreateChatThreadRequest", ()=>CreateChatThreadRequest);
parcelHelpers.export(exports, "CreateChatThreadResult", ()=>CreateChatThreadResult);
parcelHelpers.export(exports, "ChatThreadProperties", ()=>ChatThreadProperties);
parcelHelpers.export(exports, "ChatThreadsItemCollection", ()=>ChatThreadsItemCollection);
parcelHelpers.export(exports, "ChatThreadItem", ()=>ChatThreadItem);
parcelHelpers.export(exports, "UpdateChatThreadRequest", ()=>UpdateChatThreadRequest);
const ChatMessageReadReceiptsCollection = {
    type: {
        name: "Composite",
        className: "ChatMessageReadReceiptsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatMessageReadReceipt"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatMessageReadReceipt = {
    type: {
        name: "Composite",
        className: "ChatMessageReadReceipt",
        modelProperties: {
            senderCommunicationIdentifier: {
                serializedName: "senderCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            chatMessageId: {
                serializedName: "chatMessageId",
                required: true,
                type: {
                    name: "String"
                }
            },
            readOn: {
                serializedName: "readOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const CommunicationIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationIdentifierModel",
        modelProperties: {
            rawId: {
                serializedName: "rawId",
                type: {
                    name: "String"
                }
            },
            communicationUser: {
                serializedName: "communicationUser",
                type: {
                    name: "Composite",
                    className: "CommunicationUserIdentifierModel"
                }
            },
            phoneNumber: {
                serializedName: "phoneNumber",
                type: {
                    name: "Composite",
                    className: "PhoneNumberIdentifierModel"
                }
            },
            microsoftTeamsUser: {
                serializedName: "microsoftTeamsUser",
                type: {
                    name: "Composite",
                    className: "MicrosoftTeamsUserIdentifierModel"
                }
            }
        }
    }
};
const CommunicationUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "CommunicationUserIdentifierModel",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PhoneNumberIdentifierModel = {
    type: {
        name: "Composite",
        className: "PhoneNumberIdentifierModel",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const MicrosoftTeamsUserIdentifierModel = {
    type: {
        name: "Composite",
        className: "MicrosoftTeamsUserIdentifierModel",
        modelProperties: {
            userId: {
                serializedName: "userId",
                required: true,
                type: {
                    name: "String"
                }
            },
            isAnonymous: {
                serializedName: "isAnonymous",
                type: {
                    name: "Boolean"
                }
            },
            cloud: {
                serializedName: "cloud",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CommunicationErrorResponse = {
    type: {
        name: "Composite",
        className: "CommunicationErrorResponse",
        modelProperties: {
            error: {
                serializedName: "error",
                type: {
                    name: "Composite",
                    className: "ChatError"
                }
            }
        }
    }
};
const ChatError = {
    type: {
        name: "Composite",
        className: "ChatError",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            },
            target: {
                serializedName: "target",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            details: {
                serializedName: "details",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError"
                        }
                    }
                }
            },
            innerError: {
                serializedName: "innererror",
                type: {
                    name: "Composite",
                    className: "ChatError"
                }
            }
        }
    }
};
const SendReadReceiptRequest = {
    type: {
        name: "Composite",
        className: "SendReadReceiptRequest",
        modelProperties: {
            chatMessageId: {
                serializedName: "chatMessageId",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SendChatMessageRequest = {
    type: {
        name: "Composite",
        className: "SendChatMessageRequest",
        modelProperties: {
            content: {
                serializedName: "content",
                required: true,
                type: {
                    name: "String"
                }
            },
            senderDisplayName: {
                serializedName: "senderDisplayName",
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const SendChatMessageResult = {
    type: {
        name: "Composite",
        className: "SendChatMessageResult",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatMessagesCollection = {
    type: {
        name: "Composite",
        className: "ChatMessagesCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatMessage"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatMessage = {
    type: {
        name: "Composite",
        className: "ChatMessage",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            type: {
                serializedName: "type",
                required: true,
                type: {
                    name: "String"
                }
            },
            sequenceId: {
                serializedName: "sequenceId",
                required: true,
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "version",
                required: true,
                type: {
                    name: "String"
                }
            },
            content: {
                serializedName: "content",
                type: {
                    name: "Composite",
                    className: "ChatMessageContent"
                }
            },
            senderDisplayName: {
                serializedName: "senderDisplayName",
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            senderCommunicationIdentifier: {
                serializedName: "senderCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime"
                }
            },
            editedOn: {
                serializedName: "editedOn",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ChatMessageContent = {
    type: {
        name: "Composite",
        className: "ChatMessageContent",
        modelProperties: {
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            topic: {
                serializedName: "topic",
                type: {
                    name: "String"
                }
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            },
            initiatorCommunicationIdentifier: {
                serializedName: "initiatorCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            }
        }
    }
};
const ChatParticipant = {
    type: {
        name: "Composite",
        className: "ChatParticipant",
        modelProperties: {
            communicationIdentifier: {
                serializedName: "communicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            shareHistoryTime: {
                serializedName: "shareHistoryTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const UpdateChatMessageRequest = {
    type: {
        name: "Composite",
        className: "UpdateChatMessageRequest",
        modelProperties: {
            content: {
                serializedName: "content",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatParticipantsCollection = {
    type: {
        name: "Composite",
        className: "ChatParticipantsCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AddChatParticipantsRequest = {
    type: {
        name: "Composite",
        className: "AddChatParticipantsRequest",
        modelProperties: {
            participants: {
                serializedName: "participants",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            }
        }
    }
};
const AddChatParticipantsResult = {
    type: {
        name: "Composite",
        className: "AddChatParticipantsResult",
        modelProperties: {
            invalidParticipants: {
                serializedName: "invalidParticipants",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError"
                        }
                    }
                }
            }
        }
    }
};
const CreateChatThreadRequest = {
    type: {
        name: "Composite",
        className: "CreateChatThreadRequest",
        modelProperties: {
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String"
                }
            },
            participants: {
                serializedName: "participants",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatParticipant"
                        }
                    }
                }
            }
        }
    }
};
const CreateChatThreadResult = {
    type: {
        name: "Composite",
        className: "CreateChatThreadResult",
        modelProperties: {
            chatThread: {
                serializedName: "chatThread",
                type: {
                    name: "Composite",
                    className: "ChatThreadProperties"
                }
            },
            invalidParticipants: {
                serializedName: "invalidParticipants",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatError"
                        }
                    }
                }
            }
        }
    }
};
const ChatThreadProperties = {
    type: {
        name: "Composite",
        className: "ChatThreadProperties",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdOn",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            createdByCommunicationIdentifier: {
                serializedName: "createdByCommunicationIdentifier",
                type: {
                    name: "Composite",
                    className: "CommunicationIdentifierModel"
                }
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ChatThreadsItemCollection = {
    type: {
        name: "Composite",
        className: "ChatThreadsItemCollection",
        modelProperties: {
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ChatThreadItem"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "nextLink",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ChatThreadItem = {
    type: {
        name: "Composite",
        className: "ChatThreadItem",
        modelProperties: {
            id: {
                serializedName: "id",
                required: true,
                type: {
                    name: "String"
                }
            },
            topic: {
                serializedName: "topic",
                required: true,
                type: {
                    name: "String"
                }
            },
            deletedOn: {
                serializedName: "deletedOn",
                type: {
                    name: "DateTime"
                }
            },
            lastMessageReceivedOn: {
                serializedName: "lastMessageReceivedOn",
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const UpdateChatThreadRequest = {
    type: {
        name: "Composite",
        className: "UpdateChatThreadRequest",
        modelProperties: {
            topic: {
                serializedName: "topic",
                type: {
                    name: "String"
                }
            }
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"05esf":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "accept", ()=>accept);
parcelHelpers.export(exports, "endpoint", ()=>endpoint);
parcelHelpers.export(exports, "chatThreadId", ()=>chatThreadId);
parcelHelpers.export(exports, "maxPageSize", ()=>maxPageSize);
parcelHelpers.export(exports, "skip", ()=>skip);
parcelHelpers.export(exports, "apiVersion", ()=>apiVersion);
parcelHelpers.export(exports, "contentType", ()=>contentType);
parcelHelpers.export(exports, "sendReadReceiptRequest", ()=>sendReadReceiptRequest);
parcelHelpers.export(exports, "sendChatMessageRequest", ()=>sendChatMessageRequest);
parcelHelpers.export(exports, "startTime", ()=>startTime);
parcelHelpers.export(exports, "chatMessageId", ()=>chatMessageId);
parcelHelpers.export(exports, "contentType1", ()=>contentType1);
parcelHelpers.export(exports, "updateChatMessageRequest", ()=>updateChatMessageRequest);
parcelHelpers.export(exports, "participantCommunicationIdentifier", ()=>participantCommunicationIdentifier);
parcelHelpers.export(exports, "addChatParticipantsRequest", ()=>addChatParticipantsRequest);
parcelHelpers.export(exports, "updateChatThreadRequest", ()=>updateChatThreadRequest);
parcelHelpers.export(exports, "nextLink", ()=>nextLink);
parcelHelpers.export(exports, "createChatThreadRequest", ()=>createChatThreadRequest);
parcelHelpers.export(exports, "repeatabilityRequestId", ()=>repeatabilityRequestId);
var _mappers = require("../models/mappers");
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const chatThreadId = {
    parameterPath: "chatThreadId",
    mapper: {
        serializedName: "chatThreadId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const maxPageSize = {
    parameterPath: [
        "options",
        "maxPageSize"
    ],
    mapper: {
        serializedName: "maxPageSize",
        type: {
            name: "Number"
        }
    }
};
const skip = {
    parameterPath: [
        "options",
        "skip"
    ],
    mapper: {
        serializedName: "skip",
        type: {
            name: "Number"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "2021-03-07",
        isConstant: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: [
        "options",
        "contentType"
    ],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const sendReadReceiptRequest = {
    parameterPath: "sendReadReceiptRequest",
    mapper: (0, _mappers.SendReadReceiptRequest)
};
const sendChatMessageRequest = {
    parameterPath: "sendChatMessageRequest",
    mapper: (0, _mappers.SendChatMessageRequest)
};
const startTime = {
    parameterPath: [
        "options",
        "startTime"
    ],
    mapper: {
        serializedName: "startTime",
        type: {
            name: "DateTime"
        }
    }
};
const chatMessageId = {
    parameterPath: "chatMessageId",
    mapper: {
        serializedName: "chatMessageId",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: [
        "options",
        "contentType"
    ],
    mapper: {
        defaultValue: "application/merge-patch+json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const updateChatMessageRequest = {
    parameterPath: "updateChatMessageRequest",
    mapper: (0, _mappers.UpdateChatMessageRequest)
};
const participantCommunicationIdentifier = {
    parameterPath: "participantCommunicationIdentifier",
    mapper: (0, _mappers.CommunicationIdentifierModel)
};
const addChatParticipantsRequest = {
    parameterPath: "addChatParticipantsRequest",
    mapper: (0, _mappers.AddChatParticipantsRequest)
};
const updateChatThreadRequest = {
    parameterPath: "updateChatThreadRequest",
    mapper: (0, _mappers.UpdateChatThreadRequest)
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const createChatThreadRequest = {
    parameterPath: "createChatThreadRequest",
    mapper: (0, _mappers.CreateChatThreadRequest)
};
const repeatabilityRequestId = {
    parameterPath: [
        "options",
        "repeatabilityRequestId"
    ],
    mapper: {
        serializedName: "repeatability-request-id",
        type: {
            name: "String"
        }
    }
};

},{"../models/mappers":"9jD9F","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bQEJ5":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Class representing a Chat. */ parcelHelpers.export(exports, "Chat", ()=>Chat);
var _coreHttp = require("@azure/core-http");
var _mappers = require("../models/mappers");
var _parameters = require("../models/parameters");
class Chat {
    /**
     * Creates a chat thread.
     * @param createChatThreadRequest Request payload for creating a chat thread.
     * @param options The options parameters.
     */ createChatThread(createChatThreadRequest, options) {
        const operationArguments = {
            createChatThreadRequest,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, createChatThreadOperationSpec);
    }
    /**
     * Gets the list of chat threads of a user.
     * @param options The options parameters.
     */ listChatThreads(options) {
        const operationArguments = {
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatThreadsOperationSpec);
    }
    /**
     * Deletes a thread.
     * @param chatThreadId Id of the thread to be deleted.
     * @param options The options parameters.
     */ deleteChatThread(chatThreadId, options) {
        const operationArguments = {
            chatThreadId,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, deleteChatThreadOperationSpec);
    }
    /**
     * ListChatThreadsNext
     * @param nextLink The nextLink from the previous successful call to the ListChatThreads method.
     * @param options The options parameters.
     */ listChatThreadsNext(nextLink, options) {
        const operationArguments = {
            nextLink,
            options: _coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        return this.client.sendOperationRequest(operationArguments, listChatThreadsNextOperationSpec);
    }
    /**
     * Initialize a new instance of the class Chat class.
     * @param client Reference to the service client
     */ constructor(client){
        this.client = client;
    }
}
// Operation Specifications
const serializer = new _coreHttp.Serializer(_mappers, /* isXml */ false);
const createChatThreadOperationSpec = {
    path: "/chat/threads",
    httpMethod: "POST",
    responses: {
        201: {
            bodyMapper: _mappers.CreateChatThreadResult
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    requestBody: _parameters.createChatThreadRequest,
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint
    ],
    headerParameters: [
        _parameters.accept,
        _parameters.contentType,
        _parameters.repeatabilityRequestId
    ],
    mediaType: "json",
    serializer
};
const listChatThreadsOperationSpec = {
    path: "/chat/threads",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatThreadsItemCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.apiVersion,
        _parameters.startTime
    ],
    urlParameters: [
        _parameters.endpoint
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const deleteChatThreadOperationSpec = {
    path: "/chat/threads/{chatThreadId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.apiVersion
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.chatThreadId
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};
const listChatThreadsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: _mappers.ChatThreadsItemCollection
        },
        401: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        403: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        429: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        },
        503: {
            bodyMapper: _mappers.CommunicationErrorResponse,
            isError: true
        }
    },
    queryParameters: [
        _parameters.maxPageSize,
        _parameters.apiVersion,
        _parameters.startTime
    ],
    urlParameters: [
        _parameters.endpoint,
        _parameters.nextLink
    ],
    headerParameters: [
        _parameters.accept
    ],
    serializer
};

},{"@azure/core-http":"1W9s4","../models/mappers":"9jD9F","../models/parameters":"05esf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Wo7X":[function(require,module,exports,__globalThis) {
/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChatApiClientContext", ()=>ChatApiClientContext);
var _coreHttp = require("@azure/core-http");
const packageName = "azure-communication-chat";
const packageVersion = "1.0.0";
class ChatApiClientContext extends _coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the ChatApiClientContext class.
     * @param endpoint The endpoint of the Azure Communication resource.
     * @param options The parameter options
     */ constructor(endpoint, options){
        if (endpoint === undefined) throw new Error("'endpoint' cannot be null");
        // Initializing default values for options
        if (!options) options = {};
        if (!options.userAgent) {
            const defaultUserAgent = _coreHttp.getDefaultUserAgentValue();
            options.userAgent = `${packageName}/${packageVersion} ${defaultUserAgent}`;
        }
        super(undefined, options);
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri = options.endpoint || "{endpoint}";
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "2021-03-07";
    }
}

},{"@azure/core-http":"1W9s4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"elp2u":[function(require,module,exports,__globalThis) {
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCommunicationTokenCredentialPolicy", ()=>createCommunicationTokenCredentialPolicy);
var _coreHttp = require("@azure/core-http");
const createCommunicationTokenCredentialPolicy = (credential)=>{
    return (0, _coreHttp.bearerTokenAuthenticationPolicy)({
        getToken: (_scopes, options)=>credential.getToken({
                abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal
            })
    }, []);
};

},{"@azure/core-http":"1W9s4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gGuDA":[function(require,module,exports,__globalThis) {
// Azure OpenAI Configuration
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SummaryService", ()=>SummaryService);
const AZURE_OPENAI_ENDPOINT = 'https://alexper-test.openai.azure.com';
const AZURE_OPENAI_KEY = '6f33abc23fe145e1942699fb513479b9';
const DEPLOYMENT_NAME = 'gpt-35-turbo';
const API_VERSION = '2024-02-15-preview';
class BotService {
    // Initialize conversation with greeting
    async startConversation() {
        const greeting = {
            role: "assistant",
            content: "\uD83D\uDC4B Hello! I'm the Contoso Airlines automated customer service assistant. How can I assist you today?"
        };
        this.conversationHistory.push(greeting);
        return greeting.content;
    }
    // Deactivate bot (when agent takes over)
    deactivate() {
        this.isActive = false;
        return "A customer service agent will be taking over the conversation. Thank you for your patience.";
    }
    // Check if bot is active
    isEnabled() {
        return this.isActive;
    }
    // Process a message through Azure OpenAI
    async processMessage(userMessage) {
        if (!this.isActive) return null;
        try {
            // Add user message to history
            this.conversationHistory.push({
                role: "user",
                content: userMessage
            });
            // Prepare the messages array with system prompt and conversation history
            const messages = [
                {
                    role: "assistant",
                    content: 'You are a virtual customer service agent for Contoso Airlines. Your job is to assist customers with their questions in a clear, concise, and professional manner. Your responses should be specific, helpful, and relevant, avoiding vague or overly general answers.\n\n### Guidelines for Responses:\n- Provide specific answers whenever possible. Avoid simply directing customers to a website unless absolutely necessary.\n- Use real policies and example fees when applicable, but note that prices may vary.\n- Stay on topic. Answer only the question asked and avoid unnecessary details.\n- Maintain a professional and friendly tone. Keep responses polite and easy to understand.\n\n### Example Responses:\n\n- **Customer:** "How much does it cost to bring my golf clubs?"\n  - **Correct:** "Golf clubs can be checked as baggage. Depending on your fare type, they may be included for free or subject to an oversize fee of $50\u2013$100."\n  - **Incorrect:** "Fees depend on your fare type. Check the website for more details."\n\n- **Customer:** "Can I change my flight date?"\n  - **Correct:** "Yes, you can change your flight date, but a change fee of $75\u2013$200 may apply based on your ticket type."\n  - **Incorrect:** "Flight changes depend on fare type. Visit our website for details."\n\n- **Customer:** "When does online check-in open?"\n  - **Correct:** "Online check-in opens 24 hours before departure and closes 60 minutes before domestic flights and 90 minutes before international flights."\n  - **Incorrect:** "Check-in times vary. Check our website for more information."\n\n### Additional Common Questions and Ideal Answers:\n- **Customer:** "Can I bring a carry-on bag for free?"\n  - "Yes, most tickets allow one free carry-on bag (22 x 14 x 9 inches) and one personal item. Basic Economy fares may have restrictions."\n- **Customer:** "What\'s the weight limit for checked baggage?"\n  - "Checked bags must not exceed 50 lbs (23 kg). Overweight fees apply for bags up to 70 lbs (32 kg)."\n- **Customer:** "What happens if my baggage is lost?"\n  - "Report your lost baggage at the airport or online. We will track your bag and update you within 24 hours. Compensation may be available if not found within 5 days."\n- **Customer:** "Can I bring a pet on the plane?"\n  - "Yes, small pets can travel in the cabin for a $125 fee. Larger pets must travel as checked baggage. Restrictions apply."\n- **Customer:** "How do I request wheelchair assistance?"\n  - "You can request wheelchair assistance during booking or by calling customer service 48 hours before departure."\n- **Customer:** "How long do refunds take?"\n  - "Refunds are typically processed within 7\u201310 business days."\n\nYour primary goal is to provide quick, clear, and helpful answers while maintaining professionalism. If you cannot provide an exact answer, offer useful guidelines or direct the customer to the best next step.'
                },
                ...this.conversationHistory
            ];
            // Call Azure OpenAI API
            const response = await fetch(`${AZURE_OPENAI_ENDPOINT}/openai/deployments/${DEPLOYMENT_NAME}/chat/completions?api-version=${API_VERSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'api-key': AZURE_OPENAI_KEY
                },
                body: JSON.stringify({
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 800
                })
            });
            if (!response.ok) throw new Error(`API call failed: ${response.statusText}`);
            const data = await response.json();
            const botResponse = data.choices[0].message.content;
            // Add bot response to history
            this.conversationHistory.push({
                role: "assistant",
                content: botResponse
            });
            return botResponse;
        } catch (error) {
            console.error('Error processing message with Azure OpenAI:', error);
            return "I apologize, but I'm having trouble processing your request. Please try again or speak with a human agent.";
        }
    }
    constructor(){
        this.conversationHistory = [];
        this.isActive = true; // Bot starts active
    }
}
class SummaryService {
    async generateSummary(messages) {
        try {
            console.log('Starting summary generation with', messages.length, 'messages');
            const systemPrompt = {
                role: "system",
                content: "You are a professional conversation summarizer for a customer service chat. Create a clear, complete, and concise summary of the conversation between a customer and customer service. Focus on:\n1. Customer's main inquiry or issue\n2. Key details provided by the customer\n3. Responses provided by customer service\n4. Current status and any unresolved questions\n\nKeep the summary brief but comprehensive, capturing the full conversation thread."
            };
            // Direct extraction of messages for debugging
            console.log('RAW MESSAGE DUMP (first 3 messages):');
            for(let i = 0; i < Math.min(3, messages.length); i++)console.log(`Message ${i + 1} FULL:`, JSON.stringify(messages[i]));
            // Filter out system messages and prepare conversation history
            const conversationMessages = [];
            console.log('Converting Azure Chat API messages to OpenAI format...');
            for(let i = 0; i < messages.length; i++){
                const msg = messages[i];
                // Advanced content extraction
                let messageContent = null;
                const senderName = msg.senderDisplayName || 'Unknown';
                // Try multiple ways to extract content
                if (msg.content && typeof msg.content === 'string') messageContent = msg.content;
                else if (msg.content && typeof msg.content === 'object') messageContent = msg.content.message || msg.content.content || '';
                else if (msg.message) messageContent = msg.message;
                else {
                    // Look for content in other properties
                    const msgStr = JSON.stringify(msg);
                    const contentMatch = msgStr.match(/"content":"([^"]+)"/);
                    if (contentMatch && contentMatch[1]) messageContent = contentMatch[1];
                }
                // Make sure we have content
                if (!messageContent || messageContent.trim() === '') {
                    console.log(`Skipping message ${i + 1} from ${senderName}: no content found`);
                    continue;
                }
                // Skip system messages
                if (senderName === 'System') {
                    console.log(`Skipping system message ${i + 1}: ${messageContent.substring(0, 30)}...`);
                    continue;
                }
                // Determine role based on sender
                let role = 'assistant';
                if (senderName === 'Sarah Jones') role = 'user';
                else if (senderName === 'AI Assistant') role = 'assistant';
                else if (senderName === 'Support Agent') role = 'assistant';
                const formattedMessage = {
                    role: role,
                    content: messageContent
                };
                conversationMessages.push(formattedMessage);
                console.log(`Added message ${i + 1} from ${senderName} (${role}): ${messageContent.substring(0, 50)}...`);
            }
            if (conversationMessages.length === 0) {
                console.log('No valid messages to summarize');
                return "No messages to summarize yet.";
            }
            console.log(`Prepared ${conversationMessages.length} messages for summary`);
            // Create the "story" of the conversation in chronological order
            const sortedMessages = [
                ...conversationMessages
            ];
            console.log('Conversation flow:');
            sortedMessages.forEach((msg, i)=>{
                console.log(`${i + 1}. ${msg.role}: ${msg.content.substring(0, 30)}...`);
            });
            // Make API call with the full conversation
            const requestBody = {
                messages: [
                    systemPrompt,
                    ...sortedMessages
                ],
                temperature: 0.5,
                max_tokens: 500
            };
            console.log('Request payload size:', JSON.stringify(requestBody).length, 'characters');
            const response = await fetch(`${AZURE_OPENAI_ENDPOINT}/openai/deployments/${DEPLOYMENT_NAME}/chat/completions?api-version=${API_VERSION}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'api-key': AZURE_OPENAI_KEY
                },
                body: JSON.stringify(requestBody)
            });
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API response error:', response.status, errorText);
                throw new Error(`API call failed: ${response.statusText}. Details: ${errorText}`);
            }
            const data = await response.json();
            console.log('API response received successfully');
            this.lastSummaryTime = new Date();
            return data.choices[0].message.content;
        } catch (error) {
            console.error('Error generating summary:', error);
            throw error;
        }
    }
    shouldAllowNewSummary(messages, lastMessageTime) {
        // Always allow a summary
        return true;
    }
    constructor(){
        this.lastSummaryTime = null;
    }
}
exports.default = BotService;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}]},["ot36a","lsDBr"], "lsDBr", "parcelRequired7e8")

//# sourceMappingURL=Simple-bot-handoff-sample.b5a3cd24.js.map
